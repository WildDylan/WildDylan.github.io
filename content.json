{"meta":{"title":"dylan","subtitle":"inclusiveness!","description":"dylan's github.io blog.","author":"dylan","url":"https://wilddylan.github.io"},"pages":[{"title":"Categories","date":"2017-02-16T05:42:59.000Z","updated":"2016-10-12T10:07:19.000Z","comments":true,"path":"categories/index.html","permalink":"https://wilddylan.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2017-02-16T05:42:59.000Z","updated":"2016-10-12T10:07:19.000Z","comments":true,"path":"about/index.html","permalink":"https://wilddylan.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-02-16T05:42:59.000Z","updated":"2016-10-12T10:07:19.000Z","comments":true,"path":"tags/index.html","permalink":"https://wilddylan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"New Year's 2017","slug":"New Year's 2017","date":"2017-03-16T11:06:06.000Z","updated":"2017-03-17T02:04:18.000Z","comments":true,"path":"2017/03/16/New Year's 2017/","link":"","permalink":"https://wilddylan.github.io/2017/03/16/New Year's 2017/","excerpt":"With 2016 behind us and the new year begun, it’s time to write some articles about code! As in year’s past, some articles can help you known some interesting and useful things. Many thanks to Surge.sh and GitHub.io, provide a place where i can do some writing.","text":"With 2016 behind us and the new year begun, it’s time to write some articles about code! As in year’s past, some articles can help you known some interesting and useful things. Many thanks to Surge.sh and GitHub.io, provide a place where i can do some writing. What’s Android TVAndroid TV is a smart TV platform developed by Google, Based on the Android ( operating system ), It’s a new variant of Google’s mobile OS aimed at TVs, game consoles and set top boxes. It’s based upon Android 5.0 Lollipop, Which of course also run on phones, tablets and car via Android Auto. But, can you develop android application swiftly? Aha, many many developers full with experiences, so, you can SKIP the Android application basic course next. Now, let’s do it, start our first lesson about Android.","categories":[],"tags":[{"name":"2017","slug":"2017","permalink":"https://wilddylan.github.io/tags/2017/"}],"keywords":[]},{"title":"2016总结","slug":"2016总结","date":"2016-12-31T10:31:11.000Z","updated":"2017-02-04T09:03:12.000Z","comments":true,"path":"2016/12/31/2016总结/","link":"","permalink":"https://wilddylan.github.io/2016/12/31/2016总结/","excerpt":"我的2016 2016年2月，正式开始工作，上家公司（轻客）由于投资方的原因主动破产，我们属于坚持梦想的那一批人，将轻客改名为荟萃，继续为企业提供人力众包等服务。条件也算辛苦，我们6个人在原来老大租的房子里办公，虽然人少，但是生活很充实。改版，重构，写代码，想解决方案，去浙大踢球，打LOL（而且跟他们学会了打羽毛球）。就这样我们一直坚持到了5月中旬，投资方有音讯了，是一位上海的投资人。但是这个时候由于一些经济上的问题，不得不选择了离开这个目前还没有薪资的小团队。我是在15年的8月底加入这家公司，前前后后大概一年的时间，认识了这一帮能文能武能玩耍效率高的朋友，在这里我成长了许多，碰到了爱的人（虽然现在已经分手了，但是毕竟爱过），学习到了许多新的知识，并且开始学习做技术架构。我和公司的另一名手淘挖来的好兄弟一起搞完了轻客的即时通讯框架，HTML本地缓存框架，花了有一些时日，让人可以得到安慰的的是，这些框架的稳定性很好。","text":"我的2016 2016年2月，正式开始工作，上家公司（轻客）由于投资方的原因主动破产，我们属于坚持梦想的那一批人，将轻客改名为荟萃，继续为企业提供人力众包等服务。条件也算辛苦，我们6个人在原来老大租的房子里办公，虽然人少，但是生活很充实。改版，重构，写代码，想解决方案，去浙大踢球，打LOL（而且跟他们学会了打羽毛球）。就这样我们一直坚持到了5月中旬，投资方有音讯了，是一位上海的投资人。但是这个时候由于一些经济上的问题，不得不选择了离开这个目前还没有薪资的小团队。我是在15年的8月底加入这家公司，前前后后大概一年的时间，认识了这一帮能文能武能玩耍效率高的朋友，在这里我成长了许多，碰到了爱的人（虽然现在已经分手了，但是毕竟爱过），学习到了许多新的知识，并且开始学习做技术架构。我和公司的另一名手淘挖来的好兄弟一起搞完了轻客的即时通讯框架，HTML本地缓存框架，花了有一些时日，让人可以得到安慰的的是，这些框架的稳定性很好。 2016年5月12日，离开温暖的小团队，来到了朋友所在的一家公司，我和这家公司还是有一点点渊源的。我2015年来到杭州，来见的第一个人就是这家公司的马哥（不过后来他离开了），带着我们一起去吃饭，唱歌，交心的聊天。后来也是有一些小插曲有一些断断续续的联系，这次真的来了，老板说我之前放他鸽子，哈哈，所以在经过第一次跟老大面谈之后，我感觉这个人可以交为好朋友，但是不知道人家看不看的起我。接下来的日子里，我有做过关于技术部整改的方案（3个演示文稿），并且被采纳过（虽然后来的执行不是很好），这家公司给我的最大感触就是大家都不像是为自己的公司干活，都像是为了赚钱来的。我也拿这一份工资默默的干着我自己的事情，继续写一些技术部整改的方案，不过没有给老大看；继续重构项目，搭建Swift版本的框架，制定JS-Bridge的规则这些事情。规划并提前实施了有我没事的客户端架构，而且在学习一些Desktop相关的东西为有我没事的桌面版做准备，但是这一切好像都是白费，不过至少我学习到了东西，他们用不用那是他们的事情。来这家公司给我最大的成长就是要学会圆滑。我来自内蒙古，本身性子比较直，有什么说什么，但是来到这里我发现，有些话不能直接说，有些话只能跟某些人说，有些话要装着说（也许我之前去的公司人比较少，大家都是用心的交朋友吧，在这里我感觉都是在利益驱动）。不过还好，我也不参与这些，直爽的本性我认为很好，有一说一，不藏着噎着也是我这辈子所坚定的理念。马上要到年底了，由于业务的以及方向的东西导致的公司人越来越低迷，人心涣散，我也不能做些什么感觉很无力（无力是因为没有权利，毕竟越界是一件很不讨人喜欢的事情，至少我这样认为）。 2016年12月16号，去了西藏，陪朋友，他高反，我们去西藏共5天4夜，喝了3天酒，又交了一两个交心的朋友，我们相约年前在内蒙古大草原继续干杯。西藏真的美，景美人也美，每个藏民脸上都带着幸福的笑容，他们真的很幸福（西藏每年使用920亿，这其中政府拨款了90%，不幸福才怪…）。 2016年12月30号，最后一个工作日，有我没事的桌面端框架搭建结束了。 2016年不知不觉过去了，今年是技术成长的一年，学到了很多的知识。我希望我依旧可以把直爽的性格保持下去，不被污浊的环境所侵蚀。 17年该怎么过？ 我想让我所在的公司变的更好，对没错，用我的努力，让技术部变得更好，更高效，更像一个家。这就是我的梦想。 一些西藏的照片：","categories":[],"tags":[{"name":"领悟","slug":"领悟","permalink":"https://wilddylan.github.io/tags/领悟/"}],"keywords":[]},{"title":"快速搭建属于自己的斗鱼TV","slug":"快速搭建属于自己的斗鱼TV","date":"2016-12-30T05:31:45.000Z","updated":"2017-02-04T09:03:04.000Z","comments":true,"path":"2016/12/30/快速搭建属于自己的斗鱼TV/","link":"","permalink":"https://wilddylan.github.io/2016/12/30/快速搭建属于自己的斗鱼TV/","excerpt":"让小白也可以快速搭建属于自己的斗鱼TV的教程 简明扼要，开始干活： 打开qiniu.com注册个人开发者帐号 申请直播空间","text":"让小白也可以快速搭建属于自己的斗鱼TV的教程 简明扼要，开始干活： 打开qiniu.com注册个人开发者帐号 申请直播空间 这里有个坎儿，就是你得有一个备案的域名，域名备案的服务我这里提供，可以找我QQ 958226951 申请之后等待3-7天，就会有结果了，一般不会被拒绝的，你的邮箱会收到一封审核通过的邮件： 再次打开自己的七牛开发者面板，发现顶部有一个黄色的提示，让你马上体验直播，或者点击左侧列表的直播标识也可以进入配置界面。然后就是一系列的简单配置，都是顾名思义的配置，大家自己照着配就好，配置CName是比较重要的环节，共有6个CName需要你配置到自己的已备案域名下。 接下来我们添加一个自己的房间： 名称大家自己随便起，接下来我们记录一下需要记录的一些信息： 这样，七牛这边的工作就完成了，按理说，我们应该准备一台服务器进行房间的创建操作，但是这里为了先让大家跑通流程，就不搞的那么麻烦了，直接手动在这里创建一个拿来用。接下来我们创建两个新的工程用于测试，一个用于推流，另一个用于播放。 推流项目1pod 'PLMediaStreamingKit' 都是有开发经验的人，我也不多说，引入PLMediaStreamingKit作为推流库，接下来进行配置（由于我使用的是Swift，所以这里在桥接文件中引入PLMediaStreamingKit.h）： 首先，在使用推流前无比初始化推流环境： 1PLStreamingEnv.initEnv() 首先按照官方文档创建一个Stream对象： 123456789101112131415161718192021222324252627// 创建流对象 let stream = PLStream(json: NSDictionary(dictionary: [\"id\": \"helloworld\", \"title\": \"Hello world\", \"hub\" : \"leafedu\", \"publishkey\": \"bbc2d839fbeafa70\", \"publishSecurity\": \"static\", \"disabled\": NSNumber(value: false), \"profiles\": NSArray(objects: \"420p\", \"720p\"), \"hosts\": [ \"publish\": [ \"rtmp\": \"rtmp://pili-publish.devdylan.cn/leafedu/helloworld\" ], \"live\": [ \"hdl\": \"http://pili-live-hdl.devdylan.cn/leafedu/helloworld.flv\", \"hls\": \"http://pili-live-hls.devdylan.cn/leafedu/helloworld.m3u8\", \"rtmp\": \"rtmp://pili-live-rtmp.devdylan.cn/leafedu/helloworld\", \"http\": \"http://pili-live-hls.devdylan.cn/leafedu/helloworld.m3u8\" ], \"playback\": [ \"hls\": \"http://live.devdylan.cn/notification\", \"http\": \"http://live.devdylan.cn/notification\" ], \"play\": [ \"http\": \"http://pili-live-hls.devdylan.cn/leafedu/helloworld.m3u8\", \"rtmp\": \"rtmp://pili-live-rtmp.devdylan.cn/leafedu/helloworld\" ] ]]) as! [AnyHashable : Any] ) 这里的填充的内容是按照PLMediaStreamingKit的开发文档写的示例内容，由于我们没有自己的服务器，所以这里先随便填充一些内容，真正的使用我们刚才创建好的推流地址在后边，接下来创建一些基础的音视频，音视频流配置： 12345let videoCaptureConfiguration = PLVideoCaptureConfiguration.default()let audioCaptureConfiguration = PLAudioCaptureConfiguration.default()let videoStreamingConfiguration = PLVideoStreamingConfiguration.default()let audioStreamingConfiguration = PLAudioStreamingConfiguration.default() 初始化推流Session并添加一个实时预览： 1234567// 初始化Session session = PLMediaStreamingSession(videoCaptureConfiguration: videoCaptureConfiguration, audioCaptureConfiguration: audioCaptureConfiguration, videoStreamingConfiguration: videoStreamingConfiguration, audioStreamingConfiguration: audioStreamingConfiguration, stream: stream) // 添加预览 if let preView = session?.previewView &#123; view.addSubview(preView) &#125; 自行写一个按钮，在按钮动作中开始推流，这个时候写我们刚刚创建好房间的推流地址： 123self.session?.startStreaming(withPush: URL(string: \"你的以rtmp开头的推流地址\")!) &#123; print($0) &#125; 然后看日志输出，明白人能看的懂。 播放端1pod 'PLPlayerKit' 创建播放器： 1let player = PLPlayer(liveWith: URL(string: \"rtmp://pili-live-rtmp.devdylan.cn/leafedu/helloworld\")!, option: PLPlayerOption.default()) 上边是你播放推流的地址 然后添加到view上边，并设置代理： 12345// 设置代理 player?.delegate = self if let playView = player?.playerView &#123; view.addSubview(playView) &#125; 接下来，实现代理方法： 1234567891011func player(_ player: PLPlayer, statusDidChange state: PLPlayerStatus) &#123; &#125; func player(_ player: PLPlayer, stoppedWithError error: Error?) &#123; print(error?.localizedDescription ?? \"444\") &#125; func player(_ player: PLPlayer, codecError error: Error) &#123; print(error.localizedDescription ) &#125; 第一个方法是状态发生变化的时候，后两个是遇到错误的时候，同样，自己添加一个按钮控制开始播放，播放的代码为： 1self.player?.play() 测试打开推流端，点击推流按钮开始推流，在播放端点击开始播放，就会看到直播已经建立了起来。在测试前需要注意的事项： Xcode权限的申请 我们需要申请Camera以及MicroPhone的隐私权限： 包括ATS，网络的权限，接下来大家就可以测试了，在测试的过程中，可以在七牛的开发者平台查看实时信息： 可以在创建直播服务是绑定的空间内查看到直播的记录文件，保存的时长依你创建是选择的为准。这样，我们大概用20分钟的时间就打通了直播流程。接下来按照业务需求搭建自己服务器通过七牛直播服务端SDK创建房间等等的事情交给大家自己了。 配置在Pili为大家提供了整套的移动视频直播SDK（Android与iOS），PLMediaStreamingKit同样提供了高阶的一些使用，比如说美颜，声音混响等操作。这里是一份开发指南，大家可以细阅，可以达到80%的业务需求。","categories":[],"tags":[{"name":"直播","slug":"直播","permalink":"https://wilddylan.github.io/tags/直播/"}],"keywords":[]},{"title":"WebApp问题整理","slug":"WebApp问题整理","date":"2016-11-22T10:29:12.000Z","updated":"2017-02-04T09:01:41.000Z","comments":true,"path":"2016/11/22/WebApp问题整理/","link":"","permalink":"https://wilddylan.github.io/2016/11/22/WebApp问题整理/","excerpt":"问题列表伪类 :active 生效要CSS伪类 :active 生效，只需要给 document 绑定 touchstart 或 touchend 事件 &lt;style&gt; a { color: #000; } a:active { color: #fff; } &lt;/style&gt; &lt;a herf=foo &gt;bar&lt;/a&gt; &lt;script&gt; document.addEventListener(&apos;touchstart&apos;,function(){},false); &lt;/script&gt; 消除 transition 闪屏两个方法","text":"问题列表伪类 :active 生效要CSS伪类 :active 生效，只需要给 document 绑定 touchstart 或 touchend 事件 &lt;style&gt; a { color: #000; } a:active { color: #fff; } &lt;/style&gt; &lt;a herf=foo &gt;bar&lt;/a&gt; &lt;script&gt; document.addEventListener(&apos;touchstart&apos;,function(){},false); &lt;/script&gt; 消除 transition 闪屏两个方法 -webkit-transform-style: preserve-3d; /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-backface-visibility: hidden; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ 消除 IE10 里面的那个叉号input:-ms-clear{display:none;} 来源出处：http://msdn.microsoft.com/en-us/library/windows/apps/hh767361.aspx​ ###关于 iOS 与 OS X 端字体的优化(横竖屏会出现字体加粗不一致等)iOS 浏览器横屏时会重置字体大小，设置 text-size-adjust 为 none 可以解决 iOS 上的问题，但桌面版 Safari 的字体缩放功能会失效，因此最佳方案是将 text-size-adjust 为 100% 。 -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; text-size-adjust: 100%; JS 事件相关click 事件普遍 300ms 的延迟在手机上绑定 click 事件，会使得操作有 300ms 的延迟，体验并不是很好。开发者大多数会使用封装的 tap 事件来代替 click 事件，所谓的 tap 事件由 touchstart 事件 + touchmove 判断 + touchend 事件封装组成 iOS 点击会慢 300ms 问题 https://developers.google.com/mobile/articles/fast_buttons?hl=de-DE http://stackoverflow.com/questions/12238587/eliminate-300ms-delay-on-click-events-in-mobile-safari 使用 CSS3 动画的时尽量利用3D加速，从而使得动画变得流畅。动画过程中的动画闪白可以通过 backface-visibility 隐藏。 -webkit-transform-style: preserve-3d; -webkit-backface-visibility: hidden; IE10 的特殊鼠标事件http://www.mansonchor.com/blog/blog_detail_73.html 不让 Android 手机识别邮箱&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt; 禁止 iOS 识别长串数字为电话&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt; 禁止 iOS 弹出各种操作窗口-webkit-touch-callout:none 禁止用户选中文字-webkit-user-select:none 动画效果中，使用 translate 比使用定位性能高http://paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/ 获取滚动条window.scrollY window.scrollX 比如要绑定一个 touchmove 的事件，正常的情况下类似这样(来自呼吸二氧化碳) $(&apos;div&apos;).on(&apos;touchmove&apos;, function(){ //.….code }); 而如果中间的 code 需要处理的东西多的话，FPS 就会下降影响程序顺滑度，而如果改成这样 $(&apos;div&apos;).on(&apos;touchmove&apos;, function(){ setTimeout(function(){ //.….code },0); }); 把代码放在 setTimeout 中，会发现程序变快. 关于 iOS 系统中，WebAPP 启动图片在不同设备上的适应性设置http://stackoverflow.com/questions/4687698/mulitple-apple-touch-startup-image-resolutions-for-ios-web-app-esp-for-ipad/10011893#10011893 关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格(焦点科技葛亮)可以通过正则去掉 this.value = this.value.replace(/\\u2006/g, &apos;&apos;); 关于 Android WebView中，input 元素输入时出现的怪异情况见图 Android web视图，例如在 HTC EVO 和三星的 Galaxy Nexus 中，文本输入框在输入时表现的就像占位符。情况为一个类似水印的东西在用户输入区域，一旦用户开始输入便会消失(见图片)。 在 Android 的默认样式下当输入框获得焦点后，若存在一个绝对定位或者fixed的元素，布局会被破坏，其他元素与系统输入字段会发生重叠(如搜索图标将消失为搜索字段)，可以观察到布局与原始输入字段有偏差(见截图)。这是一个相当复杂的问题，以下简单布局可以重现这个问题: &lt;label for=&quot;phone&quot;&gt;Phone: *&lt;/label&gt; &lt;input type=&quot;tel&quot; name=&quot;phone&quot; id=&quot;phone&quot; minlength=&quot;10&quot; maxlength=&quot;10&quot; inputmode=&quot;latin digits&quot; required=&quot;required&quot; /&gt; 解决方法 -webkit-user-modify: read-write-plaintext-only 详细参考：http://www.bielousov.com/2012/android-label-text-appears-in-input-field-as-a-placeholder/注意，该属性会导致中文不能输入词组，只能单个字。感谢鬼哥与飞（游勇飞）贡献此问题与解决方案 JS 动态生成的 select 下拉菜单在 Android2.x 版本的默认浏览器里不起作用解决方法删除了 overflow-x:hidden; 然后在JS生成下来菜单之后 focus 聚焦，这两步操作之后解决了问题。(来自岛都-小Qi) 参考：http://stackoverflow.com/questions/4697908/html-select-control-disabled-in-android-webview-in-emulator ###移动端 HTML5 audio autoplay 失效问题 这个不是 BUG，由于自动播放网页中的音频或视频，会给用户带来一些困扰或者不必要的流量消耗，所以苹果系统和安卓系统通常都会禁止自动播放和使用 JS 的触发播放，必须由用户来触发才可以播放。 解决方法思路：先通过用户 touchstart 触碰，触发播放并暂停（音频开始加载，后面用 JS 再操作就没问题了）。 解决代码： 1234document.addEventListener(&apos;touchstart&apos;, function () &#123; document.getElementsByTagName(&apos;audio&apos;)[0].play(); document.getElementsByTagName(&apos;audio&apos;)[0].pause();&#125;); 方案出处：http://stackoverflow.com/questions/17350924/iphone-html5-audio-tag-not-working 扩展阅读：http://yujiangshui.com/recent-projects-review/#toc-7 ###移动端 HTML5 input date 不支持 placeholder 问题 input type date 的 placeholder 支持性有一定问题，因为浏览器会针对此类型 input 增加 datepicker 模块，看上去没那么必要支持 placeholder。 对 input type date 使用 placeholder 的目的是为了让用户更准确的输入日期格式，iOS 上会有 datepicker 不会显示 placeholder 文字，但是为了统一表单外观，往往需要显示。Android 部分机型没有 datepicker 也不会显示 placeholder 文字。 简单的进行了测试： 桌面端（Mac） Safari 不支持 datepicker，placeholder 正常显示。 Firefox 不支持 datepicker，placeholder 正常显示。 Chrome 支持 datepicker，显示 年、月、日 格式，忽略 placeholder。 移动端 iPhone5 iOS7 有 datepicker 功能，但是不显示 placeholder。 Andorid 4.0.4 无 datepicker 功能，不显示 placeholder 问题解决方法： 先使其 type 为 text，此时支持 placeholder，当触摸或者聚焦的时候，使用 JS 切换使其触发 datepicker 功能。 &lt;input placeholder=&quot;Date&quot; class=&quot;textbox-n&quot; type=&quot;text&quot; onfocus=&quot;(this.type=&apos;date&apos;)&quot; id=&quot;date&quot;&gt; 方案出处：http://stackoverflow.com/questions/20321202/not-showing-place-holder-for-input-type-date-field-ios-phonegap-app ###IOS Safari 支持localstorage但是setItem异常（QUOTA_EXCEEDED_ERR:DOM Exception 22） 平台：IOS8.1 browser：Safari600.1.4 问题源自于项目需要在浏览器中遮罩提示,点击关闭状态存储在localstorage中。Safari浏览器关闭后刷新页面层依旧存在 bug issue简单的存储状态可以使用cookie的方式替代。 ###Chrome 地址栏自动隐藏交互行为对于fixed 顶部的元素遮挡 系统：IOS8.1 浏览器：Chrome 26.0.1410.53 描述信息：页面包含fixed顶部的tip element，当页面向下滑动的时候Chrome地址栏自动隐藏，当向上滑动的时候地址栏自动出现。这种交互行为本身的好处会增大用户可视、交互区域。但是在Chrome 26这个版本这个浏览器UI布局使用adjustPan的方式，以至于向上滑动以后fixed的元素没有被自动向下移动（没有重绘）。 bug fixed解决办法在这里 ###Android平台遮罩层下的input、select、a等元素可以被点击和focus(点击穿透) 问题发现于三星手机，这个在特定需求下才会有，因此如果没有类似问题的可以不看。首先需求是浮层操作，在三星上被遮罩的元素依然可以获取focus、click、change. bug issue ，在查看bug报告list以后，找到了两种解决方案，第一是通过层显示以后加入对应的class名控制，第二是通过将可获取焦点元素加入的disabled属性，也可以利用属性加dom锁定的方式（disabled的一种变换方式） ###部分机型存在type为search的input，自带close按钮样式修改方法 有些机型的搜索input控件会自带close按钮（一个伪元素），而通常为了兼容所有浏览器，我们会自己实现一个，此时去掉原生close按钮的方法为 #Search::-webkit-search-cancel-button{ display: none; } 如果想使用原生close按钮，又想使其符合设计风格，可以对这个伪元素的样式进行修改。 ###唤起select的option展开zepto方式: 1$(sltElement).trrgger(&quot;mousedown&quot;); 原生js方式:123456function showDropdown(sltElement) &#123; var event; event = document.createEvent(&apos;MouseEvents&apos;); event.initMouseEvent(&apos;mousedown&apos;, true, true, window); sltElement.dispatchEvent(event);&#125;; 来自Mars","categories":[],"tags":[{"name":"Hybrid","slug":"Hybrid","permalink":"https://wilddylan.github.io/tags/Hybrid/"}],"keywords":[]},{"title":"SwiftTips（一）","slug":"SwiftTips（一）","date":"2016-11-21T09:22:15.000Z","updated":"2017-02-04T09:01:45.000Z","comments":true,"path":"2016/11/21/SwiftTips（一）/","link":"","permalink":"https://wilddylan.github.io/2016/11/21/SwiftTips（一）/","excerpt":"最新1年的Swift小Tip与一些建议阅读源码或者使用到项目中的开源库","text":"最新1年的Swift小Tip与一些建议阅读源码或者使用到项目中的开源库 开源项目 模型转为JSON https://github.com/WildDylan/Wrap OCR https://github.com/garnele007/SwiftOCR Machine Learning https://github.com/collinhundley/Swift-AI 代码规范约束 https://github.com/realm/SwiftLint 加解密 https://github.com/krzyzanowskim/CryptoSwift 日历 https://github.com/patchthecode/JTAppleCalendar 引导页 https://github.com/Ramotion/paper-onboarding 头像显示 https://github.com/BeauNouvelle/FaceAware hexColor https://github.com/hyperoslo/Hue 颜色扩展 https://github.com/ViccAlexander/Chameleon 用户使用引导 https://github.com/ephread/Instructions segmentControl https://github.com/twicketapp/TwicketSegmentedControl 安卓风 https://github.com/CosmicMind/Material Spring https://github.com/MengTo/Spring JSON https://github.com/SwiftyJSON/SwiftyJSON GCD https://github.com/duemunk/Async Location https://github.com/varshylmobile/LocationManager Auto Check Update https://github.com/ArtSabintsev/Siren ASDK https://github.com/facebook/AsyncDisplayKit Layout https://github.com/robb/Cartography Bind https://github.com/ReactiveCocoa/ReactiveCocoa URL Route https://github.com/devxoul/URLNavigator $扩展 https://github.com/ankurp/Dollar Path https://github.com/kylef/PathKit Logger https://github.com/DaveWoodCom/XCGLogger SQLite3 https://github.com/stephencelis/SQLite.swift WS https://github.com/daltoniam/starscream Image more Color https://github.com/indragiek/DominantColor Gif https://github.com/kaishin/gifu 地图路线规划 https://github.com/varshylmobile/MapManager 提示框！https://github.com/SwiftKickMobile/SwiftMessages 关于Swift下JSON解析库的分析图 如何像安卓一样方便的使用R加载资源文件https://github.com/mac-cain13/R.swift 做好代码规范从编写开始-swiftlintswiftlint autocorrect &lt;项目在Github中搜索即可&gt; Swift zipzip(arr1, arr2) 输出一个 元祖数组 [(arr1[0], arr2[0]), (…), (…)] 添加弃用信息@available(*, deprecated, message: “no longer available …”) 获取系统信息，诸如版本之类的-NSProcessInfo12let os = ProcessInfo().operatingSystemVersionlet info = \"\\(os.majorVersion).\\(os.minorVersion).\\(os.patchVersion)\" 并且这样判断版本 12345if #available(iOS 10.0, *) &#123; Push.registeNotification()&#125; else &#123; Pusher.registeNotification()&#125; 使用discardableResult设置可以忽略返回值123456789@discardableResultpublic func data(to identifier: String, with parameter: Any?, _ handler: PNRouteCallBack?) -&gt;Bool&#123; guard let hand = dataing[identifier] else &#123; return false &#125; hand(parameter, handler) return true&#125; 更加清晰的Git工作流程首先应当创建新的分支 1git checkout -b dylan 在结束自己的工作之后，提交到本地 12git add .git commit -m “Fixed some quesitons“ 如果需要提交多行文本，使用 1git commit -m &apos; 回车后即可输入，结束使用&#39;。接下来获取最新的主分支动态，并合并到我们当前已经修改的分支上 12git fetch origingit rebase origin/master 做一些操作，比如说合并提交信息： 1git rebase -i origin/master 提交到自己的分支 1git push origin dylan 发起pull request，由负责人进行代码review： 12git checkout 提交者的分支git diff 提交者/master..HEAD 合并代码到主开发分支上： 12git fetch origingit rebase -i origin/master 推送: 123456git push —force-with-lease origin mastergit log origin/master..&lt;branch-name&gt;git diff --stat origin/mastergit checkout mastergit merge &lt;branch-name&gt; --ff-onlygit push 删除开发分支: 12git push origin --delete &lt;branch-name&gt;git branch --delete &lt;branch-name&gt; 这样一次开发的Git操作就完美的结束了，另外附上一些常用的git命令： 12345git checkout . #本地所有修改的。没有的提交的，都返回到原来的状态git stash #把所有没有提交的修改暂存到stash里面。可用git stash pop回复。git reset --hard HASH #返回到某个节点，不保留修改。git reset --soft HASH #返回到某个节点。保留修改git push origin master -f 强制覆盖 最近的看到的iOS版本占比图 所以强烈建议大家开始从iOS8.0进行系统支撑，这并没有问题。 常用语在Git Hub你提交给其他开源库的pull request被merge之后，请对项目拥有者说： 1Pure awesomeness, thanks a lot! 结尾123456789101112131415161718什么叫价值？同是两根竹子，一支做成了笛子，一支做成了晾衣杠。晾衣杠不服气的问笛子：“我们都是同一片山上的竹子，凭什么我天天日晒雨淋，不值一文，而你却价值千金呢？”笛子：”因为你只挨了一刀，而我却经历了千刀万剐，精雕细做。”晾衣杠此时沉默了……人生亦是如此，经得起打磨，耐得起寂寞，扛得起责任，肩负起使命！人生才会有价值！ 现在碎片化知识已经出现在各个角落，人们对于碎片化知识的汲取到底是对还是错呢？总之我是赞成的，当然我也更赞成如果你有足够的时间，请系统化的了解、深入的了解。","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://wilddylan.github.io/tags/Swift/"}],"keywords":[]},{"title":"如何利用Swift解析MarkDown","slug":"如何利用Swift解析MarkDown","date":"2016-11-16T09:17:02.000Z","updated":"2017-02-04T09:03:00.000Z","comments":true,"path":"2016/11/16/如何利用Swift解析MarkDown/","link":"","permalink":"https://wilddylan.github.io/2016/11/16/如何利用Swift解析MarkDown/","excerpt":"由于自己的开源项目需要使用MarkDown作为主要的文本语法，本该由iOS小组同学负责的东西由于他有点事情所以就改为由我负责了。由于也是第一次接触在Swift上边解析MarkDown，所以先去了解了一些github上边的开源项目，但是少之又少，而且实现的功能都很简单（大多数都是使用NSAttributeString来实现简单的加粗、倾斜、下划线），并不能达到我所期望的效果（支持90%以上的MarkDown并支持HTML）。 更新，IBM提供了C库用来解析MardDown到HTML 如何解决问题首先根据经验，我首先想到的是CoreText + Regex。没错，给我一段MarkDown的文本，先用Regex匹配出每一个MarkDown的Element，然后使用CoreText绘制出来，如果是图片则预先占位，表格则细化解析，绘制。尝试着下手之后，发现MarkDown的语法不是一般的多，这样写下去光是解析器我可能要写一个月左右（编码、测试等）。","text":"由于自己的开源项目需要使用MarkDown作为主要的文本语法，本该由iOS小组同学负责的东西由于他有点事情所以就改为由我负责了。由于也是第一次接触在Swift上边解析MarkDown，所以先去了解了一些github上边的开源项目，但是少之又少，而且实现的功能都很简单（大多数都是使用NSAttributeString来实现简单的加粗、倾斜、下划线），并不能达到我所期望的效果（支持90%以上的MarkDown并支持HTML）。 更新，IBM提供了C库用来解析MardDown到HTML 如何解决问题首先根据经验，我首先想到的是CoreText + Regex。没错，给我一段MarkDown的文本，先用Regex匹配出每一个MarkDown的Element，然后使用CoreText绘制出来，如果是图片则预先占位，表格则细化解析，绘制。尝试着下手之后，发现MarkDown的语法不是一般的多，这样写下去光是解析器我可能要写一个月左右（编码、测试等）。 于是，抱着比较懒的心态，我想到了我在做PC端的时候用到的marked.js，是我用来把MarkDown文本转为HTML的，这样一来，客户端的文本解析与预览就可以通过这个工具搞定一大半了，所以接下来的事情就是把marked.js加入到项目中，load并调用方法。既然是与JS交互，相信读者对JavaScriptCore这个库一定不是很陌生。 过程 加载：先把marked.js拖拽到项目中，然后在某文件中引入JavaScriptCore，并加载 123456789101112import JavaScriptCoreprivate var context: JSContext = JSContext()private var marked: JSValue?// initialized javascriptdo &#123; try _ = context.evaluateScript(String(contentsOfFile: Bundle.main.path(forResource: \"marked\", ofType: \"js\")!)) marked = context.objectForKeyedSubscript(\"marked\")&#125; catch &#123; debugPrint(\"initialized marked js with error!\")&#125; 要注意的是，这里的marked.js文件我们要稍作修改，需要把最外层的function（涵义是定义并马上执行）去掉。 调用 上边我们通过marked = context.objectForKeyedSubscript(&quot;marked&quot;)这样的方式获得了marked这个方法，紧接着按照官方文档的要求去调用： 12345guard let value = marked?.call(withArguments: [content]) else &#123; return false&#125;let markedHTML = value.toString() 这样，我们通过marked?.call来调用这个方法，并获得返回的value，将结果toString()。 以上完成的步骤就是将textView输入的文字转为HTML，接下来就是渲染了，很简单，依旧按照PC的思路，MarkDown-HTML的样式使用github-markdown-css，代码高亮使用highlight.js，为了快速，我们将这些css与js资源文件也一并压缩打包到App的bundle中，然后使用： 123456789101112131415161718192021222324&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\"/&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimal-ui\"&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"github-markdown.css\"/&gt; &lt;link rel=\"stylesheet\" href=\"libs/highlight.js/9.8.0/styles/color-brewer.min.css\"&gt; &lt;style&gt; .markdown-body &#123; box-sizing: border-box; padding: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;article class=\"markdown-body\"&gt; [markdown-content-flag] &lt;/article&gt; &lt;/div&gt; &lt;script src=\"libs/highlight.js/9.8.0/highlight.min.js\"&gt;&lt;/script&gt; &lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 读者可能会注意到其中有[markdown-content-flag]这样一个字串，用于我们加载之前替换为MarkDown文本： 12345678910do &#123; var htmlContent = try String(contentsOfFile: Bundle.main.path(forResource: \"PNPreview\", ofType: \"html\")!) let range = htmlContent.range(of: \"[markdown-content-flag]\") htmlContent.replaceSubrange(range!, with: HTML) webView.stopLoading() webView.loadHTMLString(htmlContent, baseURL: nil)&#125; catch &#123;&#125; 这样，展示也就没有问题了，然后大家可以在其中做很多层自定义处理。最终我写了简单的demo用于测试，效果如下： 这样，编辑器的一大部分就解决掉了。当然这对于用户来讲还不是最好的体验，最好的体验应该是我们一边输入一边看到效果的，这种效果的实现方式依旧可以使用上边的方式来实现。 关于MarkDown-CSS样式以及代码高亮的效果大家可以自由的去寻找。 在客户端工作之外，接触到了其他各个方面的语言确实对自我提升很大， 我这里说的不是你能读懂的的代码多了，而是说解决问题的思路更多了。每一种语言都有自己的独到之处。甚至你可以从一些管理方面的书籍中学习到一些实际的技巧应用到人员的组织、调配，项目的合理安排与规划等。","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://wilddylan.github.io/tags/Swift/"}],"keywords":[]},{"title":"移动H5前端性能优化注意点","slug":"移动H5前端性能优化注意点","date":"2016-11-11T09:40:13.000Z","updated":"2017-02-04T09:02:18.000Z","comments":true,"path":"2016/11/11/移动H5前端性能优化注意点/","link":"","permalink":"https://wilddylan.github.io/2016/11/11/移动H5前端性能优化注意点/","excerpt":"希望得到的最好的效果： PC优化手段在Mobile侧同样适用 最多三秒钟渲染完成单屏或者使用Loading 基于3G/4G移动网络下，每屏幕资源不超过1024KB 加载优化 合并CSS、JavaScript 合并小图片、使用雪碧图 缓存一切可以缓存的资源，部分资源css、js使用src=&quot;abc.css?cacheVersion=1&quot;来控制版本 使用长Cache 压缩HTML、CSS、JS 启用GZip 使用首屏加载","text":"希望得到的最好的效果： PC优化手段在Mobile侧同样适用 最多三秒钟渲染完成单屏或者使用Loading 基于3G/4G移动网络下，每屏幕资源不超过1024KB 加载优化 合并CSS、JavaScript 合并小图片、使用雪碧图 缓存一切可以缓存的资源，部分资源css、js使用src=&quot;abc.css?cacheVersion=1&quot;来控制版本 使用长Cache 压缩HTML、CSS、JS 启用GZip 使用首屏加载 使用按需加载 使用滚屏加载 增加进度指示器 减少Cookie 避免重定向 异步加载第三方资源 CSS优化 CSS写在头部，JS写到尾部或者异步 避免图片和iFrame等的SRC为空 尽量避免重设图片大小 图片尽量避免使用DataURL 尽量避免在HTML标签中写Style 避免CSS表达式 移除空的CSS规则 正确使用Display的属性 不滥用Float 不滥用Web字体 不声明过多的Font-size 值为0时候不需要任何单位 标准化各种浏览器的前缀 避免让选择符看起来像正则表达式 图片优化 使用 CSS3、SVG、IconFont代替图片 使用Srcset WebP优于JPG PNG8优于GIF 首次加载不大于1024KB单页 图片不宽于640 脚本优化 减少重绘 缓存Dom选择与计算 缓存列表的长度 尽量使用事件代理，避免批量绑定事件 尽量使用ID选择器 使用touch代理click 渲染优化 HTML使用ViewPort 减少Dom节点 尽量使用CSS3动画 合理使用requestAnimationFrame动画代替setTimeout 适当使用Canvas动画 touchmove，scroll事件会导致多次渲染 使用 CSS3-transitions、CSS3-3D、Opacity、Canvas、WebGL、Video来触发GPU渲染","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://wilddylan.github.io/tags/HTML5/"}],"keywords":[]},{"title":"如何迈出第四步（数据展示）","slug":"如何迈出第四步（数据展示）","date":"2016-10-24T01:22:32.000Z","updated":"2017-02-04T09:02:45.000Z","comments":true,"path":"2016/10/24/如何迈出第四步（数据展示）/","link":"","permalink":"https://wilddylan.github.io/2016/10/24/如何迈出第四步（数据展示）/","excerpt":"数据的获取与展示是每个App必不可少的功能，最常见的就是列表（iOS的TableView，Android的ListView）。在RN中当然也有ListView，第四步将在第三步建立好衔接的基础下，完成2个列表视图的构建，并加入网络请求知识（也就有下拉刷新了）。首先，我们去寻找一个接口，用以获取数据。这里为了方便直接使用聚合，我这里是找了一个微信文章推荐的接口： 1http://v.juhe.cn/weixin/query?pno=1&amp;ps=20&amp;key=1cb0962fb0fb73dae41d96e88733ac96 参数： pno：页码 ps：每页内容个数 key：我的key，上边的可以直接拿去使用 接下来继续打开项目，进行编码，首先我们需要的是获取数据进行展示，在News.js中。","text":"数据的获取与展示是每个App必不可少的功能，最常见的就是列表（iOS的TableView，Android的ListView）。在RN中当然也有ListView，第四步将在第三步建立好衔接的基础下，完成2个列表视图的构建，并加入网络请求知识（也就有下拉刷新了）。首先，我们去寻找一个接口，用以获取数据。这里为了方便直接使用聚合，我这里是找了一个微信文章推荐的接口： 1http://v.juhe.cn/weixin/query?pno=1&amp;ps=20&amp;key=1cb0962fb0fb73dae41d96e88733ac96 参数： pno：页码 ps：每页内容个数 key：我的key，上边的可以直接拿去使用 接下来继续打开项目，进行编码，首先我们需要的是获取数据进行展示，在News.js中。 在使用ListView的时候，也需要数据源，并且我们还想加一个下拉刷新，我们的数据格式是这样的： 12345678&#123; \"firstImg\":\"http:\\/\\/zxpic.gtimg.com\\/infonew\\/0\\/wechat_pics_-8774101.jpg\\/640\", \"id\":\"wechat_20151202064749\", \"source\":\"果果帮\", \"title\":\"笑死了,哈哈小伙子你很有前途\", \"url\":\"http:\\/\\/v.juhe.cn\\/weixin\\/redirect?wid=wechat_20151202064749\", \"mark\":\"\"&#125; 我们先来尝试着获取数据，使用fetch： 1fetch('http://v.juhe.cn/weixin/query?pno=1&amp;ps=50&amp;key=1cb0962fb0fb73dae41d96e88733ac96') 然后我们尝试着把数据渲染上去（等下的解释我都写到代码注释里）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import React, &#123; Component, &#125; from 'react'import &#123; View, Text, ListView, RefreshControl, TouchableOpacity, StyleSheet, Image, Dimensions &#125; from 'react-native'import &#123; Router, Scene, Actions, ActionConst &#125; from 'react-native-router-flux';class News extends Component &#123; constructor(props)&#123; super(props); // 每一个ListView都需要一个数据源，称为`DataSource`。rowHasChanged用来比较前后的数据是否相同，相同则不重新渲染。 this.ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1.url !== r2.url &#125;); // 先初始化一个空的数组，供存放列表数据 this._data = []; // 可变状态 this.state = &#123; // dataSource是ListView显示的一个必须属性，cloneWithRows用于传入数据。 dataSource: this.ds.cloneWithRows(this._data), // 控制下拉刷新的状态 isRefreshing: false &#125;; // 加载第一次数据 this._onRefresh(); &#125; // 触发下拉刷新 _onRefresh = () =&gt; &#123; // 首先更改状态为true this.setState(&#123;isRefreshing: true&#125;); var self = this; // 开启网络请求 fetch('http://v.juhe.cn/weixin/query?pno=1&amp;ps=20&amp;key=1cb0962fb0fb73dae41d96e88733ac96') // 对数据做处理，这里没有写catch，应该写的，捕获错误 .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; // 看一下是否是成功，成功：先清空本地数据，然后将新的数据加入。因为是下拉刷新，上拉加载的功能自行研究。已经很简单了。 if (responseJson.reason == 'success') &#123; let data = responseJson.result.list; if (data) &#123; this._data = data; &#125; &#125; self.setState(&#123; dataSource: this.ds.cloneWithRows(this._data), isRefreshing: false &#125;); &#125;) &#125; // 用来渲染行的方法，将数据转为Cell进行展示。 _renderRow (rowData, sectionID, rowID) &#123; return ( &lt;TouchableOpacity onPress=&#123;()=&gt;this._pressRow(rowData)&#125;&gt; &lt;View style=&#123;styles.cell&#125;&gt; &lt;Image style=&#123;styles.cellImage&#125; source=&#123;&#123; uri: rowData.firstImg &#125;&#125; /&gt; &lt;View style=&#123;styles.cellColumn&#125;&gt; &lt;Text style=&#123;styles.cellText&#125; numberOfLines=&#123;0&#125;&gt;&#123;rowData.title&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.cellExtra&#125;&gt;#&#123;rowData.source&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ); &#125; _pressRow = (rowData) =&gt; &#123; // 在这里实现点击事件 console.log(rowData.url); &#125; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, marginTop: 44&#125;&#125;&gt; &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this._renderRow.bind(this)&#125; refreshControl=&#123; &lt;RefreshControl refreshing=&#123;this.state.isRefreshing&#125; onRefresh=&#123;this._onRefresh&#125; tintColor=\"rgb(181, 181, 181)\" title=\"下拉刷新数据\" titleColor=\"rgb(181, 181, 181)\" colors=&#123;['rgb(181, 181, 181)', 'rgb(181, 181, 181)', 'rgb(181, 181, 181)']&#125; /&gt; &#125; /&gt; &lt;/View&gt; ) &#125;&#125;const contentWidth = Dimensions.get('window').width;const styles = StyleSheet.create(&#123; cell: &#123; padding: 10, paddingTop: 10, paddingBottom: 0, flexDirection: 'row', flex: 1, alignItems: 'center' &#125;, cellImage: &#123; width: 50, height: 50, backgroundColor: 'rgb(221, 221, 221)' &#125;, cellText: &#123; textAlign: 'left', marginLeft: 10, width: contentWidth - 75, &#125;, cellExtra: &#123; fontSize: 10, color: 'rgb(181, 181, 181)', marginLeft: 10 &#125;, cellColumn: &#123; flexDirection: 'column' &#125;&#125;);export default News 接着我们来实现点击事件的详情跳转（这里有个问题，就是TabBar的隐藏，因为我们是用Router来跳转的，而在实现的时候，TabBar我们是自己写的，然后react-router-flux有个问题就是不能在子路由中打开父路由的界面，暂时提了一个issue，还有一个暂时的解决方案，所有的外层都用router-flux提供。这里先做演示），在NewsPage.js中： 12345678910111213141516171819202122232425import React, &#123; Component, &#125; from 'react'import &#123; Router, Scene &#125; from 'react-native-router-flux';import News from './News'import NewsDetail from './NewsDetail';class NewsPage extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;Scene key=\"_NewsRouter\"&gt; &lt;Scene key=\"News\" component=&#123;News&#125; title=\"News\" navigationBarStyle=&#123;&#123; backgroundColor: 'white' &#125;&#125; titleStyle=&#123;&#123;color: '#525354', fontFamily: 'Helvetica', fontSize: 20&#125;&#125; initial=&#123;true&#125; /&gt; &lt;scene key=\"NewsDetail\" component=&#123;NewsDetail&#125; title=\"NewsDetail\" hideTabBar /&gt; &lt;/Scene&gt; &lt;/Router&gt; ) &#125;&#125;export default NewsPage 然后在点击的时候打开详情： 123456_pressRow = (rowData) =&gt; &#123; Actions.NewsDetail(&#123; url: rowData.url, type: ActionConst.PUSH &#125;);&#125; 个人中心里边就比较简单了，大家自己通过之前的学习去尝试着完成微信个人中心界面的布局。简单的实现几个点击事件。TabBar隐藏的问题需要我们修改视图的层级：把TabBar变为一个Navigation包涵的视图。首先去掉index.ios.js中： 1&lt;Scene key=\"RootPage\" component=&#123;RootPage&#125; title=\"News\" initial=&#123;this.props.launched&#125;/&gt; 原来的hideNavBar属性，并直接改名为News。然后把News.js中的代码迁移到NewsPage中。最后的index.ios.js是这样的： 12345678910111213141516171819202122import React, &#123; Component &#125; from 'react';import &#123; AppRegistry &#125; from 'react-native';import &#123; Router, Scene &#125; from 'react-native-router-flux';import GuidePage from './GuidePage';import RootPage from './RootPage';import NewsDetail from './News/NewsDetail';class Project extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;Scene key=\"root\"&gt; &lt;Scene key=\"GuidePage\" component=&#123;GuidePage&#125; hideNavBar title=\"GuidePage\" initial=&#123;this.props.launched&#125; /&gt; &lt;Scene key=\"RootPage\" component=&#123;RootPage&#125; title=\"News\" initial=&#123;this.props.launched&#125;/&gt; &lt;scene key=\"NewsDetail\" component=&#123;NewsDetail&#125; title=\"NewsDetail\"/&gt; &lt;/Scene&gt; &lt;/Router&gt; ); &#125;;&#125;;AppRegistry.registerComponent('Project', () =&gt; Project); 然后就可以解决跳转的问题。但是接着出现了下一个问题，在点击个人中心的之后，发现顶部导航还是News的名称，所以TabBar也要进行处理，由于react-router-flux目前的框架问题（子路由不可以操作父路由，并且想操作Tabbar只能使用router-flux的方式创建TabBar），所以我们直接在index中使用Scene创建我们的Tabbar： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text, StyleSheet, View, Image &#125; from 'react-native';import &#123; Router, Scene &#125; from 'react-native-router-flux';import GuidePage from './GuidePage';import NewsDetail from './News/NewsDetail';import NewsPage from './News/NewsPage';import AccountPage from './Account/AccountPage';class TabIcon extends React.Component &#123; render()&#123; let selectedColor = '#34A3FF'; let deSelectedColor = 'rgb(181, 181, 181)'; let title = this.props.title; let selected = this.props.selected; let itemImage = &#123; \"新闻\": &#123; selected: 'http://ocef2grmj.bkt.clouddn.com/first_selected.png', deSelected: 'http://ocef2grmj.bkt.clouddn.com/first_normal.png' &#125;, \"我的\": &#123; selected: 'http://ocef2grmj.bkt.clouddn.com/fourth_selected.png', deSelected: 'http://ocef2grmj.bkt.clouddn.com/fourth_normal.png' &#125; &#125;; return ( &lt;View style=&#123;styles.tabBarItem&#125;&gt; &lt;Image source=&#123;&#123; uri: selected? itemImage[title].selected : itemImage[title].deSelected&#125;&#125; style=&#123;styles.tabBarImage&#125;/&gt; &lt;Text style=&#123;[&#123;color: selected ? selectedColor :deSelectedColor&#125;, styles.tabBatText]&#125;&gt;&#123;title&#125;&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;class Project extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;Scene key=\"GuidePage\" component=&#123;GuidePage&#125; hideNavBar title=\"GuidePage\" initial=&#123;this.props.launched&#125; /&gt; &lt;Scene key=\"main\" tabs=&#123;true&#125; style=&#123;styles.tabBarStyle&#125; initial=&#123;true&#125;&gt; &lt;Scene key=\"NewsModule\" title=\"新闻\" icon=&#123;TabIcon&#125; initial=&#123;true&#125;&gt; &lt;Scene key=\"News\" component=&#123;NewsPage&#125; title=\"News\" /&gt; &lt;Scene key=\"NewsDetail\" component=&#123;NewsDetail&#125; hideTabBar title=\"NewsDetail\"/&gt; &lt;/Scene&gt; &lt;Scene key=\"AccountModule\" title=\"我的\" icon=&#123;TabIcon&#125;&gt; &lt;Scene key=\"Mine\" component=&#123;AccountPage&#125; title=\"个人中心\" /&gt; &lt;/Scene&gt; &lt;/Scene&gt; &lt;/Router&gt; ); &#125;;&#125;;const styles = StyleSheet.create(&#123; tabBarStyle: &#123; borderTopWidth : .5, borderColor : '#b7b7b7', backgroundColor: 'white', opacity : 1 &#125;, tabBarItem: &#123; alignItems: 'center' &#125;, tabBatText: &#123; fontSize: 10, marginTop: 4 &#125;, tabBarImage: &#123; width: 26, height: 26 &#125;&#125;);AppRegistry.registerComponent('Project', () =&gt; Project); 最终的效果是： 跳转到详情的时候会自动的隐藏TabBar，这里还需要一个工作就是把TabBarItem作为我们自己的一个控件，交给大家啦！到此为止，React-Native的上手教程就结束了，希望大家有所收获，进阶的内容一起讨论，我会在一个自己的私有项目中使用React-Native来做一个核心的模块，之后会发布出来。 代码地址依旧不变，以后还会更新呦。","categories":[],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://wilddylan.github.io/tags/ReactNative/"}],"keywords":[]},{"title":"如何迈出第三步（衔接）","slug":"如何迈出第三步（衔接）","date":"2016-10-21T06:21:38.000Z","updated":"2017-02-04T09:02:50.000Z","comments":true,"path":"2016/10/21/如何迈出第三步（衔接）/","link":"","permalink":"https://wilddylan.github.io/2016/10/21/如何迈出第三步（衔接）/","excerpt":"第二步，我们依旧遗留了一个问题，从引导页进入到程序主界面，打算使用React-Router来解决这个问题。目前我对React-Router也是处于知道但没用过的状态，我们先尝试着寻找资料了解一下这个功能组件（记住React-Router这个名字还是因为我之前使用了很久的vue-router）。来到Reacr-Router Github的主页后，阅读了一下大致的介绍，感觉还是只适合Web的React相关的路由操作（小白见解），我们使用另一个： 1$ npm i react-native-router-flux --save 并且在使用之前建议大家阅读一下这篇文章，接着我们按照Github的文档来看下具体该如何操作：","text":"第二步，我们依旧遗留了一个问题，从引导页进入到程序主界面，打算使用React-Router来解决这个问题。目前我对React-Router也是处于知道但没用过的状态，我们先尝试着寻找资料了解一下这个功能组件（记住React-Router这个名字还是因为我之前使用了很久的vue-router）。来到Reacr-Router Github的主页后，阅读了一下大致的介绍，感觉还是只适合Web的React相关的路由操作（小白见解），我们使用另一个： 1$ npm i react-native-router-flux --save 并且在使用之前建议大家阅读一下这篇文章，接着我们按照Github的文档来看下具体该如何操作： 12// 首先，引入路由import &#123; Router, Scene &#125; from 'react-native-router-flux'; 然后，我们先随便写一个程序的主界面RootPage.js： 123&lt;View&gt; &lt;Text&gt;Hello main page.&lt;/Text&gt;&lt;/View&gt; 然后我们要使用路由做一下界面的跳转之前，我们想一下，引导页只出现一次的，这个问题先留在这里，先去看怎么使用Router，首先改造我们的index.ios.js： 12345678910111213141516171819202122import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, View&#125; from 'react-native';// 引入Router, Sceneimport &#123; Router, Scene &#125; from 'react-native-router-flux';import GuidePage from './GuidePage';import RootPage from './RootPage';class Project extends Component &#123; render() &#123; return ( // 创建路由 &lt;Router&gt; &lt;Scene key=\"root\"&gt; &lt;Scene key=\"guide\" component=&#123;GuidePage&#125; hideNavBar title=\"GuidePage\" initial=&#123;true&#125; /&gt; &lt;Scene key=\"root\" component=&#123;RootPage&#125; title=\"RootPage\" initial=&#123;false&#125;/&gt; &lt;/Scene&gt; &lt;/Router&gt; ); &#125;;&#125;;AppRegistry.registerComponent('Project', () =&gt; Project); 先不要问为什么，接着按照git的文档进行操作，在GuidePage中引入： 1import &#123; Actions, ActionConst &#125; from 'react-native-router-flux'; 并修改进入按钮点击的事件： 1234567&lt;TouchableOpacity onPress=&#123;() =&gt; &#123; // 注意这里 Actions.RootPage(&#123;type: ActionConst.REPLACE&#125;); &#125;&#125; activeOpacity=&#123;50 / 100&#125;&gt; ...&lt;/TouchableOpacity&gt; 然后会发现点击进入按钮之后，界面被主界面替换掉了。现在我们来解释代码： 总共引入了：Router、Scene、Actions、ActionConst4个组件，他们分别的作用是，创建一个路由容器，创建容器内的场景，发起跳转动作，跳转的方式。 所以，这些代码好理解了，我们现在程序入口的时候，创建一个路由： 123456789101112&lt;Router&gt; &lt;Scene key=\"root\"&gt; &lt;Scene key=\"GuidePage\" component=&#123;GuidePage&#125; hideNavBar title=\"GuidePage\" initial=&#123;true&#125; /&gt; &lt;Scene key=\"RootPage\" component=&#123;RootPage&#125; title=\"RootPage\" initial=&#123;false&#125;/&gt; &lt;/Scene&gt;&lt;/Router&gt; 包含了2个界面（场景），供我们切换，里边是一些配置，都是顾名思义的，所以不做多的解释。我们看到有个initial属性，是用来控制谁是首要的，引导页出现一次，所以我们要根据属性来控制程序进入到哪一个界面，我们寻求App的帮助，打开Xcode工程，在AppDelegate中，我们存储一下用户的使用状态。最简单的办法改一下： 1234567BOOL launched = [[NSUserDefaults standardUserDefaults] boolForKey:ApplicationDidLaunchedYet]; RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@&quot;Project&quot; initialProperties:@&#123; @&quot;launched&quot;: @(launched) &#125; launchOptions:launchOptions]; [[NSUserDefaults standardUserDefaults] setBool:YES forKey:ApplicationDidLaunchedYet]; [[NSUserDefaults standardUserDefaults] synchronize]; 然后我们在使用一下： 123456&lt;Router&gt; &lt;Scene key=\"root\"&gt; &lt;Scene key=\"GuidePage\" component=&#123;GuidePage&#125; hideNavBar title=\"GuidePage\" initial=&#123;this.props.launched&#125; /&gt; &lt;Scene key=\"RootPage\" component=&#123;RootPage&#125; title=\"RootPage\" initial=&#123;this.props.launched&#125;/&gt; &lt;/Scene&gt; &lt;/Router&gt; 就OK了，具体的router的其他方法看文档。我们常用的就是PUSH还有POP，接下来我们看看怎么能写一个类似微信iOS App的TabBar，也就是程序的主框架：假设我们需要2个组件，创建2个文件夹，假定我们做一个新闻类的App，第一个叫主页，第二个是个人中心，修改index为： 1234567891011121314151617181920import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, View&#125; from 'react-native';import &#123; Router, Scene &#125; from 'react-native-router-flux';import GuidePage from './GuidePage';import RootPage from './RootPage';class Project extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;Scene key=\"root\"&gt; &lt;Scene key=\"GuidePage\" component=&#123;GuidePage&#125; hideNavBar title=\"GuidePage\" initial=&#123;this.props.launched&#125; /&gt; &lt;Scene key=\"RootPage\" component=&#123;RootPage&#125; title=\"RootPage\" hideNavBar initial=&#123;this.props.launched&#125;/&gt; &lt;/Scene&gt; &lt;/Router&gt; ); &#125;;&#125;;AppRegistry.registerComponent('Project', () =&gt; Project); 在RootPage中创建Tabbar： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React, &#123; Component, &#125; from 'react';import &#123; View, Text, StyleSheet, TabBarIOS &#125; from 'react-native';import &#123; Router, Scene, Actions, ActionConst &#125; from 'react-native-router-flux';import NewsPage from './News/NewsPage';import AccountPage from './Account/AccountPage';class RootPage extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; selectedTab: \"newsTab\" &#125;; &#125; render() &#123; return ( &lt;TabBarIOS unselectedTintColor=\"darkgrey\" tintColor=\"#34A3FF\" barTintColor=\"white\"&gt; &lt;TabBarIOS.Item title=\"News\" systemIcon=\"featured\" selected=&#123;this.state.selectedTab === 'newsTab'&#125; onPress=&#123;() =&gt; &#123; this.setState(&#123; selectedTab: 'newsTab' &#125;); &#125; &#125;&gt; &lt;NewsPage /&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title=\"Account\" systemIcon=\"contacts\" selected=&#123;this.state.selectedTab === 'accountTab'&#125; onPress=&#123;() =&gt; &#123; this.setState(&#123; selectedTab: 'accountTab' &#125;); &#125; &#125;&gt; &lt;AccountPage /&gt; &lt;/TabBarIOS.Item&gt; &lt;/TabBarIOS&gt; ); &#125;;&#125;export default RootPage 然后举例看一下News模块（这个文件管理所有的News路由）： 123456789101112131415161718import React, &#123; Component, &#125; from 'react'import &#123; View, &#125; from 'react-native'import &#123; Router, Scene, Actions, ActionConst &#125; from 'react-native-router-flux';import News from './News'class NewsPage extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;Scene key=\"_NewsRouter\"&gt; &lt;Scene key=\"News\" component=&#123;News&#125; title=\"News\" initial=&#123;true&#125; /&gt; &lt;/Scene&gt; &lt;/Router&gt; ) &#125;&#125;export default NewsPage 这个是默认的News界面： 1234567891011121314import React, &#123; Component, &#125; from 'react'import &#123; View, &#125; from 'react-native'import &#123; Router, Scene, Actions, ActionConst &#125; from 'react-native-router-flux';class News extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123; backgroundColor: 'red', flex: 1 &#125;&#125;&gt; &lt;/View&gt; ) &#125;&#125;export default News 我们来看一下效果： 代码已经上传到github，这就是一个简单的应用程序框架，下周一我们来写新闻列表的获取数据并展示。 代码地址依旧没变。","categories":[],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://wilddylan.github.io/tags/ReactNative/"}],"keywords":[]},{"title":"如何迈出第二步（组件优化）","slug":"如何迈出第二步（组件优化）","date":"2016-10-21T01:19:50.000Z","updated":"2017-02-04T09:02:57.000Z","comments":true,"path":"2016/10/21/如何迈出第二步（组件优化）/","link":"","permalink":"https://wilddylan.github.io/2016/10/21/如何迈出第二步（组件优化）/","excerpt":"真的这种事情很好，勇敢的迈出第一步之后，就必须要接着走下去了。因为我第一篇的文章已经发出去了，并在结尾说下一次要做优化，为了厚脸皮也要用心的把问题解决了。解决完问题之后，还要装个逼，装逼到一半的时候，装不下去了，就必须得继续学习才能继续装逼。希望大家可以勇敢的迈出惧怕或者懒散的一步，程序员不要眼高手低。谁说高手组队不会翻车？不仅仅是这样，越牛逼的人翻车的后果越严重。 接着上一篇比较破的文章（我确实是第一天开始写RN的代码，之前都是看），发文章的时候我甚至有点脸红，妈的这是第一次，觉得这么坑的文章要发出去了，但是随之带来的就是写好下一篇的思想。不啰嗦，开始写：","text":"真的这种事情很好，勇敢的迈出第一步之后，就必须要接着走下去了。因为我第一篇的文章已经发出去了，并在结尾说下一次要做优化，为了厚脸皮也要用心的把问题解决了。解决完问题之后，还要装个逼，装逼到一半的时候，装不下去了，就必须得继续学习才能继续装逼。希望大家可以勇敢的迈出惧怕或者懒散的一步，程序员不要眼高手低。谁说高手组队不会翻车？不仅仅是这样，越牛逼的人翻车的后果越严重。 接着上一篇比较破的文章（我确实是第一天开始写RN的代码，之前都是看），发文章的时候我甚至有点脸红，妈的这是第一次，觉得这么坑的文章要发出去了，但是随之带来的就是写好下一篇的思想。不啰嗦，开始写： 上节最后的优化，是把pageControl用for循环写了，然后我们先在最小的组件中看下有没有可以优化的地方。PageControl.js中： 123456789101112131415161718192021222324const styles = StyleSheet.create(&#123; container: &#123; backgroundColor: 'white', flexDirection: 'row', alignItems: 'center', justifyContent: \"space-between\", width: 50, marginTop: 40 &#125;, item: &#123; width: 10, height: 10, borderRadius: 5, backgroundColor: 'white', borderColor: '#34a3ff', borderWidth: 1 &#125;, itemHighLight: &#123; width: 10, height: 10, borderRadius: 5, backgroundColor: 'skyblue' &#125;&#125;); css写重复了，我们提取相同的： 12345678910111213itemSize: &#123; width: 10, height: 10, borderRadius: 5,&#125;,item: &#123; backgroundColor: 'white', borderColor: '#34a3ff', borderWidth: 1&#125;,itemHighLight: &#123; backgroundColor: 'skyblue'&#125; 然后将render()方法中不会改变的局部变量用let定义： 12345678910111213141516render() &#123; let number = this.props.number; let index = this.props.index; var items = new Array(); for (var i=0; i&lt;number; i++) &#123; let item = ( &lt;View style=&#123;[(i == index ? styles.itemHighLight : styles.item), styles.itemSize]&#125; key=&#123;i&#125; &gt;&lt;/View&gt; ); items.push(item); &#125; return ( &lt;View style=&#123;styles.container&#125;&gt; &#123;items&#125; &lt;/View&gt; )&#125; 然后想一个问题，如何可以让PageControl保持不跟着ScrollView一起滚动呢（我们现在相当于创建了3个PageControl）？所以这里PageControl组件要提供一个动态修改当前index的功能。所以scrollView的滑动我们要监听，然后在状态中加入当前的页码。这个时候我们会发现，PageControl与下边的进入按钮其实是不动的，所以我们将index.ios.js中的内容再次拆分为上下两部分，上边显示内容，下边显示pageControl与进入按钮。这个时候，程序要大改了，貌似之前写的都有问题，但是别急，慢慢来看，我们就是将东西诺了个位置。 既然让pageControl不动，所以只能使用position: &#39;absolute&#39;来帮助它脱离当前的文档流（当前的视图层），并且要实时的控制pageControl的展示，所以在index.ios.js中的state中加入currentIndex属性，并监听scrollView的滑动。最终我们的PageControl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import React, &#123; Component, &#125; from 'react'import &#123; View, StyleSheet, Dimensions &#125; from 'react-native'class PageControl extends Component &#123; static propTypes = &#123;&#125; static defaultProps = &#123;&#125; constructor(props) &#123; super(props) this.state = &#123;&#125; &#125; render() &#123; let number = this.props.number; let index = this.props.index; var items = new Array(); let screenWidth = Dimensions.get('window').width; let containerPosition = &#123; width: number * 20, position: 'absolute', left: (screenWidth - number * 20) / 2.0, top: this.props.top &#125;; for (var i=0; i&lt;number; i++) &#123; let item = ( &lt;View style=&#123;[(i == index ? styles.itemHighLight : styles.item), styles.itemSize]&#125; key=&#123;i&#125; &gt;&lt;/View&gt; ); items.push(item); &#125; return ( &lt;View style=&#123;[styles.container, containerPosition]&#125;&gt; &#123;items&#125; &lt;/View&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; backgroundColor: 'white', flexDirection: 'row', alignItems: 'center', justifyContent: \"space-between\", width: 50, marginTop: 40 &#125;, itemSize: &#123; width: 10, height: 10, borderRadius: 5, &#125;, item: &#123; backgroundColor: 'white', borderColor: '#34a3ff', borderWidth: 1 &#125;, itemHighLight: &#123; backgroundColor: 'skyblue' &#125;&#125;);export default PageControl 再看一下ScrollContent： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React, &#123; Component, &#125; from 'react'import &#123; View, StyleSheet, Image, Text, Dimensions&#125; from 'react-native'class ScrollContent extends Component &#123; static propTypes = &#123;&#125; static defaultProps = &#123;&#125; constructor(props) &#123; super(props) this.state = &#123;&#125; &#125; render() &#123; return ( &lt;View style=&#123; styles.container &#125;&gt; &lt;Image source=&#123;&#123; uri: this.props.uri &#125;&#125; style=&#123; styles.image &#125;/&gt; &lt;Text style=&#123;styles.title&#125;&gt;&#123;this.props.title&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.detail&#125;&gt;&#123;this.props.detail&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.subDetail&#125;&gt;&#123;this.props.subDetail&#125;&lt;/Text&gt; &lt;/View&gt; ) &#125;&#125;const contentWidth = Dimensions.get('window').width;const contentHeight = Dimensions.get('window').height;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, alignItems: 'center', justifyContent: \"center\", backgroundColor: 'white', width: contentWidth, height: contentHeight &#125;, image: &#123; width: 253, height: 200 &#125;, title: &#123; fontSize: 24, color: '#358ED7', fontWeight: \"400\", marginTop: 50 &#125;, detail: &#123; fontSize: 14, color: '#1D1D26', fontWeight: \"400\", marginTop: 20 &#125;, subDetail: &#123; fontSize: 14, color: '#1D1D26', fontWeight: \"400\", marginTop: 2 &#125;&#125;);export default ScrollContent index.ios.js中我们顺便把初始化content的地方改掉，并且在最后一张的时候展示进入App按钮： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, View, ScrollView, TouchableOpacity, Dimensions, Text&#125; from 'react-native';import ScrollContent from './ScrollContent';import PageControl from './PageControl';class Project extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; currentIndex: 0 &#125;; &#125; render() &#123; let screenWidth = Dimensions.get('window').width; let pageControlTop = screenWidth / 2.0 + 300; let objects = [ &#123; uri: \"http://ocef2grmj.bkt.clouddn.com/Group.png\", title: \"Shopping directly\", detail: \"Know your factories. Know your costs.\", subDetail: \"Always ask why.\" &#125;, &#123; uri: \"http://ocef2grmj.bkt.clouddn.com/Clothes-illustration.png\", title: \"Hello world!\", detail: \"Know your factories. Know your costs.\", subDetail: \"Always ask why.\" &#125;, &#123; uri: \"http://ocef2grmj.bkt.clouddn.com/Group1.png\", title: \"What are you doing?\", detail: \"Know your factories. Know your costs.\", subDetail: \"Always ask why.\" &#125; ]; var scrollItems = new Array(); for (var i=0; i&lt;objects.length; i++) &#123; let obj = objects[i]; let item = ( &lt;ScrollContent uri=&#123;obj.uri&#125; title=&#123;obj.title&#125; detail=&#123;obj.detail&#125; subDetail=&#123;obj.subDetail&#125; key=&#123;i&#125;/&gt; ); scrollItems.push(item); &#125; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;ScrollView style=&#123;styles.scrollView&#125; horizontal=&#123;true&#125; showsHorizontalScrollIndicator=&#123;false&#125; alwaysBounceHorizontal=&#123;true&#125; pagingEnabled=&#123;true&#125; onScroll=&#123;(event: Object) =&gt; &#123; let caluIndex = parseInt(event.nativeEvent.contentOffset.x / screenWidth); this.setState(&#123; currentIndex: caluIndex &#125;); &#125;&#125; &gt; &#123;scrollItems&#125; &lt;/ScrollView&gt; &lt;PageControl number=&#123;objects.length&#125; index=&#123;this.state.currentIndex&#125; top=&#123;pageControlTop&#125;/&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; &#123;&#125;&#125; activeOpacity=&#123;50 / 100&#125;&gt; &#123; this.state.currentIndex == objects.length - 1 ? (&lt;Text style=&#123; styles.enterButton &#125;&gt;Enter&lt;/Text&gt;): (null) &#125; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1 &#125;, scrollView: &#123; flex: 1, backgroundColor: 'white' &#125;, enterButton: &#123; position: 'absolute', left: (Dimensions.get('window').width - 70) / 2.0, bottom: 15, color: '#34A3FF', fontSize: 17, fontWeight: \"400\", borderWidth: 1, borderColor: '#34A3FF', borderRadius: 3, padding: 5, paddingLeft: 15, paddingRight: 15, &#125;&#125;);AppRegistry.registerComponent('Project', () =&gt; Project); 接下来，我们要把这个ScrollView单开一个叫做引导页的组件GuidePage.js： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import React, &#123; Component, &#125; from 'react'import &#123; View, ScrollView, TouchableOpacity, Dimensions, Text, StyleSheet &#125; from 'react-native'import ScrollContent from './ScrollContent';import PageControl from './PageControl';class GuidePage extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; currentIndex: 0 &#125;; &#125; render() &#123; let screenWidth = Dimensions.get('window').width; let pageControlTop = screenWidth / 2.0 + 300; let objectNum = this.props.objects.length; var scrollItems = new Array(); for (var i=0; i&lt;objectNum; i++) &#123; let obj = this.props.objects[i]; let item = ( &lt;ScrollContent uri=&#123;obj.uri&#125; title=&#123;obj.title&#125; detail=&#123;obj.detail&#125; subDetail=&#123;obj.subDetail&#125; key=&#123;i&#125;/&gt; ); scrollItems.push(item); &#125; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;ScrollView style=&#123;styles.scrollView&#125; horizontal=&#123;true&#125; showsHorizontalScrollIndicator=&#123;false&#125; alwaysBounceHorizontal=&#123;true&#125; pagingEnabled=&#123;true&#125; onScroll=&#123;(event: Object) =&gt; &#123; let caluIndex = parseInt(event.nativeEvent.contentOffset.x / screenWidth); this.setState(&#123; currentIndex: caluIndex &#125;); &#125;&#125; &gt; &#123;scrollItems&#125; &lt;/ScrollView&gt; &lt;PageControl number=&#123;objectNum&#125; index=&#123;this.state.currentIndex&#125; top=&#123;pageControlTop&#125;/&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; &#123;&#125;&#125; activeOpacity=&#123;50 / 100&#125;&gt; &#123; this.state.currentIndex == objectNum - 1 ? (&lt;Text style=&#123; styles.enterButton &#125;&gt;Enter&lt;/Text&gt;): (null) &#125; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1 &#125;, scrollView: &#123; flex: 1, backgroundColor: 'white' &#125;, enterButton: &#123; position: 'absolute', left: (Dimensions.get('window').width - 70) / 2.0, bottom: 15, color: '#34A3FF', fontSize: 17, fontWeight: \"400\", borderWidth: 1, borderColor: '#34A3FF', borderRadius: 3, padding: 5, paddingLeft: 15, paddingRight: 15, &#125;&#125;);export default GuidePage 然后在使用的时候index.ios.js： 12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, View&#125; from 'react-native';import GuidePage from './GuidePage';class Project extends Component &#123; render() &#123; let objects = [ &#123; uri: \"http://ocef2grmj.bkt.clouddn.com/Group.png\", title: \"Shopping directly\", detail: \"Know your factories. Know your costs.\", subDetail: \"Always ask why.\" &#125;, &#123; uri: \"http://ocef2grmj.bkt.clouddn.com/Clothes-illustration.png\", title: \"Hello world!\", detail: \"Know your factories. Know your costs.\", subDetail: \"Always ask why.\" &#125;, &#123; uri: \"http://ocef2grmj.bkt.clouddn.com/Group1.png\", title: \"What are you doing?\", detail: \"Know your factories. Know your costs.\", subDetail: \"Always ask why.\" &#125; ]; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;GuidePage objects=&#123;objects&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1 &#125;&#125;);AppRegistry.registerComponent('Project', () =&gt; Project); 这样，我们解决了引导页的封装，第一次入手，确实绕弯，道行不深啊。不急慢慢来，既然有了引导页，就要点击进入的时候跳转到App中，这个操作如何来完成呢？我们知道，index.ios.js是我们程序的入口，而且引导页只出现一次，我们下篇文章来摸索一下。 代码的地址还没变哦，在迈出第一步中文末有。","categories":[],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://wilddylan.github.io/tags/ReactNative/"}],"keywords":[]},{"title":"如何迈出第一步","slug":"如何迈出第一步","date":"2016-10-20T02:59:32.000Z","updated":"2017-02-04T08:40:45.000Z","comments":true,"path":"2016/10/20/如何迈出第一步/","link":"","permalink":"https://wilddylan.github.io/2016/10/20/如何迈出第一步/","excerpt":"在算法前5课结束后，我渐渐的明白了一个道理：不管前方多难，放手去做吧，最难的是迈出第一步，迈出去了，以后就掌控在你手中了。快排、最短路径、二叉树算是算法的基础内容，但是之前一直不敢下手把他们写出来，因为工作3年多了，都是在创业公司，重重的业务负担让人满脑子充斥的都是业务逻辑、UI界面，5年前学的东西都忘的干净，所以我不假思索的在日程中加入了写算法文章，并且马上买了一本算法的书。然后逼着自己写了开篇之后，发现每天上午上班，先放开手中的工作，安静的读书、实践代码、写出来自己的思想并分享给大家是一件很不错的事情，而且渐渐的觉得重新拾起了算法。其实我买的书的内容，就是讲解到了二叉树就完结了，我大概用了4天的时间读完了这本书。 然后就是今天所写的react-native，其实在RN刚出的时候，我就开始入手了（忠实的FaceBook技术粉），但是一直在给自己找理由不去实践，每次版本更新，也只是去官网看看例子，觉得理解就行了。这段时间有朋友问到我相关的东西，我发现，在实际动手的时候，我就写个登录界面都写的不是很得心应手。所以决定迈出写项目的第一步。那，又有人要问了，写什么项目呢？先别急，既然是迈出第一步，那就要慢慢来。我姑且当读者都熟悉HTML、CSS、JS。","text":"在算法前5课结束后，我渐渐的明白了一个道理：不管前方多难，放手去做吧，最难的是迈出第一步，迈出去了，以后就掌控在你手中了。快排、最短路径、二叉树算是算法的基础内容，但是之前一直不敢下手把他们写出来，因为工作3年多了，都是在创业公司，重重的业务负担让人满脑子充斥的都是业务逻辑、UI界面，5年前学的东西都忘的干净，所以我不假思索的在日程中加入了写算法文章，并且马上买了一本算法的书。然后逼着自己写了开篇之后，发现每天上午上班，先放开手中的工作，安静的读书、实践代码、写出来自己的思想并分享给大家是一件很不错的事情，而且渐渐的觉得重新拾起了算法。其实我买的书的内容，就是讲解到了二叉树就完结了，我大概用了4天的时间读完了这本书。 然后就是今天所写的react-native，其实在RN刚出的时候，我就开始入手了（忠实的FaceBook技术粉），但是一直在给自己找理由不去实践，每次版本更新，也只是去官网看看例子，觉得理解就行了。这段时间有朋友问到我相关的东西，我发现，在实际动手的时候，我就写个登录界面都写的不是很得心应手。所以决定迈出写项目的第一步。那，又有人要问了，写什么项目呢？先别急，既然是迈出第一步，那就要慢慢来。我姑且当读者都熟悉HTML、CSS、JS。 当我们下载一个新的App的时候，我们最先看到的是什么？没错，启动页，引导图。启动页是配置到配置文件中的，所以我们来完成我们第一个引导页的制作 如果按照App的开发角度，这个界面可以用ScrollView、pageControl、Button来完成，当然在RN中也我们也假定是这样的。大家各自新建一个RN的项目，并且我们以iOS为准。 项目名大家随便搞一个，我们先不急着对文件进行分组归类，也不需要想着任何有关架构设想的事情。直接在index.ios.js中开始我们第一个界面的制作，当然，按照App的思想，这个视图控制器的基本层级是： View：ScrollView：pageControl, Button，所以我们先渲染一个全屏的View，背景色为skyblue： 123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, View&#125; from 'react-native'class Project extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: 'skyblue', &#125;&#125;);AppRegistry.registerComponent('Project', () =&gt; Project); 接着，我们写一个ScrollView上去：并且在上边加入3个屏幕大小的不同颜色的View，并对scrollView做一些简单的配置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, View, ScrollView, Text, Dimensions&#125; from 'react-native'class Project extends Component &#123; render() &#123; var windowWidth = Dimensions.get('window').width; var windowHeight = Dimensions.get('window').height; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;ScrollView horizontal=&#123;true&#125; showsHorizontalScrollIndicator=&#123;false&#125; alwaysBounceHorizontal=&#123;true&#125; pagingEnabled=&#123;true&#125; style=&#123;styles.scrollView&#125;&gt; &lt;View style=&#123;&#123; backgroundColor: 'orange', height: windowHeight, width: windowWidth &#125;&#125; /&gt; &lt;View style=&#123;&#123; backgroundColor: 'red', height: windowHeight, width: windowWidth &#125;&#125; /&gt; &lt;View style=&#123;&#123; backgroundColor: 'yellow', height: windowHeight, width: windowWidth &#125;&#125; /&gt; &lt;/ScrollView&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1 &#125;, scrollView: &#123; flex: 1, backgroundColor: 'skyblue' &#125;&#125;);AppRegistry.registerComponent('Project', () =&gt; Project); 接下来我们亲自写一个小组件，用于放至中间的一张图片以及一段文字，新建一个js文件，姑且命名为scrollContent.js，先别急着写，先把这个组件引入到index.js种，然后替换到刚刚我们的View。 然后再开始编写，这里要注意，我们先约定，组件的样式定义到组件里。 组件内容，我们大致的拆分为：图片，标题，详情，附加详情。 原本应该是这样的，但是我们看到下边还有一个页面指示器，所以我们还需要一个占位的视图。至于下边的跳过按钮，我暂时觉得这个不太好，我们应该在最后一页才展示一个进入App的按钮（要求用户必须看完。。），所以我们先写一个这样的按钮放到底部。我一度没有正规的学过前端，所以css写的特别烂！希望可以在博客之路找到个好的老司机带路上车！先来看组件的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import React, &#123; Component, &#125; from 'react'import &#123; View, StyleSheet, Image, Text, Dimensions, TouchableOpacity,&#125; from 'react-native'class ScrollContent extends Component &#123; static propTypes = &#123;&#125; static defaultProps = &#123;&#125; constructor(props) &#123; super(props) this.state = &#123;&#125; &#125; render() &#123; return ( // http://ocef2grmj.bkt.clouddn.com/Clothes-illustration.png // http://ocef2grmj.bkt.clouddn.com/Group1.png &lt;View&gt; &lt;View style=&#123; styles.container &#125;&gt; &lt;Image source=&#123;&#123; uri:'http://ocef2grmj.bkt.clouddn.com/Group.png' &#125;&#125; style=&#123; styles.image &#125;/&gt; &lt;Text style=&#123; styles.title &#125;&gt;Shopping directly&lt;/Text&gt; &lt;Text style=&#123; styles.detail &#125;&gt;Know your factories. Know your costs.&lt;/Text&gt; &lt;Text style=&#123; styles.subDetail &#125;&gt;Always ask why.&lt;/Text&gt; &lt;View style=&#123; styles.placeHold &#125;&gt;&lt;/View&gt; &lt;/View&gt; &lt;View style=&#123; styles.buttonGroup &#125;&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; &#123;&#125;&#125; activeOpacity=&#123;50 / 100&#125;&gt; &lt;Text style=&#123; styles.enterButton &#125;&gt;Enter&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; &lt;/View&gt; ) &#125;&#125;const contentWidth = Dimensions.get('window').width;const contentHeight = Dimensions.get('window').height - 60;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, alignItems: 'center', justifyContent: 'center', backgroundColor: 'white', width: contentWidth, height: contentHeight &#125;, image: &#123; width: 253, height: 200 &#125;, title: &#123; fontSize: 24, color: '#358ED7', fontWeight: \"400\", marginTop: 50 &#125;, detail: &#123; fontSize: 14, color: '#1D1D26', fontWeight: \"400\", marginTop: 20 &#125;, subDetail: &#123; fontSize: 14, color: '#1D1D26', fontWeight: \"400\", marginTop: 2 &#125;, placeHold: &#123; marginTop: 40, height: 15, width: 80 &#125;, buttonGroup: &#123; height: 60, width: contentWidth, flex: 1, alignItems: 'center', justifyContent: 'center', backgroundColor: 'white' &#125;, enterButton: &#123; padding: 15, paddingTop: 5, paddingBottom: 5, borderWidth: 1, color: '#34A3FF', fontSize: 17, borderColor: '#34A3FF', borderRadius: 3 &#125;&#125;);export default ScrollContent 然后看使用： 123456789101112131415161718192021222324252627282930313233343536373839404142import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, View, ScrollView,&#125; from 'react-native'import ScrollContent from './ScrollContent'class Project extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;ScrollView horizontal=&#123;true&#125; showsHorizontalScrollIndicator=&#123;false&#125; alwaysBounceHorizontal=&#123;true&#125; pagingEnabled=&#123;true&#125; style=&#123;styles.scrollView&#125;&gt; &lt;ScrollContent /&gt; &lt;ScrollContent /&gt; &lt;ScrollContent /&gt; &lt;/ScrollView&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1 &#125;, scrollView: &#123; flex: 1, backgroundColor: 'skyblue' &#125;&#125;);AppRegistry.registerComponent('Project', () =&gt; Project); 这个时候，我们发现组件里的内容还是外界传入比较好，所以使用props，我们来修改自己的组件： 12345678910111213141516171819return ( &lt;View&gt; &lt;View style=&#123; styles.container &#125;&gt; &lt;Image source=&#123;&#123; uri: this.props.uri &#125;&#125; style=&#123; styles.image &#125;/&gt; &lt;Text style=&#123; styles.title &#125;&gt;&#123;this.props.title&#125;&lt;/Text&gt; &lt;Text style=&#123; styles.detail &#125;&gt;&#123;this.props.detail&#125;&lt;/Text&gt; &lt;Text style=&#123; styles.subDetail &#125;&gt;&#123;this.props.subDetail&#125;&lt;/Text&gt; &lt;View style=&#123; styles.placeHold &#125;&gt;&lt;/View&gt; &lt;/View&gt; &lt;View style=&#123; styles.buttonGroup &#125;&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; &#123;&#125;&#125; activeOpacity=&#123;50 / 100&#125;&gt; &#123; this.props.showEnter == true? (&lt;Text style=&#123; styles.enterButton &#125;&gt;Enter&lt;/Text&gt;): (null) &#125; &lt;/TouchableOpacity&gt; &lt;/View&gt; &lt;/View&gt; ) 然后在使用： 123456789101112131415161718&lt;ScrollContent uri=\"http://ocef2grmj.bkt.clouddn.com/Group.png\" title=\"Shopping directly\" detail=\"Know your factories. Know your costs.\" subDetail=\"Always ask why.\" showEnter=&#123;false&#125; /&gt;&lt;ScrollContent uri=\"http://ocef2grmj.bkt.clouddn.com/Clothes-illustration.png\" title=\"Buy shoes\" detail=\"Know your factories. Know your costs.\" subDetail=\"Always ask why.\" showEnter=&#123;false&#125; /&gt;&lt;ScrollContent uri=\"http://ocef2grmj.bkt.clouddn.com/Group1.png\" title=\"Shopping directly\" detail=\"Know your factories. Know your costs.\" subDetail=\"Always ask why.\" showEnter=&#123;true&#125; /&gt; 这样完成了之后，我们来看一下初期的效果： 你们完成了么？然后大家发现，我们只是完成了一部分，少了一个指示器，然后我们来自定义这个控件，新建js文件pageControl.js。最简单的思维，3个小View（这里我们先写死3个）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123; Component, &#125; from 'react'import &#123; View, StyleSheet &#125; from 'react-native'class PageControl extends Component &#123; static propTypes = &#123;&#125; static defaultProps = &#123;&#125; constructor(props) &#123; super(props) this.state = &#123;&#125; &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;this.props.index == 0 ? styles.itemHighLight : styles.item&#125;&gt;&lt;/View&gt; &lt;View style=&#123;this.props.index == 1 ? styles.itemHighLight : styles.item&#125;&gt;&lt;/View&gt; &lt;View style=&#123;this.props.index == 2 ? styles.itemHighLight : styles.item&#125;&gt;&lt;/View&gt; &lt;/View&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; backgroundColor: 'white', flexDirection: 'row', alignItems: 'center', justifyContent: \"space-between\", width: 50, marginTop: 40 &#125;, item: &#123; width: 10, height: 10, borderRadius: 5, backgroundColor: 'white', borderColor: '#34a3ff', borderWidth: 1 &#125;, itemHighLight: &#123; width: 10, height: 10, borderRadius: 5, backgroundColor: 'skyblue' &#125;&#125;);export default PageControl 这里写的比较作死， 这里应该是外界传入items的个数，然后每次设置一下index就好了，这里偷懒了，我们继续来优化这个pageControl，稍作修改： 12345678910111213141516render() &#123; var number = this.props.number; var index = this.props.index; var items = new Array(); for (var i=0; i&lt;number; i++) &#123; var item = ( &lt;View style=&#123;i == index ? styles.itemHighLight : styles.item&#125; key=&#123;i&#125; &gt;&lt;/View&gt; ); items.push(item); &#125; return ( &lt;View style=&#123;styles.container&#125;&gt; &#123;items&#125; &lt;/View&gt; ) &#125; 这样在使用的时候就可以： 1&lt;PageControl style=&#123;styles.pageControl&#125; number=&#123;3&#125; index=&#123;this.props.index&#125;/&gt; 到现在，我们总算磕磕绊绊的完成了一个滑动视图，而且还有很多的缺陷。明天我们继续来优化这个小的组件，争取做到每个方面都很极致。 代码的地址，以后每次更新之后都会修改这里的代码。","categories":[],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://wilddylan.github.io/tags/ReactNative/"}],"keywords":[]},{"title":"算法第五课","slug":"算法第五课","date":"2016-10-19T04:55:39.000Z","updated":"2017-02-04T09:02:26.000Z","comments":true,"path":"2016/10/19/算法第五课/","link":"","permalink":"https://wilddylan.github.io/2016/10/19/算法第五课/","excerpt":"树什么是树，没有回路的就是树，有回路的就是图。树有很多特性： 树中的任意两个点有且仅有唯一的一条路 树中如果有n个点，那么它一定恰好有n-1条边 在树中任意两点之间加一条，就会构成回路 常见的树，有家谱、操作系统的文件夹，目录等。并且我们规定，只要是没有回路的连通无向图就是树。为了确定每一棵树的形态，我们在对一棵树进行讨论的时候，将树中每个点称为结点或者节点，在树中，我们可以指定一个特殊的节点-根。有一个根的树叫做有根树。根又叫做根节点，一棵树有且仅有一个根节点。根节点又可以被称为祖先，接下来就是父节点（没有父节点的节点就是根），子节点。如果一个节点没有子节点，这个节点被称为叶节点。如果一个节点既不是根节点也不是叶节点，也可以被称为内部节点，每个节点有深度，深度指的是从根到这个节点的层数（根为第一层）。","text":"树什么是树，没有回路的就是树，有回路的就是图。树有很多特性： 树中的任意两个点有且仅有唯一的一条路 树中如果有n个点，那么它一定恰好有n-1条边 在树中任意两点之间加一条，就会构成回路 常见的树，有家谱、操作系统的文件夹，目录等。并且我们规定，只要是没有回路的连通无向图就是树。为了确定每一棵树的形态，我们在对一棵树进行讨论的时候，将树中每个点称为结点或者节点，在树中，我们可以指定一个特殊的节点-根。有一个根的树叫做有根树。根又叫做根节点，一棵树有且仅有一个根节点。根节点又可以被称为祖先，接下来就是父节点（没有父节点的节点就是根），子节点。如果一个节点没有子节点，这个节点被称为叶节点。如果一个节点既不是根节点也不是叶节点，也可以被称为内部节点，每个节点有深度，深度指的是从根到这个节点的层数（根为第一层）。 二叉树二叉树是一种特殊的数，二叉树的特点是，每个节点最多有2个子节点，左边的叫做左节点，右边的叫做右节点。或者说，每个节点最多有2个子树，更加严格的递归定义是：二叉树要么为空，要么由根节点、左子树、右子树构成，而左子树，右子树分别又是一棵二叉树。 二叉树还有两种特殊定义的二叉树，叫做满二叉树（二叉树中每个内部节点都有2个子节点，严格的定义是深度为h且有2^h-1个节点的树）和完全二叉树（一棵树除了最右边的位置上有一个或是几个节点缺少外，其他是丰满的，则是完全二叉树，严格的定义是：若设二叉树的高度为h，除第h层外，其他各层的节点树都达到最大个数，第h层从右向左连续缺若干节点，一个树，有右节点必有左节点）。可以将满二叉树理解为极其完美的完全二叉树。 先想一想，一棵完全二叉树如何做存储呢？其实二叉树种，父节点与子节点有着很不错的规律，只需用一个一维数组就可以存储完全二叉树： 通过上图我们发现，如果完全二叉树的一个编号为K，那么他左子节点的编号是2*K，右子节点的编号是2*K + 1，如果已知子节点的编号为X，那么父节点的编号就是X/2。如果一个完全二叉树有N个节点，那么这个完全二叉树的高度为 1logN 即最多有logN层节点。完全二叉树最典型的应用就是堆。 堆，神奇的优先队列什么是堆，堆就是一种特殊的完全二叉树 如上图，有没有发现这棵二叉树有一个特点，就是所有的父节点都比子节点要小（圆圈里边的是值，上面的树是编号），符合这样特点的完全二叉树被我们称为最小堆，反之，如果父节点都比子节点要大，称为最大堆。 假如有14个数： 199, 5, 36, 7, 22, 17, 46, 12, 2, 19, 25, 28, 1, 92 请找出这14个数中最小的数，你可能直接想到了，一个循环不就好了么 12345for (int i = 1; i &lt;= 14; i ++) &#123; if (a[i] &lt; min) &#123; min = a[i]; &#125;&#125; 这种方法的时间复杂度是O(14)，也就是O(N)。假如有14次这样的操作，就是O(14^2)，有没有更好的方法呢？堆这个特殊的结构恰好能够很好的解决这个问题。首先我们把14个数字按照最小堆的要求放入一棵完全二叉树，就像下边这棵树一样： 很显然，最小的树就在堆顶，假设存储这个堆的数组叫做h的话，最小数就是h[1]。如果我们要删除最小值并增加一个数字23呢？我们将堆顶的数字移除，然后将23放入堆顶。显然加了新的数值后，已经不符合最小堆的特性了，我们需要将新加入树的节点调整到合理的位置。 当然是向下调整了，最小堆种的大数都在下边的。所以我们只需要不停的与当前节点的子节中较小的节点进行比较并且互换。 我们发现，在堆23进行调整的时候，只进行了3次比较，就恢复了最小堆的特性。现在每次删除一个最小的数的同时增加一个新的数，需要的时间复杂度是O(3)，恰好是$$O(log_214) 也就是 O(log_2N)，简写为 O(logN)$$如果只想新增一个值呢？只需要把这个值插入到末尾，然后根据情况判断新元素是否需要上移，加入我们现在需要新增一个数字3： 先将3与它的父节点比较，如果比父节点小，则更换位置，继续向上比较即可。说了这么半天，我们忽略了一个很大的问题，怎么创建一个堆呢？可以从空的堆开始，依次的读入元素。还有一种方法，那就是直接把这14个数放入一个完全二叉树中（这里依旧用一个一维数组存储完全二叉树）： 12position: 1 2 3 4 5 6 7 8 9 10 11 12 13 14data : 99 5 36 7 22 17 92 12 2 19 25 28 1 46 我们从叶节点开始，因为叶节点没有子节点，所以所有的叶节点都符合最小堆特性，所以我们开始处理叶节点之外的点。不符合最小堆特性的都需要向下调整。说白了就2行代码： 123for (int i = n / 2; i &gt;= 1; i --) &#123; siftDown(i); // 向下调整&#125; 二叉树还有一个特点：第n/2一定是这棵树的最后一个非叶节点。用这种方法创建堆的时间复杂度为O(N)。堆还有一个作用是排序，排序的时间复杂度也是O(NlogN)，根据我们上边的思维，堆排序就很简单了，比如我们要从小到大排序，我们先建立一个最小堆，然后堆顶的就是最小的，每次删除顶部元素并输出，直到堆空为止。 说了这么多，我们通过代码来看一下建立堆与堆排序的完整过程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576int h[101]; // 用来存放堆的数组int n; // 用来存储堆中元素的个数，也就是堆的大小void swap(int x, int y) &#123; int temp = h[x]; h[x] = h[y]; h[y] = temp; return;&#125;void siftdown(int i) &#123; // 传入一个需要向下调整的节点编号i int position, flag = 0; // 使用flag来标记是否还需要继续向下调整 // 当i节点有左子节点并且需要继续调整的时候 while ( i * 2 &lt;= n &amp;&amp; flag == 0 ) &#123; // 首先判断与左子节点的关系，用position记录比较小的结点编号 if ( h[i] &gt; h[i * 2] ) &#123; position = i * 2; &#125; else &#123; position = i; &#125; if ( i * 2 + 1 &lt;= n ) &#123; if ( h[position] &gt; h[i * 2 + 1] ) &#123; // 注意这里是 h[position]，说白了也就是3个值中的最小值 position = i * 2 + 1; &#125; &#125; // 如果最小的编号不是当前编号，说明子节点小于父节点 if ( position != i ) &#123; // 交换 position 与 i 位置的数字 swap(position, i); i = position; // 更新i为交换的子节点的位置，便于继续向下交换 &#125; else &#123; flag = 1; // 意味着父节点是最小，不需要调整了 &#125; &#125; return;&#125;void create() &#123; for (int i = n / 2; i &gt;= 1; i --) &#123; siftdown(i); &#125; return;&#125;int deleteMax() &#123; int temp = h[1]; // 新建一个变量来存储堆顶的值 h[1] = h[n]; // 将堆的最后一个元素赋值给堆顶 n --; // 堆的元素减少1 siftdown(1); // 将堆顶向下排序 return temp;&#125;int main(int argc, const char * argv[]) &#123; int num; // 要排序数字的个数 scanf(\"%d\", &amp;num); for (int i = 1; i &lt;= num; i ++) &#123; scanf(\"%d\", &amp;h[i]); // 将输入的数字顺序初始化到一维数中 &#125; n = num; // 表示堆中元素的个数 // 创建堆 create(); // 删除顶部元素 for (int i = 1; i &lt;= num; i ++) &#123; printf(\"%d \", deleteMax()); &#125; return 0;&#125; 有人说了，不是还有最大堆么？哈哈，你真聪明，接着改代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374int h[101]; // 用来存放堆的数组int n; // 用来存储堆中元素的个数，也就是堆的大小void swap(int x, int y) &#123; int temp = h[x]; h[x] = h[y]; h[y] = temp; return;&#125;void siftdown(int i) &#123; // 传入一个需要向下调整的节点编号i int position, flag = 0; // 使用flag来标记是否还需要继续向下调整 // 当i节点有左子节点并且需要继续调整的时候 while ( i * 2 &lt;= n &amp;&amp; flag == 0 ) &#123; // 首先判断与左子节点的关系，用position记录比较大的结点编号 if ( h[i] &lt; h[i * 2] ) &#123; position = i * 2; &#125; else &#123; position = i; &#125; if ( i * 2 + 1 &lt;= n ) &#123; if ( h[position] &lt; h[i * 2 + 1] ) &#123; // 注意这里是 h[position]，说白了也就是3个值中的最大值 position = i * 2 + 1; &#125; &#125; // 如果最小的编号不是当前编号，说明子节点大于父节点 if ( position != i ) &#123; // 交换 position 与 i 位置的数字 swap(position, i); i = position; // 更新i为交换的子节点的位置，便于继续向下交换 &#125; else &#123; flag = 1; // 意味着父节点是最大，不需要调整了 &#125; &#125; return;&#125;void create() &#123; for (int i = n / 2; i &gt;= 1; i --) &#123; siftdown(i); &#125; return;&#125;int main(int argc, const char * argv[]) &#123; int num; // 要排序数字的个数 scanf(\"%d\", &amp;num); for (int i = 1; i &lt;= num; i ++) &#123; scanf(\"%d\", &amp;h[i]); // 将输入的数字顺序初始化到一维数中 &#125; n = num; // 表示堆中元素的个数 // 创建堆 create(); while (n &gt; 1) &#123; swap(1, n); n --; siftdown(1); &#125; // 删除顶部元素 for (int i = 1; i &lt;= num; i ++) &#123; printf(\"%d \", h[i]); &#125; return 0;&#125; 并且，堆排序的时间复杂度为$$O(NlogN)$$另外，如果求一个数列中第K小的数，只需要建立一个大小为K的最大堆，堆顶就是第K小的数字，时间复杂度为$$O(NlogK)$$树还有很多神奇的用法，比如线段树、树状数组、Trie树、二叉搜索树、红黑树等，这些结构比较复杂，大家可以多多探索。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wilddylan.github.io/tags/算法/"}],"keywords":[]},{"title":"算法第四课","slug":"算法第四课","date":"2016-10-18T07:06:36.000Z","updated":"2017-02-04T09:02:29.000Z","comments":true,"path":"2016/10/18/算法第四课/","link":"","permalink":"https://wilddylan.github.io/2016/10/18/算法第四课/","excerpt":"深度和广度是什么 为什么叫做深度与广度优先呢，其实是针对图的遍历而言的，请看 使用深度优先来便利这个图（具体什么是图，可以去搜索一下图论中关于图的定义）的具体过程是，假设从左边的顶点开始，沿着当前定点的边，走到未访问过的顶点；当没有未访问过的顶点时，返回到上一个点，继续试探别的点（沿着某一条分支走到底，然后回朔，再沿着另一条进行同样的操作）。所有的顶点都走过了或者是提前符合我们的条件，遍历结束。 广度优先的思想是：首先以一个未被访问过的顶点作为起始顶点，访问其所有相邻的顶点，然后对每个相邻的定点，再访问他们相邻的未被访问过的点定点，直到所有的点都被访问或者提前符合我们的条件，遍历结束。","text":"深度和广度是什么 为什么叫做深度与广度优先呢，其实是针对图的遍历而言的，请看 使用深度优先来便利这个图（具体什么是图，可以去搜索一下图论中关于图的定义）的具体过程是，假设从左边的顶点开始，沿着当前定点的边，走到未访问过的顶点；当没有未访问过的顶点时，返回到上一个点，继续试探别的点（沿着某一条分支走到底，然后回朔，再沿着另一条进行同样的操作）。所有的顶点都走过了或者是提前符合我们的条件，遍历结束。 广度优先的思想是：首先以一个未被访问过的顶点作为起始顶点，访问其所有相邻的顶点，然后对每个相邻的定点，再访问他们相邻的未被访问过的点定点，直到所有的点都被访问或者提前符合我们的条件，遍历结束。 使用广度或者深度来遍历图，都会得到这个图的生成树，这个以后会提到😤。 城市地图 假期，小朋友A想去小朋友B家玩，怎么去呢？小朋友A用百度地图搜索除了到B家的最短路径。上边是城市的地图。 数据是这样给出的： 1234567895 81 2 2 1 5 102 3 3 2 5 73 1 43 4 4 4 5 5 5 3 3 第一行表示有5个城市，8条公路，接下来8行，每行都是类似于a，b，c这样的数据，表示有一条路可以从城市a到b（单向），并且路程有c公里。即a，b，c仅仅表示有一条路可以从城市a到城市b。小朋友A家在1号城市，小朋友B家在5号城市。请求出最短路径。 已知，有5个城市，8条公路，我们用一个5*5的二维数组来存储这些信息。 123456+ 1 - 2 - 3 - 4 - 51 0 2 -1 -1 10 2 -1 0 3 -1 73 4 -1 0 4 -14 -1 -1 -1 0 5 5 -1 -1 3 -1 0 0表示自己到自己的距离，-1表示不可以到达，比如说 map[2][1] = -1意味着从城市2不能到达城市1，接下来我们就要寻找最短的距离了。我们一个一个找，你会发现之前写过这样的代码，对，在算法第三课种，迷宫就是这么想的。一个深度查找就可以知道了（我们来动手写一下代码）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;int min = 9999999;int book[101];int map[11][11];int n; // 多少个城市int m; // 多少条路int des;void dfs(int currentCity, int distance) &#123; // 如果当前走过的路，已经大于之前走过的路，直接返回，不需要继续了 if (distance &gt; min) &#123; return; &#125; if (currentCity == n) &#123; if (distance &lt; min) &#123; min = distance; &#125; return; &#125; for (int i = 1; i &lt;= n; i ++) &#123; if (map[currentCity][i] != -1 &amp;&amp; book[i] == 0) &#123; book[i] = 1; dfs(i, distance + map[currentCity][i]); book[i] = 0; &#125; &#125; return;&#125;int main(int argc, const char * argv[]) &#123; // 初始化地图 scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) &#123; for (int j = 1; j &lt;= n; j ++) &#123; if ( i == j ) &#123; map[i][j] = 0; &#125; else &#123; map[i][j] = -1; &#125; &#125; &#125; // 初始化道路 int a, b, c; for (int i = 1; i &lt;= m; i ++) &#123; scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); map[a][b] = c; &#125; book[1] = 1; // 从城市1出发 dfs(1, 0); printf(\"%d\", min);&#125; 上边的地图我们发现城市之间只是单向的通道，如果改为双向的呢？大家把上边的地图修改一下看看。还有，发现了么，我们写了好多代码都离不开book这个数组，嘿嘿。广度优先和深度优先该什么时候使用呢（所有周边的权值相同的时候使用广度，思考为什么）。 第四课其实是第三课的练习与只是的完善，但并不是，接下来我们来探讨最短路径问题： 最短路径Floyd-Warshall 上图中，有4个城市，8条线路，公路上的数字表示这条公路的长短，请注意这些公路是单向的，我们现在需要求任意两个城市之间的最短路程，也就是求2个点之间的最短路径，这个问题也被称为多源最短路径问题。 现在需要一个数据结构来存储图的信息，依旧，跟以前一样，我们可以选择一个4*4的矩阵，比如1号城市到2号城市的距离为2，则设map[1][2]=2，2号城市无法到达4号城市，则设置距离为无穷大（之前我们用的是-1表示不可以到达），并约定一个城市自己到自己的路程为0。具体如下： 12345+ 1 2 3 41 0 2 6 42 / 0 3 /3 7 / 0 14 5 / 12 0 通过之前的学习，我们可以使用深度或者广度优先搜索来寻找，即对每两个点都进行一次深度或者广度优先搜索，就可以求得结果，可是还有没有别的办法呢？ 根据以往的经验，我们思考下，如果要让任意两点之间的距离变短，只能引入第三个点K，并通过这个点中转，A → K → B，才可能缩短A到B的路程，那么这个中转点是1~n种的哪个点呢？而且有的时候不仅仅通过1个点中转，甚至通过2个点中转可以得到最短的路程（在图上，大家自己比划一下）。将这个问题一般化：当任意两点之间不允许经过第三个点时，这些城市之间的最短路程就是初始路程，假设，目前只允许经过1号顶点，求任意两点（i，j）之间的最短距离，该如何求呢？只需判断 1map[i][1] + map[1][j] &lt; map[i][j] 这样，map[i][1]表示i点到1点的路程，map[1][j]表示从1号顶点到j点的路程。这样，i，j是不定的，我们要确认所有的2点之间的最短路程，所以i，j都是1~n循环： 1234567for (int i = 1; i &lt;= 4; i ++) &#123; for (int j = 1; j &lt;=4; j ++) &#123; if (map[i][1] + map[1][j] &lt; map[i][j]) &#123; map[i][j] = map[i][1] + map[1][j]; &#125; &#125;&#125; 这样我们简单的算出了，只中转1号顶点，任意两点间的最短距离。同理，经过别的顶点都是一样的，所以，经过所有的顶点中转： 123456789for (int k = 0; k &lt;= 4; k ++) &#123; for (int i = 1; i &lt;= 4; i ++) &#123; for (int j = 1; j &lt;=4; j ++) &#123; if (map[i][k] + map[k][j] &lt; map[i][j]) &#123; map[i][j] = map[i][k] + map[k][j]; &#125; &#125; &#125; &#125; 对你没看错，就是这样么简单，这种思想也被称为动态规划。核心代码只有5行，不过，它的时间复杂度为： 1O(N^3) 但是要注意，这种算法不能解决包含负权回路的图，自行科普一下什么叫做负权环。 算了，因为带有负权环的图没有最短路径，查了之后思考一下。 如果对时间要求不高，使用这种方法可谓最容易了，当然还有更快的算法： Dijkstra上节我们说的是多源最短路径问题，任意的两个点，这次呢，我们来解决确定一个顶点，到其他各个顶点的最短路径，也称为单源最短路径问题，先来看一下图： 如上图，我们求一下，从1号定点，到达其余各个点的最短路程，与之前的算法一样，我们使用二维数组来表示这些点之间的路程： 1234567+ 1 2 3 4 5 61 0 1 12 / / /2 / 0 9 3 / /3 / / 0 / 5 /4 / / 4 0 13 155 / / / / 0 46 / / / / / 0 还需使用一个一维数组来存储1号顶点到其余点的路程，并将此时数组种的值描述为估计值： 12顶点: 1 2 3 4 5 6距离: 0 1 12 / / / 既然是求1号顶点到其余各个点的值，那就先找一个离1号点最近的点，也就是2号点，这个时候，2号点的值从估计值变为确定值，即1号顶点到2号顶点的最短路径就是当前数组中的值。 为什么？因为1号点的周围，除了2号点，别的点都要远，所以选择2号点作为接下来的中转点没问题吧？ 接着想，看上图，通过2号点，我们可以到达3号和4号，所以接下来我们要想的是，2到3能否让1到3更小。上边的数组我们用distance命名，即比较，distance[3]和distance[2]+map[2][3]的大小。distance[2]大家还记吧，表示点1到点2的路程，map[2][3]表示点2到点3的路程。我们发现，distance[3] &gt; distance[2]+map[2][3]，所以把distance[3]的值更新为10，这个过程，有个专业的术语，叫做松弛，1号到3号点的路程，通过2号到3号边松弛成功，这就是Dijkstra算法的主要思想：通过边来松弛1号点到其余点的路程。同理，对2号到4号点的距离可以松弛为distance[2]+map[2][4] ，所以把distance[4]改为4。2号所有的边都松弛结束后： 12顶点: 1 2 3 4 5 6距离: 0 1 10 4 / / 接下来在剩下的3、4、5、6点中，选出距离1号最近的点，为4号点，然后对4号点的所有出边进行松弛（4到3，4到5，4到6）（为什么？我们确定了点1，点2，所以在松弛点4周边的时候，前面的线路就是1-2-4 然后到3，到5，到6）： 12顶点: 1 2 3 4 5 6距离: 0 1 8 4 17 19 接着在余下的3、5、6中选择最近的点3进行松弛（3到5）（点1，点2，点4，点3确定，所以接下来是1-2-4-3-5）： 12顶点: 1 2 3 4 5 6距离: 0 1 8 4 13 19 继续在余下的5、6点种对点5进行松弛（1-2-4-3-5）（5到6）： 12顶点: 1 2 3 4 5 6距离: 0 1 8 4 13 17 现在，我们已经确定了所有的距离，简单不。我们用代码实现上述的思路： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int main(int argc, const char * argv[]) &#123; int map[10][10], distance[10], book[10]; int UNACCESS_DISTANCE = 999999; int n, m; // N表示点的个数，M表示边的条数 scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) &#123; for (int j = 1; j &lt;= n; j ++) &#123; if ( i == j ) &#123; map[i][j] = 0; &#125; else &#123; map[i][j] = UNACCESS_DISTANCE; &#125; &#125; &#125; // 读入边 for (int i = 1; i &lt;= m; i ++) &#123; int tx, ty, td; scanf(\"%d %d %d\", &amp;tx, &amp;ty, &amp;td); map[tx][ty] = td; &#125; // 初始化distance数组，这里是1号顶点到其余点的初始路程 for (int i = 1; i &lt;= n; i ++) &#123; distance[i] = map[1][i]; &#125; // 标记数组初始化 for (int i = 1; i &lt;= n; i ++) &#123; book[i] = 0; // 全部未定值 &#125; book[1] = 1; // 我们通过把book置为1表示该点已经确定值。 // 核心算法 int min = UNACCESS_DISTANCE; int fixedValue = 0; // 定值 for (int i = 1; i &lt;= n - 1; i ++) &#123; // 点1定了，所以少循环一次就够了 // 找到距离1号的最近的点 for (int j = 1; j &lt;= n; j ++) &#123; if (book[j] == 0 &amp;&amp; distance[j] &lt; min) &#123; min = distance[j]; fixedValue = j; &#125; &#125; book[fixedValue] = 1; min = UNACCESS_DISTANCE; // 归位寻找最小值 for (int k = 1; k &lt;= n; k ++) &#123; if ( map[fixedValue][k] &lt; UNACCESS_DISTANCE ) &#123; // 是可以连通的 if ( distance[fixedValue] + map[fixedValue][k] &lt; distance[k] ) &#123; // 按照思路比较 distance[k] = distance[fixedValue] + map[fixedValue][k]; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i ++) &#123; printf(\"到%d点%d \", i, distance[i]); &#125;&#125; 通过上述的代码，我们可以看出，时间复杂度为： 1O(N^2) 这里其实还可以优化，我们以后也会提到。另外，对于边数少于N^2的稀疏图来说M远远小于N*N的图，M相对大的图，叫做稠密图，我们可以使用邻接表（等下会说）来代替邻接矩阵，使得整个时间复杂度优化到： 1O(M+N)logN 最快的情况，就是M=N^2，这个时候，(M+N)logN要比N*N还大。但是大多数情况下，边不会有那么多。接下来我们主要讲解邻接表，先看数据 1234564 51 4 94 3 81 2 52 4 61 3 7 第一行表示顶点个数与边数，接下来的每行，表示x到y的路程为z。现在要使用邻接表来存储这个图，先给出代码如下： 1234567891011121314151617181920212223int main(int argc, const char * argv[]) &#123; int n, m; // 点、边 // u、v、w数组的大小，要根据实际情况来设置，一般要比m大1 int u[6], v[6], w[6]; // first和next数组要比n大1 int first[5], next[5]; scanf(\"%d %d\", &amp;n, &amp;m); // 初始化first数组1~n的值为-1，表示1~n顶点暂时没有边 for (int i = 1; i &lt;= n; i ++) &#123; first[i] = -1; &#125; for (int i = 1; i &lt;= m; i ++) &#123; scanf(\"%d %d %d\", &amp;u[i], &amp;v[i], &amp;w[i]); // 读入每条边 // 重点操作 next[i] = first[u[i]]; first[u[i]] = i; &#125;&#125; 这里展示的是使用数组来实现邻接表，首先我们为每一条边进行1~m的编号，用u、v、w三个数组来记录每条边的信息，即第i条边用u[i],v[i]-&gt;w[i]来表示，first数组的1-&gt;n分别用来存储1-&gt;n号点的第一条边的编号，即first[u[i]]保存点u[i]的第一条边的编号，next[i]存储编号为i的边的下一条边的编号。 接下来如何遍每一条边呢？我们之前说过，其实first数组存着每个顶点i的第一条边，比如1号点的第一条边是编号为5的边（1，3，7），2号点的第一条边是编号为4的边（2，4，6），3号点没有出向边，4号点的第一条边是编号为2的边（4，3，8）。那么如何遍历1号点的每一条边呢？在找到1号点的第一条边后，剩下的都可以在next数组中依次找到： 12345int k = first[1];while (k != -1) &#123; printf(\"%d %d %d\\n\", u[k], v[k], w[k]); k = next[k];&#125; 输出了 1231 3 71 2 51 4 9 细心的人会发现，此时遍历某个点的边的时候的遍历顺序，正好与读入的时候顺序相反，因为在每个点插入边的时候，都是直接插入表的首部而不是尾部，不过这并不会产生任何问题，这恰好是奇妙之处。遍历每个定点的边： 1234567for (int i = 1; i &lt;= n; i ++) &#123; int k = first[i]; while (k != -1) &#123; printf(\"%d %d %d\\n\", u[k], v[k], w[k]); k = next[k]; &#125;&#125; 可以发现，使用邻接表存储图的时候，时间空间复杂度是 1O(M) 遍历一条边的时间复杂度也是同样的，如果一张图是稀疏图的话，选用邻接表来存储要比使用矩阵好的多。 Dijkstra算法虽然不错，但是依旧无法解决负权边（哈哈，就是有边的路程是负数）的图，所以我们引出一个无论是思想上还是代码实现上都堪称完美的最短路径算法： Bellman-Ford算法极其简单，核心的代码只有4行，我们先来看看它的样子： 1234567for (int k = 1; k &lt;= n - 1; k ++) &#123; for (int i = 1; i &lt;= m; i ++) &#123; if (distance[v[i]] &gt; distance[u[i]] + w[i]) &#123; distance[v[i]] = distance[u[i]] + w[i]; &#125; &#125;&#125; 上边的代码中，外层循环一共循环了n-1次，内部循环循环了M次，即枚举每一条边，distance数组的作用与Dijkstra算法一样，记录源点到各个点的最短路径，u、v、w三个数组用来记录边的信息。 123if (distance[v[i]] &gt; distance[u[i]] + w[i]) &#123; distance[v[i]] = distance[u[i]] + w[i];&#125; 上面这行代码的意思是，看看能否通过u[i]-&gt;v[i]（值为w[i]）这条边，使得1号点到v[i]号顶点的距离变短。即1号点到u[i]号点的距离加上u[i]-&gt;v[i]这条边的值，是否会比原先1号点到v[i]号点的距离dis[v[i]]要小，这一点与松弛的操作是一样的，现在我们要把所有的边都松弛一遍： 12345for (int i = 1; i &lt;= m; i ++) &#123; if (distance[v[i]] &gt; distance[u[i]] + w[i]) &#123; distance[v[i]] = distance[u[i]] + w[i]; &#125;&#125; 把每条边松弛一遍后，会有什么效果呢？我们来看个具体的例子，求下图1号点到其余所有点的最短路径。 我们还是使用一个distance数组来存储1号点到所有点的距离： 12position: 1 2 3 4 5distance: 0 / / / / 我们开始对每一次输入的边进行松弛： 首先输入了2，3，2，所以就是对2-&gt;3这条边松弛，即判断distance[3]&gt;distance[2]+2?此时，2与3都是未知，所以无穷大与无穷大+2不可以做比较，所以2-&gt;3松弛失败，接着对第二个输入1，2，-3进行松弛，即判断distance[2]&gt;distance[1]+(-3)，distance[1]是0，所以distance[2]为无穷大，大于-3，所遇distance[2] = -3，依次对每组输入的数字进行松弛，得到 12position: 1 2 3 4 5distance: 0 -3 / / 5 我们发现，对每条边松弛之后，distance[2]与distance[5]的值变小。即1号点到2号与5号的路程都变小了。接下来我们对所有的边进行下一轮松弛： 过程与上一轮一样（过程依旧是从第一组输入的边开始，大家脑补），结果为： 12position: 1 2 3 4 5distance: 0 -3 -1 2 5 在这一轮松弛后，我们发现，现在通过2 3 2这条边，可以使1号点到3号点的具体变短。实际上，第一轮松弛过后，得到的是从1号点只能经过一条边到达其余各点的最短路径长度。第二轮松弛过后，得到的是从1号点最多经过2条边到达各个点的最短路径长度，当然K轮就是K条边。现在有一个新的问题了，K是多少？多少轮可以让我们求得答案呢？ 只需要进行n-1轮就够了，因为在一个含有n个定点的图中，任意两点之间的最短路径最多包含n-1边。有人要问了，不是还有回路么？答案是，不可能，最短路径肯定是一个不包含回路的路径，假设有负数路程，那么每走一次就会减少一次，很明显不可能的。接下来，我们完成上边的后2轮松弛，第三轮过后： 12position: 1 2 3 4 5distance: 0 -3 -1 2 4 第四轮后： 12position: 1 2 3 4 5distance: 0 -3 -1 2 4 最后，说白了，这个算法就是，对所有输入的边，进行最多n-1次松弛，但是我们会发现，我们在想的时候，一些已经确定的点，我们还是想了一下对他松弛的过程，是不是有些浪费呢？先来看完整的代码： 1234567891011121314151617181920212223242526272829303132int main(int argc, const char * argv[]) &#123; int n, m; // 点、边 int distance[10]; // 用来存放源距各个点的路程 int u[10], v[10], w[10]; // u -&gt; v 的路程是 w int UNACCESS_VALUE = 999999; // 模拟正无穷大 scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i ++) &#123; scanf(\"%d %d %d\", &amp;u[i], &amp;v[i], &amp;w[i]); &#125; // 初始化路程数组 for (int i = 1; i &lt;= n; i ++) &#123; distance[i] = UNACCESS_VALUE; &#125; distance[1] = 0; // 核心算法 for (int i = 1; i &lt;= n - 1; i ++) &#123; for (int j = 1; j &lt;= m; j ++) &#123; // 按照刚刚的思想去写代码：源到目的地的距离 &gt; 源到起点的距离 + 起点到目的地的距离 if ( distance[v[j]] &gt; distance[u[j]] + w[j] ) &#123; distance[v[j]] = distance[u[j]] + w[j]; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i ++) &#123; printf(\"%d \", distance[i]); &#125;&#125; 此外，这个算法还可以判断一个图是否有负权回路，如果在n-1轮后，依然存在 123if ( distance[v[j]] &gt; distance[u[j]] + w[j] ) &#123; distance[v[j]] = distance[u[j]] + w[j];&#125; 意味着，n-1轮松弛后，还可以继续松弛，说明有负权回路。这个算法的时间复杂度为： 1O(M*N) 这个时间复杂度貌似高于Dijkstra算法，我们还可以继续对它进行优化。在实际操作中（上边的例子也是），其实不需要n-1次就能算出最短路径，我们也说过，最多使用n-1次，所以我们可以添加一个变量，用来标记数组distance是否在本轮松弛中发生了变化，如果没有发生变化就提前跳出循环。 1234567891011121314151617int check = 0; for (int i = 1; i &lt;= n - 1; i ++) &#123; check = 0; // 标记本轮松弛是否会发生 for (int j = 1; j &lt;= m; j ++) &#123; if ( distance[v[j]] &gt; distance[u[j]] + w[j] ) &#123; distance[v[j]] = distance[u[j]] + w[j]; check = 1; &#125; &#125; if ( check == 0 ) &#123; break; &#125;&#125; 刚才我们也提到过，其实一些已经松弛成功的边还在被无用的松弛，所以我们继续优化，每次只对最短路径估计值发生了变化的点的所有出边进行松弛，我们称为Bellman-Ford的队列优化。 每次选取队首点u，对点u的所有出边进行松弛操作，例如有一条u到v的边，如果通过n到v这条边使源点到点v的路程变短，而且点v不在当前的队列中，就将点v放入队尾。需要注意的是，同一个点同时在队列中出现多次是毫无意义的，所以我们需要一个数组来进行去重。在对点u的所有出边松弛完毕后，将u出队。反复操作至队列为空。我们用代码来讲解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172int main(int argc, const char * argv[]) &#123; // 还记得之前讲到的邻接表么？这里我们使用邻接表来存储数据 int n, m; // first 比n大1 next比m大1 int first[6], next[8]; int u[8], v[8], w[8]; int distance[8]; int book[6]; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) &#123; first[i] = -1; // 初始化first数组，都暂时无边 book[i] = 0; // 初始化标记数组，都不在队列中 &#125; for (int i = 1; i &lt;= m; i ++) &#123; scanf(\"%d %d %d\", &amp;u[i], &amp;v[i], &amp;w[i]); // 建立邻接表的关联 next[i] = first[u[i]]; first[u[i]] = i; &#125; // 初始化初始路程 for (int i = 1; i &lt;= n; i ++) &#123; distance[i] = 999999; &#125; distance[1] = 0; // 创建队列 int queue[101] = &#123;0&#125;, head = 1, tail = 1; // 将1号顶点入队 queue[tail] = 1; tail ++; // 标记这个点已经在队列中 book[1] = 1; int k = 0; while (head &lt; tail) &#123; // 将n-1的循环改为队列循环 // 邻接表的遍历方式 k = first[queue[head]]; while (k != -1) &#123; // 是否可以松弛 if ( distance[v[k]] &gt; distance[u[k]] + w[k] ) &#123; distance[v[k]] = distance[u[k]] + w[k]; // 松弛成功，当前成功松弛的点是 v[k]. // 入队，检查标记 if (book[v[k]] == 0) &#123; queue[tail] = v[k]; tail ++; book[v[k]] = 1; &#125; &#125; k = next[k]; &#125; // 对首已经松弛结束了，置为0，因为本次可能不是松弛的最终结果 book[queue[head]] = 0; head ++; &#125; for (int i = 1; i &lt;= n; i ++) &#123; printf(\"%d \", distance[i]); &#125; return 0;&#125; 检查一个数字是否在队列中也可以遍历，但是时间复杂度是O(N)，但是使用book就变成了O(1)。并且，如果一个点，进入到队列的次数超出n次，这图也存在负权回路。 至此，最短路径算法告一段落了，以后有优化我们再提起。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wilddylan.github.io/tags/算法/"}],"keywords":[]},{"title":"算法第三课","slug":"算法第三课","date":"2016-10-15T08:47:57.000Z","updated":"2017-02-04T09:02:31.000Z","comments":true,"path":"2016/10/15/算法第三课/","link":"","permalink":"https://wilddylan.github.io/2016/10/15/算法第三课/","excerpt":"枚举枚举算法又被称为穷举算法，字面看很暴力，先来看一个例子： 1口口口+口口口=口口口？ 3位数与3位数相加等于一个3位数（使用1~9，不能重复），用穷举来说，就是列举所有的可能。这样写for循环的话，我们要写9个循环嵌套（9个数字，每个都要循环），然后通过一大串的判断语句之后，才能得到我们的答案（答案还需要除以2，173+286与286+173是一样的），有兴趣或者有时间的同学可以用穷举的思想试一下。","text":"枚举枚举算法又被称为穷举算法，字面看很暴力，先来看一个例子： 1口口口+口口口=口口口？ 3位数与3位数相加等于一个3位数（使用1~9，不能重复），用穷举来说，就是列举所有的可能。这样写for循环的话，我们要写9个循环嵌套（9个数字，每个都要循环），然后通过一大串的判断语句之后，才能得到我们的答案（答案还需要除以2，173+286与286+173是一样的），有兴趣或者有时间的同学可以用穷举的思想试一下。 接下来，我们再看另外一个例子：123，3个数字全排列，可能是123，132，213，231，321，312；那么1234全排列呢？123456789全排列呢？1~n的全排列呢？使用穷举，我们的想法是： 1234567891011int main(int argc, const char * argv[]) &#123; for (int i = 1; i &lt;=3; i ++) &#123; for (int j = 1; j &lt;=3; j ++) &#123; for (int k = 1; k &lt;= 3; k++) &#123; if ( i != k &amp;&amp; i != j &amp;&amp; j != k ) &#123; printf(\"%d%d%d\\n\", i, j, k); &#125; &#125; &#125; &#125;&#125; 那1234，就是4个for，1~9就是9个for…. 显然，比较傻，我们接着往下想（先剧透一下，本文其实不叫枚举，叫深度搜索）：如果现在有3张扑克牌，3个盒子，把牌放入盒子，其实我们发现，每次的操作都是相同的，只不过是把手上剩余的排放入当前的盒子中。所以我们大致的伪代码描述一下这样的思维： 12345678void nextStep(int step) &#123; for (int i = 0; i &lt;= n; i ++) &#123; if 手上有牌 &#123; 放入当前的step nextStep(step + 1) &#125; &#125;&#125; 按照这样的思维，我们来解决上边的问题：首先准备book数组用来标记所有的扑克牌是否已经使用，然后使用numbox表示盒子， 1234567891011121314151617181920212223242526272829303132int numbox[10], book[10], count; // 我们假定，输入的范围就是1~9, numbox为盒子, book标记这张扑克还在不在手上void stepTo(int step);int main(int argc, const char * argv[]) &#123; scanf(\"%d\", &amp;count); stepTo(1); // 从第一步开始 return 0;&#125;void stepTo(int step) &#123; // Step表示当前是第几个小盒子的面前，或者说第几步 if ( step == count + 1 ) &#123; // count为盒子数，如果step==count+1意味着count个盒子全部放好了扑克 for (int i = 1; i &lt;= count; i ++) &#123; printf(\"%d\", numbox[i]); // 依次打印盒子中的数字 &#125; printf(\"\\n\"); return ; // 结束本次流程 &#125; // 此时，我们需要往盒子中放入扑克牌 for (int i = 1; i &lt;= count; i ++) &#123; // 循环扑克牌 // 判断扑克牌是否在手中（book数组标记位是否为0, 1表示已经用了） if ( book[i] == 0 ) &#123; numbox[step] = i; // 当前的盒子放入该扑克牌 book[i] = 1; // 标记为使用 stepTo(step + 1); // 下一步 book[i] = 0; // 将试过的扑克牌置为未使用 &#125; &#125; return;&#125; 其中的核心代码，其实是： 12345678for (int i = 1; i &lt;= count; i ++) &#123; // 循环扑克牌 if ( book[i] == 0 ) &#123; numbox[step] = i; // 当前的盒子放入该扑克牌 book[i] = 1; // 标记为使用 stepTo(step + 1); // 下一步 book[i] = 0; // 将试过的扑克牌置为未使用 &#125;&#125; 基本类似于我们刚才的想法，现在我们来逐行解释一下： 从1开始，循环每张扑克牌 book数组是我们用来标记扑克牌是否使用的，这里 ==0意味这这张牌没有使用 将这张牌，放入当前的盒子 本次循环中，将这张牌标记为已经使用 在这张牌已经使用的情况下，进行下一步的寻找 将本次循环使用的牌标记为0，因为后边还需要使用这张牌。 3，4，5，6行代码，可能大家理解起来会很吃力，一定要慢慢的想： 当前的扑克，已经放入了当前的盒子，那么在寻找下一个盒子放什么扑克之前，当前使用了的扑克需要 book[i] = 1。调用了下一步之后，由于这张牌在以后的情况中还会被继续使用，所以我们把book位置为未使用(这里因为我们是先进入下一步，然后置扑克为未使用，所以对第5行的下一步寻找没有影响，但是如果不置为1，下次循环这张牌就不能使用了。这是一个链式的思维，一点点在调用下一步的时候减少扑克，递归的思维就不说了哈，如果没想明白，希望大家使用笔模拟一下for的数据变动) 以上的代码，被称为深度搜索（Depth First Search，DFS），关键的思想就是当下该如何做，以后的做法和当下是一样的。深度搜索的基本模型是： 12345void dfs(int step) &#123; 判断边界 尝试每一种可能 继续下一步&#125; 现在我们利用这种思维来解决开篇那个使用穷举需要9个循环嵌套的问题：首先是9个盒子，然后9张牌： 1234567891011121314151617181920212223242526272829303132int book[10], numbox[10];void dfs(int box) &#123; if ( box == 10 ) &#123; // box == 9 + 1, 意味着走过了9个放数字的步骤 // 口口口 + 口口口 = 口口口 int numberA = numbox[1] * 100 + numbox[2] * 10 + numbox[3]; int numberB = numbox[4] * 100 + numbox[5] * 10 + numbox[6]; int results = numbox[7] * 100 + numbox[8] * 10 + numbox[9]; if ( numberA + numberB == results ) &#123; printf(\"%d%d%d + %d%d%d = %d%d%d\", numbox[1], numbox[2], numbox[3], numbox[4], numbox[5], numbox[6], numbox[7], numbox[8], numbox[9]); printf(\"\\n\"); &#125; return; // 结束本次流程 &#125; for (int i = 1; i &lt;= 9; i ++) &#123;// 循环数字 if ( book[i] == 0 ) &#123; // 未使用的数字 numbox[box] = i; book[i] = 1; dfs(box + 1); // 下一步 book[i] = 0; &#125; &#125; return;&#125;int main(int argc, const char * argv[]) &#123; dfs(1); // 从第一个盒子开始放入 return 0;&#125; 是不是相当的简单，接下来的去重，就大家自己做吧，我们接着往下看：最短路径问题（其实也不算，最短路径后边有自己的算法…，这里起名阻塞了）。 我们来看迷宫问题，假如有一个迷宫，迷宫中存在障碍物，我们如何能从起点找到到达目标点的最短步数呢？解决这个问题，首先我们要用一个二维数组来表示迷宫，默认全为0，迷宫中的障碍物用1表示，然后开始写代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485int book[51][51]; // 标记走过的点int minStep = 9999999;struct Maze &#123; int map[51][51]; int n; // 行 int m; // 列&#125;;struct StartPoint &#123; int x; int y;&#125;;struct EndPoint &#123; int x; int y;&#125;;struct Maze maze;struct StartPoint sPoint;struct EndPoint ePoint;void dfs(int x, int y, int step);int main(int argc, const char * argv[]) &#123; scanf(\"%d %d\", &amp;maze.n, &amp;maze.m); for (int i = 1; i &lt;=maze.n ; i ++) &#123; for (int j = 1; j &lt;= maze.m; j ++) &#123; scanf(\"%d\", &amp;maze.map[i][j]); &#125; &#125; sPoint.x = 1, sPoint.y = 1; // 设置起点 book[sPoint.x][sPoint.y] = 1; // 防止后边重复走起点 printf(\"输入结束地址: \"); scanf(\"%d %d\", &amp;ePoint.x, &amp;ePoint.y); dfs(1, 1, 0); // 初始步是0 printf(\"%d\\n\", minStep); return 0;&#125;void dfs(int x, int y, int step) &#123; // 4个方向，右、下、左、上 int next[4][2] = &#123; &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125; &#125;; int tx, ty; if ( x == ePoint.x &amp;&amp; y == ePoint.y ) &#123; // 到了目标点 if (step &lt; minStep) &#123; minStep = step; // 更新最小的步数 &#125; return; &#125; // 思考下一步可能的位置点 for (int i = 0; i &lt; 4; i ++) &#123; // 4中方向可能走 tx = x + next[i][0]; ty = y + next[i][1]; // 判断是否越界 if ( tx &lt; 1 || tx &gt; maze.n || ty &lt; 1 || ty &gt; maze.m ) &#123; continue; &#125; // 判断是否为障碍物或者是已经走过的点 if ( maze.map[tx][ty] == 0 &amp;&amp; book[tx][ty] == 0 ) &#123; book[tx][ty] = 1; dfs(tx, ty, step + 1); book[tx][ty] = 0; &#125; &#125; return;&#125; 简单的，解决了迷宫最短路径问题。但是仅仅是这样么，并不是，接下来介绍一种叫做广度优先搜索的方法，简称BFS（Breadth First Search）。用言语描述，2个方法的区别就是，深度搜索是每次都走到极致，然后在下一次，而广度则是每次都往外同时扩张一层：我们继续使用迷宫的例子去寻找到达目的地的最短距离： 从1，1开始，我们可以到达的点是 1，2与2， 1两个点，接下来2，2这个点都可以到达，所以我们依旧需要标记位来标记点已经被走过避免重复，因为步数是一样的，所以无关紧要了（2个点一步都可以到达另一个点，岂不是步数一样么）。 12345678迷宫：0→0 1 0↓ ↓0 0→0 0 ↓ ↓0 0 1 0 0 1 0 0 0 0 0 1 使用这种扩散的思想，我们很容易想到，既然是一层一层，而且有顺序链式的关系，我们可以使用队列来完成（队列忘了可以去看算法二中的代码），我们来写代码研究一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;stdio.h&gt;struct node &#123; int x; // 横坐标 int y; // 纵坐标 int prev; // 如果需要输出路径的话，可以用来标记父节点在队列中的编号 int step; // 步数&#125;;int main(int argc, const char * argv[]) &#123; int map[51][51] = &#123;0&#125;; // 地图 int book[51][51] = &#123;0&#125;;// 标记 int next[4][2] = &#123; &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125; &#125;; // 4个方向，右、下、左、上 struct node queue[2501]; // 50 * 50的地图范围 int head, tail; // 队列的使用方式 int n, m; // 分别表示地图的行列 int ex, ey; // 目标点 // 初始化地图与目标点 scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) &#123; for (int j = 1; j &lt;= m; j ++) &#123; scanf(\"%d\", &amp;map[i][j]); &#125; &#125; printf(\"输入目标点: \"); scanf(\"%d %d\", &amp;ex, &amp;ey); // 初始化队列 head = 1; tail = 1; // 插入起点 queue[tail].x = 1; queue[tail].y = 1; queue[tail].prev = 0; queue[tail].step = 0; tail ++; // 标记起点1, 1为走过的点 book[1][1] = 1; int flag = 0; // 标记是否到达目标点, 0表示没有到达，1表示到达 int tx, ty; // 临时变量 while (head &lt; tail) &#123; // 对队列进行遍历操作 // 4个方向的操作 for (int i = 0; i &lt; 4; i ++) &#123; tx = queue[head].x + next[i][0]; ty = queue[head].y + next[i][1]; // 是否越界 if ( tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; m ) &#123; continue; &#125; // 是否障碍物或者走过的点 if ( map[tx][ty] == 0 &amp;&amp; book[tx][ty] == 0 ) &#123; book[tx][ty] = 1; // 插入新的点到队列中, 这里由于我们是扩展，所以用过的点就不会在用了，也就不需要把标记位清0 queue[tail].x = tx; queue[tail].y = ty; queue[tail].prev = head; // 每一个点都是从head扩展出来的，所以上一个就是head的位置 queue[tail].step = queue[head].step + 1;// 步数等于head的步数加1 tail ++; &#125; if ( tx == ex &amp;&amp; ty == ey ) &#123; // 如果是目标点，标记一下，结束 flag = 1; break; &#125; &#125; if (flag == 1) &#123; break; &#125; head ++; // 当前点已经寻找完了，继续从头部扩散 &#125; printf(\"Step: %d\", queue[tail - 1].step); int prev = queue[tail - 1].prev; while (prev) &#123; // prev node struct node prevNode = queue[prev]; printf(\"&#123;%d, %d&#125; \", prevNode.x, prevNode.y); prev = prevNode.prev; &#125;&#125; 我们大致的模拟一下，从(1，1)点开始，先尝试往右找到了(1，2)，此时的队列： 12345head == tail == 1x: 1y: 1step: 0prev: 0 尝试走到1，2： 12345678910tx = queue[head].x;ty = queue[head].y + 1;// 判断越界、标记省略了 ...book[tx][ty] = 1;// 插入新的点到队列中queue[tail].x = tx;queue[tail].y = ty;queue[tail].prev = head;queue[tail].step = queue[head].step + 1;tail ++; 此时的队列是： 12345head == 1, tail == 2x: 1 1y: 1 2step: 0 1prev: 0 1 接着还要尝试往其他方向走，我们发现从（1，1）一步还可以走到（2，1），所以也加入队列 12345head == 1, tail == 3x: 1 1 2y: 1 2 1step: 0 1 1prev: 0 1 1 扩展完（1，1）后，这个点就没用了，所以while中的head++让（1，1）出栈后 12345head == 2, tail == 3x: 1 1 2y: 1 2 1step: 0 1 1prev: 0 1 1 变成了这样，head变为了2，所以接下来要从点（1，2）开始扩展。我们发现（1，2）这个点可以到达（2，2），所以将2，2加入队列中： 12345head == 2, tail == 4x: 1 1 2 2y: 1 2 1 2step: 0 1 1 2prev: 0 1 1 2 这样，（1，2）这个这个点已经扩展结束了，所以移除队列 12345head == 3, tail == 4x: 1 1 2 2 y: 1 2 1 2step: 0 1 1 2prev: 0 1 1 2 现在head变为了（2，1）点，我们继续扩展下去。接下来的模拟过程，大家自己来思考一下。 你们先看，我去拉屎~ 回来了，接着写，拉了屎后轻松了许多，放空了思维，我们来解一道叫做水管工的题，先看个彩色的图： 想必读者都玩过这个游戏。水管分为直的水管，弯的水管，把他们连起来，形成一条通道，如果有通道的话，输出链接的点（使用广度搜索或者深度搜索）。我们先来分析一下组成的部件： 这是水管的全部状态，直管2种状态，弯管4种状态。当然，我们还可以在地图中加入障碍物，用0代替，水管的状态分别用数字指定： 1234567891 = 弯管，右上角2 = 弯管，右下角3 = 弯管，左下角4 = 弯管，左上角分别对应了上图的部件5，部件4，部件6，部件35 = 直管，水平6 = 直管，竖直分别对应了上图的部件2，部件10 = 障碍物 这里我们给出的测试地图是，（1，1）从左边进水，（5，4）从右边出水为成功： 对数组我喜欢从下标1开始叫，这样不用思考 123455 3 5 31 5 3 02 3 5 16 1 1 51 5 5 4 并且我们注意到，每个管子进水的方向也可能是不同的，所以我们规定 12341 = 左边进水2 = 上边进水3 = 右边进水4 = 下边进水 所以我们写实现代码，分别用深度与广度实现（建议自己先想一下再看）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475int map[6][6]; // 地图int book[50][50]; // 标记int n, m; // 行 列int flag; // 结果标记void dfs(int x, int y, int front);int main(int argc, const char * argv[]) &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) &#123; for (int j = 1; j &lt;= m; j ++) &#123; scanf(\"%d\", &amp;map[i][j]); &#125; &#125; dfs(1, 1, 1); if ( flag == 1 ) &#123; printf(\"成功了!\"); &#125; else &#123; printf(\"不能连通\"); &#125;&#125;void dfs(int x, int y, int front) &#123; if (x == n+1 &amp;&amp; y == m &amp;&amp; front == 1) &#123;// 为什么n+1，因为水流出去才行，而不是到了（n，m）结束，动脑子想想，我们的题目要求从右下角的右边出水 flag = 1; return ; &#125; // 越界处理 if ( x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m ) &#123; return; &#125; if ( book[x][y] == 1 ) &#123; return; &#125; book[x][y] = 1; // 当水管是直管的时候 if ( map[x][y] == 5 || map[x][y] == 6 ) &#123; // 左边进水 if ( front == 1 ) &#123; dfs(x + 1, y, 1); &#125; // 上边进水 if ( front == 2 ) &#123; dfs(x, y + 1, 2); &#125; // 右边进水 if ( front == 3 ) &#123; dfs(x - 1, y, 3); &#125; // 下边进水 if ( front == 4 ) &#123; dfs(x, y - 1, 4); &#125; &#125; // 当水管是弯管的时候 if ( map[x][y] &gt;= 1 &amp;&amp; map[x][y] &lt;= 4 ) &#123; if ( front == 1 || front == 3) &#123; dfs(x, y+1, 2); dfs(x, y-1, 4); &#125; // 上、下 if ( front == 2 || front == 4) &#123; dfs(x-1, y, 3); dfs(x+1, y, 1); &#125; &#125; book[x][y] = 0; return;&#125; 然后我们用广度的思想也想一下，首先我们需要一个队列 1234567struct node &#123; int x; int y; int prev; int front;&#125; s[2501];int head, tail; 初始化队列之后，然后我们需要一个while循环： 12345678910// 初始化队列head = 1;tail = 1; // 加入第一个点s[tail].x = 1;s[tail].y = 1;s[tail].prev = 0;s[tail].front = 1; // 左边进水tail ++; 然后 123456789101112131415161718192021222324252627282930while (head &lt; tail) &#123; // 结果判断 // 越界判断 // 是否为已经走过的管道 // 标记 int pipes = map[s[head].x][s[head].y]; if (pipes == 5 || pipes == 6) &#123; struct node tNode; // 加入队列 if (s[head].front == 1) &#123; &#125; else if (s[head].front == 2) &#123; &#125; else if (s[head].front == 3) &#123; &#125; else &#123; &#125; s[tail] = tNode; tail ++; &#125; else &#123; struct node rNode, lNode; // 加入队列 if (s[head].front == 1 || s[head].front == 3) &#123; &#125; else &#123; &#125; s[tail] = rNode; tail ++; s[tail] = lNode; tail ++; &#125; head ++; &#125; 兄弟，自己写吧~ 我也看的头晕。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wilddylan.github.io/tags/算法/"}],"keywords":[]},{"title":"算法第二课","slug":"算法第二课","date":"2016-10-15T06:48:36.000Z","updated":"2017-02-04T09:02:35.000Z","comments":true,"path":"2016/10/15/算法第二课/","link":"","permalink":"https://wilddylan.github.io/2016/10/15/算法第二课/","excerpt":"栈、队列、链表队列先进先出，前面出，后面进。队列分列表头，列表尾。使用2个位置标记量分别代表首、尾，当首=尾，标识队列为空队列。每当入数据，尾++，出数据，头++： 123456789101112131415161718192021222324252627282930struct list &#123; int data[1000]; int head; int tail;&#125;;int main(int argc, const char * argv[]) &#123; struct list list; // 初始化列表首、尾 list.head = 1; list.tail = 1; // 读入数据 for (int i = 1; i &lt;= 5; i ++) &#123; scanf(\"%d\", &amp;list.data[i]); list.tail ++; &#125; printf(\"list headNum: %d, tailNum: %d\\n\", list.data[list.head], list.data[list.tail - 1]); // 模拟出一个值 list.head ++; printf(\"list headNum: %d, tailNum: %d\\n\", list.data[list.head], list.data[list.tail - 1]); // 模拟入一个值 list.data[list.tail] = 10; list.tail ++; printf(\"list headNum: %d, tailNum: %d\\n\", list.data[list.head], list.data[list.tail - 1]);&#125; 栈先进后出，只能后边进，从后边出。栈只有栈顶。使用一个数字标记栈顶，入栈，栈顶++，出栈，栈顶—：","text":"栈、队列、链表队列先进先出，前面出，后面进。队列分列表头，列表尾。使用2个位置标记量分别代表首、尾，当首=尾，标识队列为空队列。每当入数据，尾++，出数据，头++： 123456789101112131415161718192021222324252627282930struct list &#123; int data[1000]; int head; int tail;&#125;;int main(int argc, const char * argv[]) &#123; struct list list; // 初始化列表首、尾 list.head = 1; list.tail = 1; // 读入数据 for (int i = 1; i &lt;= 5; i ++) &#123; scanf(\"%d\", &amp;list.data[i]); list.tail ++; &#125; printf(\"list headNum: %d, tailNum: %d\\n\", list.data[list.head], list.data[list.tail - 1]); // 模拟出一个值 list.head ++; printf(\"list headNum: %d, tailNum: %d\\n\", list.data[list.head], list.data[list.tail - 1]); // 模拟入一个值 list.data[list.tail] = 10; list.tail ++; printf(\"list headNum: %d, tailNum: %d\\n\", list.data[list.head], list.data[list.tail - 1]);&#125; 栈先进后出，只能后边进，从后边出。栈只有栈顶。使用一个数字标记栈顶，入栈，栈顶++，出栈，栈顶—： 1234567891011121314151617181920212223struct stack &#123; int data[10]; int top;&#125;;int main(int argc, const char * argv[]) &#123; struct stack stack; // 没有对象 stack.top = 1; for (int i = 1; i &lt;= 5; i ++) &#123; scanf(\"%d\", &amp;stack.data[i]); stack.top = i; &#125; // 模拟入栈 stack.data[stack.top + 1] = 7; stack.top ++; // 模拟出栈 stack.data[stack.top] = 0; stack.top --;&#125; 至此，大家可以模拟一个打扑克的游戏，俗称列火车，假设2个小朋友每个人都有10张排，你一张我一张放到桌子上，如果我出的这张之前也出过，那么2张牌中间的所有的排都是我赢的，谁先出光谁输（简单分析：2个列表存放2个人的扑克，先进后出，1个栈，从顶往底拿牌，赢的牌插入到每个人列表的后边）。 链表一个链着一个，前一个数中知道下一个链着谁~。基本的形式： 1234struct node &#123; int data; struct node *next;&#125;; 如何建立一个链表呢？首先我们需要一个链表头，就像是火车头一样，然后链着一节一节的车厢。当链表还没有建立的时候，头部暂时置为空。 1struct node *head = NULL; // 初始化; 紧接着，创建第一个结点，并用临时指针p指向这个节点，然后链接到头部： 12345678910111213struct node *head = NULL; // 初始化; struct node *p; p = (struct node *)malloc(sizeof(struct node)); scanf(\"%d\", &amp;p-&gt;data); p-&gt;next = NULL; if (head == NULL) &#123; head = p; &#125; else &#123; head-&gt;next = p; &#125; 所以我们来看完整的链表构建代码（并往其中插入一个数字）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct node &#123; int data; struct node *next;&#125;;int main(int argc, const char * argv[]) &#123; struct node *head = NULL, *p = NULL, *q = NULL, *t = NULL; int count, inputData; printf(\"Enter Number: \"); scanf(\"%d\", &amp;count); for (int i = 1; i &lt;= count; i ++) &#123; scanf(\"%d\", &amp;inputData); p = (struct node *)malloc(sizeof(struct node)); p-&gt;data = inputData; p-&gt;next = NULL; if (head == NULL) &#123; head = p; &#125; else &#123; q-&gt;next = p; &#125; q = p; &#125; t = head; int insert; printf(\"Enter insertNumber: \"); scanf(\"%d\", &amp;insert); while (t != NULL) &#123; if (t-&gt;next == NULL || t-&gt;next-&gt;data &gt; insert) &#123; p = (struct node *)malloc(sizeof(struct node)); p-&gt;data = insert; p-&gt;next = t-&gt;next; t-&gt;next = p; break; &#125; t = t-&gt;next; &#125; t = head; while (t != NULL) &#123; printf(\"%d \", t-&gt;data); t = t-&gt;next; &#125;&#125; 这里有malloc确没有free，留个问题给大家吧。上边所说的是使用指针的方式来制作链表，但是有些人的指针学的并不好，别急，还有另一种方法，我们使用数组来实现，叫做模拟链表。 模拟链表如何实现呢，其实原理很简单，我们使用2个数组，第一个数组存放数据，第二个数组同样的位置上存放着该数据右边数据的位置： 12345&lt;position&gt;: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10data array: 9, 1, 4, 3, 2, 6, 7, 3, 4&lt;position&gt; : 1, 2, 3, 4, 5, 6, 7, 8, 9, 10right array: 2, 3, 4, 5, 6, 7, 8, 9, 0 不难理解，如果这个时候我们希望插入一个6到第三个位置该怎么办呢，只需要将数据6放入data array[10]的位置，然后将right array[3] 的值改为10，并且将right array[10]的值改为4就好了。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wilddylan.github.io/tags/算法/"}],"keywords":[]},{"title":"使用yarn制作npm包","slug":"使用yarn制作npm包","date":"2016-10-14T07:35:43.000Z","updated":"2016-10-14T07:39:34.000Z","comments":true,"path":"2016/10/14/使用yarn制作npm包/","link":"","permalink":"https://wilddylan.github.io/2016/10/14/使用yarn制作npm包/","excerpt":"环境MAC OSX 工具：Yarn （npm install yarnpkg -g），git 创建你的第一个NPM库 在创建你的第一个库之前，你需要了解什么是yarn。 打开终端，首先创建一个git仓库 1git init RockSocket 进入RockSocket文件夹，执行： 1yarn init 这将会询问你以下几个问题：","text":"环境MAC OSX 工具：Yarn （npm install yarnpkg -g），git 创建你的第一个NPM库 在创建你的第一个库之前，你需要了解什么是yarn。 打开终端，首先创建一个git仓库 1git init RockSocket 进入RockSocket文件夹，执行： 1yarn init 这将会询问你以下几个问题： 1234567name (my-new-project):version (1.0.0):description:entry point (index.js):git repository:author:license (MIT): 可以选择回答或者直接按回车使用括号中的默认值（如果你想所有的东西使用默认值的话，可以直接使用npm install --yes，这样会跳过所有的问题）。 package.json现在，在文件夹中应该出现了一个package.json，它大致的样式是这样子的： 123456789101112&#123; \"name\": \"RockSocket\", \"version\": \"1.0.0\", \"description\": \"RockSocket is a npm framework created by `yarn`\", \"main\": \"index.js\", \"repository\": &#123; \"url\": \"https://github.com/wilddylan/rocksocket.git\", \"type\": \"git\" &#125;, \"author\": \"Dylan &lt;3664132@163.com&gt;\", \"license\": \"MIT\"&#125; 这些值的含义分别是（这个文件你可以按照自己的意愿修改）： name：包的唯一标识，如果你这个包可以被别人使用，就必须确认这个名字是唯一的。 version：当前的版本，发布更新必须更改这个值。 description：包的描述，不是必须的值，这个用来帮助用户理解你的库的作用。 main：入口文件 repository：git仓库的地址，以后源代码也是存放在这里的。 author：作者，是有格式的，例如dylan &lt;dylan@china.com&gt; (http://wilddylan.github.io)。 license：规定了大家使用你代码的权限。 Additional fields在package.json中你还有可能希望添加以下的一些字段： 12345678910111213141516171819&#123; \"name\": \"RockSocket\", \"...\": \"...\", \"keywords\": [\"cool\", \"useful\", \"stuff\"], \"homepage\": \"https://RockSocket.com\", \"bugs\": \"https://github.com/you/RockSocket/issues\", \"contributors\": [ \"Your Friend &lt;their-email@example.com&gt; (http://their-website.com)\", \"Another Friend &lt;another-email@example.com&gt; (https://another-website.org)\" ], \"files\": [ \"index.js\", \"lib/*.js\", \"bin/*.js\" ], \"bin\": &#123; \"rock-socket-cli\": \"bin/rock-socket-cli.js\" &#125;&#125; 他们分别的含义是： keywords：别的开发者可以通过这些关键字搜索到你的项目。 homepage：项目的主页，提供一些文档、说明等。 bugs：项目出现的问题，一般是github的issue的地址，可以引导大家去查看。 contributors：项目成员，可以被定义在这里。 files：文件的列表，可以用*来表示所有，规则跟shell的一样。 bin：yarn在安装时可以使用的图形化界面。 项目说明一般写入到gith中ReadMe.md中，供大家参考。在创建项目的时候，保证库的简洁，同样需要注意你的库所依赖的库。 项目发布首先要在npm注册一个account，注册地址，紧接着，在当前文件夹下： 1yarn login 会要求你提供刚刚输入的帐号以及邮箱，会在publish的时候问你询问密码，现在还不需要。 1yarn publish 首先会让你输入自己的版本号，然后会要求输入刚刚帐号的密码，最后提示成功。 使用你上传的项目在新的项目中： 1yarn add RockSocket 也可以通过： 1yarn info RockSocket 来查看自己库的信息，当然，在npmjs.com上也是可以看的到的。","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"https://wilddylan.github.io/tags/Node/"}],"keywords":[]},{"title":"算法开篇课","slug":"算法开篇课","date":"2016-10-14T05:13:53.000Z","updated":"2017-02-04T08:40:24.000Z","comments":true,"path":"2016/10/14/算法开篇课/","link":"","permalink":"https://wilddylan.github.io/2016/10/14/算法开篇课/","excerpt":"算法开篇介绍：Algorithm，是指解题方案的准确而完整的描述，代表着用系统的方法描述解决问题的策略机制。 最快最简单的排序首先看题： 班上有5位同学，分别考了5分，3分，5分，8分，2分，将分数从大到小排序是8，5，5，3，2。有什么好的办法可以编写一段程序，让计算机随机读入5个分数然后将这5个分数从大到小输出。老道的程序员可能各种冒泡，打擂台，这都比较深入了，先往下看： 我们借助一个一维数组就可以解决这个问题，创建一个a[11]的数组，这样下标分别为a[0]-&gt;a[10]，分别表示0分，1分…10分，每当有一个分数出现，就在对应的下标位置+1，最后打印即可满足我们现在的要求。 12345678910111213141516171819202122int main(int argc, const char * argv[]) &#123; int a[11]; int scannedNumber; for (int i = 0; i &lt; 11; i ++) &#123; a[i] = 0; &#125; for (int j = 0; j &lt; 5; j ++) &#123; scanf(\"%d\", &amp;scannedNumber); a[scannedNumber] ++; &#125; for (int k = 10; k &gt;= 0; k --) &#123; for (int l = 0; l &lt; a[k]; l ++) &#123; printf(\"%d\", k); &#125; &#125; return 0;&#125; 这种排序算法，我们称为桶排序，每个分数都好比一个桶，每出现一次，就在桶中加一点东西。接下来，我们尝试着对数据范围在0~100之间的任意数量数字进行从大到小的排序：","text":"算法开篇介绍：Algorithm，是指解题方案的准确而完整的描述，代表着用系统的方法描述解决问题的策略机制。 最快最简单的排序首先看题： 班上有5位同学，分别考了5分，3分，5分，8分，2分，将分数从大到小排序是8，5，5，3，2。有什么好的办法可以编写一段程序，让计算机随机读入5个分数然后将这5个分数从大到小输出。老道的程序员可能各种冒泡，打擂台，这都比较深入了，先往下看： 我们借助一个一维数组就可以解决这个问题，创建一个a[11]的数组，这样下标分别为a[0]-&gt;a[10]，分别表示0分，1分…10分，每当有一个分数出现，就在对应的下标位置+1，最后打印即可满足我们现在的要求。 12345678910111213141516171819202122int main(int argc, const char * argv[]) &#123; int a[11]; int scannedNumber; for (int i = 0; i &lt; 11; i ++) &#123; a[i] = 0; &#125; for (int j = 0; j &lt; 5; j ++) &#123; scanf(\"%d\", &amp;scannedNumber); a[scannedNumber] ++; &#125; for (int k = 10; k &gt;= 0; k --) &#123; for (int l = 0; l &lt; a[k]; l ++) &#123; printf(\"%d\", k); &#125; &#125; return 0;&#125; 这种排序算法，我们称为桶排序，每个分数都好比一个桶，每出现一次，就在桶中加一点东西。接下来，我们尝试着对数据范围在0~100之间的任意数量数字进行从大到小的排序： 123456789101112131415161718192021222324int main(int argc, const char * argv[]) &#123; int book[101], scannedNumber; int inputCount; for (int i = 0; i &lt; 101; i ++) &#123; book[i] = 0; &#125; printf(\"Enter numbers you want:\"); scanf(\"%d\", &amp;inputCount); for (int j = 0; j &lt; inputCount; j ++) &#123; scanf(\"%d\", &amp;scannedNumber); book[scannedNumber] ++; &#125; for (int k = 100; k &gt;= 0; k --) &#123; for (int l = 0; l &lt; book[k]; l ++) &#123; printf(\"%d \", k); &#125; &#125; return 0;&#125; 同样没有什么问题的，我们接下来考虑时间复杂度的问题：代码中第6行，循环了M次（M为桶的个数），第14行循环了N次（输入的数字个数），19行循环了M+N次，所以我们得到时间复杂度为O(2*(M+N))，在说时间复杂度的时候，可以忽略较小的常数，所以最终的时间复杂度为： 1O(M+N) 这是一个非常快的排序算法，其实这还不是真正的桶排序，桶排序实际要更复杂，这个只能算简化版。基本上还不能算是一个真正意义的算法，上边的处理如果碰到输出得该分数的同学的信息就显得有点问题了，因为我们只是输出了分数。所以引出第二节：冒泡排序 冒泡排序简化版的桶排序，不仅仅有使用范围的限制，更是浪费空间，如果我们需要排序的范围是0~2100000000，那就要申请2100000001个变量，我们要用这么多的桶来存储每一个数字出现的次数。即时，你只给3个数字（1， 19999， 1999999）排序，也需要2000001个桶，太浪费了。还不止，如果是浮点型呢？那我们接触一个新的算法，冒泡排序！它可以很好的解决这2个问题。冒泡排序的基本思想是，相邻的2个元素，如果顺序错误就把他们位置互换。如果我们要将 112, 35, 99, 18, 76 这几个数从大到小进行排序，越小的越靠后。 首先：比较第1位和第2位的大小，我们发现12要比35小，所以交换位置，交换后： 135, 12, 99, 18, 76 然后：按照上述的方法，继续往下比较，第2位与第3位…. 135, 99, 12, 18, 76 继续：第3位和第4位： 135, 99, 18, 12, 76 继续：第4位和第5位： 135, 99, 18, 76, 12 经过4次比较之后，最小的数字已经到了最后一位，一位一位的比，大的就往前换，就像一个气泡，所以称为冒泡。到这里，我们只是将其中的一个数字归位了，继续重复上面的过程：继续比较第1位与第2位，第2位与第3位，第3位与第4位，你会发现，第5位不需要比较了，因为他已经是最小的了。第二次比较后： 199, 35, 76, 18, 12 接下来的几次都是这样，有几个数字，比较的次数是n-1趟。冒泡的原则是，每次比较只将1个数组归位。接下来我们代码实现： 12345678910111213141516171819202122232425262728293031int main(int argc, const char * argv[]) &#123; int a[20], scannedNumber, input; scanf(\"%d\", &amp;input); for (int i = 1; i &lt;= input; i ++) &#123; scanf(\"%d\", &amp;scannedNumber); a[i] = scannedNumber; &#125; // 共有INPUT个数字，所以只需要排INPUT-1次即可 for (int i = 1; i &lt;= input - 1; i ++) &#123; // INPUT-I 意味着，每一次外层循环后，都有一个数字归位 for (int j = 1; j &lt;= input - i ; j ++) &#123; // 交换 if ( a[j] &lt; a[j + 1] ) &#123; int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125; for (int i = 1; i &lt;= input; i ++) &#123; printf(\"%d \", a[i]); &#125; return 0;&#125; 将上边的代码稍稍修改，就可以解决前面桶排序无法做到的输出学生信息以及浮点数的问题： 123456789101112131415161718192021222324252627282930313233struct Student &#123; char name[20]; float score;&#125;;int main(int argc, const char * argv[]) &#123; struct Student s[100]; int scannedNumber; scanf(\"%d\", &amp;scannedNumber); for (int i = 1; i &lt;= scannedNumber; i ++) &#123; scanf(\"%s %f\", s[i].name, &amp;s[i].score); &#125; // 控制排序次数 for (int j = 1; j &lt;= scannedNumber - 1; j ++) &#123; for (int k = 1; k &lt;= scannedNumber - j; k ++) &#123; if (s[k].score &lt; s[k+1].score) &#123; struct Student temp = s[k]; s[k] = s[k + 1]; s[k + 1] = temp; &#125; &#125; &#125; for (int l = 1; l &lt;= scannedNumber; l ++) &#123; printf(\"%s, %.2f\\n\", s[l].name, s[l].score); &#125; return 0;&#125; 完美搞定了。输入： 12345dylan 81.5alice 64.6peter 91.4bobo 31.9amy 67 输出： 12345peter, 91.40dylan, 81.50amy, 67.00alice, 64.60bobo, 31.90 冒泡排序的核心部分是嵌套循环，不难看出，冒泡循环的复杂度是： 1O(N^2) 这是一个很高的时间复杂度，冒泡排序除了它迷人的名字，以时间复杂度来看，没什么好推荐的，想要更好的排序么？ 快速排序冒泡排序算是我们学习的第一个算法，但是时间浪费的极多。假定计算机运行10亿次/秒，桶排序需要10亿+1个位置，但只需要0.1s，冒泡排序则需要1千万秒。接下来我们了解快速排序。首先记住快速排序的核心方法：设，基准数为左边第一个数，保证基准数左边全部比它小，右边全部比它大；所以2个起点，最左边、最右边。共同向中间触发，右边先走（注意，左边为基准数，一定要先从右往左，先想想为什么，后面给出解释），先从右边向左边找一个比基准数小的数字，然后从左边向右边找一个比基准数大的数字，交换他们。当左右碰面的时候，交换当前数字与基准数的位置。当基准数确认位置之后，基准数左边、右边分为2个子列（有一点点2分味道，以后讲），在进行设置基准数，寻找。这里用到了递归，所以我们来模拟一下过程，假定有这样一个数列： 16, 1, 2, 7, 9, 3, 4, 5, 10, 8 我们以最左边的6为初始基准数，从左向右找一个大于6的数，从右向左找一个小于6的数字，并交换，我们发现，从右向左第一个小于6的数字是5，从左向右第一个大于6的数字是7，交换他们的位置 16, 1, 2, 5, 9, 3, 4, 7, 10, 8 接下来，继续向前寻找，左向右发现了9，右向左发现了4，所以交换他们： 16, 1, 2, 5, 4, 3, 9, 7, 10, 8 继续往前，糟了，2个人撞一起了，这个时候，把基准数与这个数字交换位置： 13, 1, 2, 5, 4, 6, 9, 7, 10, 8 这样，基准数字6已经归位，而且左边都是小于6的数字，右边都是大于6的数字。接下来，我们分别处理左边、右边两个数列： 123, 1, 2, 5, 49, 7, 10, 8 先处理第一个序列，3为基准数： 12345678 i→ ←j3, 1, 2, 5, 4 得2, 1, 3, 5, 4 得子串1： 2, 1 -&gt; 1, 2子串2： 5, 4 -&gt; 4, 5 因为是右边先开始，所以在2的位置，会碰撞，交换位置即得到了结果。子串9, 7, 10, 8大家自己去分析一下。最终排序结束了。然后我们按照上边的思想来写代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int a[11];int count = 10;void sort(int left, int right);int main(int argc, const char * argv[]) &#123; for (int i = 1; i &lt;= count; i ++) &#123; scanf(\"%d\", &amp;a[i]); &#125; sort(1, count); for (int j = 1; j &lt;= count; j ++) &#123; printf(\"%d \", a[j]); &#125; return 0;&#125;void sort(int left, int right) &#123; if ( left &gt; right ) &#123; return; &#125; // 设置基准数 int refNum = a[left]; // 设置左右起点 int lPoint = left; int rPoint = right; // 当没有碰撞的时候，不停的交换 while (lPoint != rPoint) &#123; // 从右边开始找，比基准数小的数字, 然后停止，注意我的判断，如果比基准数大，rPoint向前移动一位，也就是说，如果比基准数字小，rPoint记录的就是这个数字的位置 while (a[rPoint] &gt;= refNum &amp;&amp; lPoint &lt; rPoint) &#123; rPoint --; &#125; // 左边找，比基准数大的数字，然后停止 while (a[lPoint] &lt;= refNum &amp;&amp; lPoint &lt; rPoint ) &#123; lPoint ++; &#125; // 交换位置 if ( lPoint &lt; rPoint ) &#123; int temp = a[lPoint]; a[lPoint] = a[rPoint]; a[rPoint] = temp; &#125; &#125; // 归位基准数字，这个时候，左右标记点处于同一个位置上，也就是基准点应该在的位置 a[left] = a[lPoint]; a[lPoint] = refNum; // 交换之后，开始处理子串，基准数不需要动位置 sort(left, lPoint - 1); sort(lPoint + 1, right); return ;&#125; 现在我们来回顾上边的问题左边为基准数，为什么一定要先从右边开始? 基准数字在左边，假设，左边先开始，找的是比基准数字大的数字： 13, 1, 2, 6, 7 如上，找到数字6的时候，左边停下了，右边开始寻找，发现直接碰撞了，变成了： 16, 1, 2, 3, 7 但是如果从右边开始就会变成 12, 1, 3, 6, 7 总结排序的算法还有很多，计数、基数、插入、归并、堆排序等，我们在后边会慢慢的涉及到。当然，快排的时间复杂度怎么算呢？我们想想，最差的情况，就是像冒泡一样，相邻的2个数字不停的交换，为： 1O(N^2) 快排的最好时间复杂度为（为什么）： 1O(NLogN) 由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。 练习要求对不定数量的数字进行排序，1秒之内完成。 拿到这道题，我们关注的应当是1s之内，数字是不定量的，我们需要按照上边提供的时间复杂度来讲。假如说现在范围超级大，使用桶排序基本不可能的，因为没法申请那么大的数组，如果数字超级多，使用冒泡排序的时间复杂度又是O(N^2)，但是使用快速排序却很好。代码省略了。 本文结束。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wilddylan.github.io/tags/算法/"}],"keywords":[]},{"title":"上传Library到JCenter","slug":"上传Library到JCenter","date":"2016-10-14T03:27:30.000Z","updated":"2017-02-04T09:02:40.000Z","comments":true,"path":"2016/10/14/上传Library到JCenter/","link":"","permalink":"https://wilddylan.github.io/2016/10/14/上传Library到JCenter/","excerpt":"确定要上传的Library如果你有Library可以忽略此步骤，没有的话添加library。在Android Studio中选择File-&gt;New-&gt;New Module,然后选择一个Library,新建一个Library。这里以新建DemoLibrary为例子。（注意这里的Library需要后面的Package的名字一致）。","text":"确定要上传的Library如果你有Library可以忽略此步骤，没有的话添加library。在Android Studio中选择File-&gt;New-&gt;New Module,然后选择一个Library,新建一个Library。这里以新建DemoLibrary为例子。（注意这里的Library需要后面的Package的名字一致）。 现在项目的结构如下图，接下来就是添加必要的Jcenter的依赖，为上传做准备。 注册账号首先去bintray官网注册账号，注册完成后验证邮箱，然后登陆进入首页点击View All，选择Maven仓库，新建一个Package，填写Package名字（注意Package需要和你的Library的名字一致） 注意点击你的头像-&gt;Your Profile-&gt;Edit-&gt;Api key,这个先记下来，后面上传要用到。 新建一个Package 添加依赖在整个工程的build.gradle文件中添加classpath &#39;com.novoda:bintray-release:0.3.4&#39;,注意是整个工程的build.gradle。 接着是在你自己Library（这里是DemoLibrary）的build.gradle的文件中配置自己的信息，复制下面的脚本，改成你自己的信息即可 1234567891011121314apply plugin: &apos;com.android.library&apos;apply plugin: &apos;com.novoda.bintray-release&apos;publish &#123; userOrg = &apos;lufficc&apos; //你的用户名 groupId = &apos;com.lufficc&apos; //你的唯一的groupId，对应com.squareup.okhttp3:okhttp:3.4.1中的com.squareup.okhttp3 artifactId = &apos;DemoLibrary&apos; //你的library的名字，对应com.squareup.okhttp3:okhttp:3.4.1中的okhttp publishVersion = &apos;0.0.1&apos; //版本号 desc = &apos;This is a demo library to teach how to publish you own library to jcenter with android studio.&apos; website = &apos;http://lufficc.com/&apos; //建议填写github地址，不过不影响，这里做演示填的自己的网址 bintrayUser = &apos;lufficc&apos; //你的用户名 bintrayKey = &apos;Your api key&apos; //在你的账户里面查找&#125; 经过上面的配置，上传成功后那么别人引用你的library的代码就为compile &#39;com.lufficc:DemoLibrary:0.0.1&#39;。 上传经过上面的配置，现在就可以传了，上传之前记得Sync一下Project,然后打开命令行，输入,回车： 1gradlew clean build bintrayUpload -PdryRun=false 然后等待几分钟，期间会联网下载依赖的库，最后如果没有问题，会显示BUILD SUCCESSFUL信息，然后去官网查看刚才建的Package，会发现多了你刚才上传的版本号。 点进去可以看到有三种引用方式： 但是到这里还无法让别人也能引用，目前只是你自己的私人库。下面是添加到Jcenter,非常简单。 添加到Jcenter在上面的页面中点击Add To JCenter，然后随便填写一下comments，点击send，然后工作人员会审核和，你只需等待几个小时，然后会有站内消息提示你已经发布发到Jcenter，这样别人也可以引用你的Library，有没有很自豪的感觉！ 更新版本号这个非常简单，当你的Libraryd代码更改后，只需要更改一下上面的配置里面的publishVersion，运行gradlew clean build bintrayUpload -PdryRun=false，就可以更新版本号了。这样，整个过程就结束了，遇到什么问题欢迎评论提出或者私信我。 总结 其实上传没那么复杂 注册账号 为自己的Library项目添加依赖，配置信息 上传，添加到Jcenter 更新版本号 常见问题 如果你的Java doc含有中文导致上传失败，可以尝试在lib的build.gradle添加如下代码： 123456789allprojects &#123;tasks.withType(Javadoc) &#123; options&#123; encoding &quot;UTF-8&quot; charSet &apos;UTF-8&apos; links &quot;http://docs.oracle.com/javase/7/docs/api&quot; &#125;&#125;&#125; 本教程是基于插件novoda/bintray-release的，更多问题可以查看issues或者查看Wiki。 原文地址","categories":[],"tags":[{"name":"AndroidLib","slug":"AndroidLib","permalink":"https://wilddylan.github.io/tags/AndroidLib/"}],"keywords":[]},{"title":"一些App动态化解决方案","slug":"一些App动态化解决方案","date":"2016-10-14T02:30:36.000Z","updated":"2017-02-04T09:02:20.000Z","comments":true,"path":"2016/10/14/一些App动态化解决方案/","link":"","permalink":"https://wilddylan.github.io/2016/10/14/一些App动态化解决方案/","excerpt":"文章持续更新 App动态化解决方案，说白了就是后台可以控制或更改App的行为。一些常见的做法如： App启动请求配置文件，配置文件中存放着一系列的参数，供App配置 使用一些第三方SDK提供的动态参数（跟第一种类似） 使用App触发与Socket的长连接，时时的调配或者修改应用程序信息 使用HTML 使用HTML作为动态界面的App我们又称为Hybrid App（混合性App），是指介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。现在有半数以上的App都可以被称为这种类型的App。 热修复程序出BUG了，服务端通过程序启动的配置文件或者Socket链接向App下发一段代码进行修复，业界出名的JSPatch使用范围极广。只需配置一段JS代码即可达到运行时替换或者增加方法等操作。是作为热修复的极好选择。还有一些热修复的方案就是通过HTML来替换当前的原生界面，这样的App通常是组件化App，所有界面的打开均通过服务器获取的Map进行路由，服务器只需动态的更新这张Map，替换到出问题的界面即可。但是这种方法仅仅对界面有用，如果某一类的功能出了问题，就无用了（App还是以界面为主的，BUG也多发生与界面，当然高级的BUG略过了）。","text":"文章持续更新 App动态化解决方案，说白了就是后台可以控制或更改App的行为。一些常见的做法如： App启动请求配置文件，配置文件中存放着一系列的参数，供App配置 使用一些第三方SDK提供的动态参数（跟第一种类似） 使用App触发与Socket的长连接，时时的调配或者修改应用程序信息 使用HTML 使用HTML作为动态界面的App我们又称为Hybrid App（混合性App），是指介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。现在有半数以上的App都可以被称为这种类型的App。 热修复程序出BUG了，服务端通过程序启动的配置文件或者Socket链接向App下发一段代码进行修复，业界出名的JSPatch使用范围极广。只需配置一段JS代码即可达到运行时替换或者增加方法等操作。是作为热修复的极好选择。还有一些热修复的方案就是通过HTML来替换当前的原生界面，这样的App通常是组件化App，所有界面的打开均通过服务器获取的Map进行路由，服务器只需动态的更新这张Map，替换到出问题的界面即可。但是这种方法仅仅对界面有用，如果某一类的功能出了问题，就无用了（App还是以界面为主的，BUG也多发生与界面，当然高级的BUG略过了）。 热更新热更新与热修复本应该是出现在同一个位置的，热更新多为代码的修改与控制的变更，比如说微信经常在App发布的时候埋一些小功能在里边，然后到了节日通过控制打开等，Hybrid App常用的动态更新分2中，服务端直接更新，动态更新本地的资源Zip包。我之前的公司也有写过一套JSON-&gt;View的方法用于更新界面。 动态调试、实时调试首先是与服务器建立链接的方式，一般都会以摇一摇等动作来触发，App与Socket建联之后，实时的监控这VC的didAppear等方法，每当App界面变化，都会为当页截图，处理之后通过长连接上传到服务器，服务器发给后台之后，后台根据一些空间的信息与截图进行绘制，一个同步的App界面就展示到了后台。当然，后台也可以动态的把这些空间的点击事件传回App。 日志的动态获取等完全是代码提前写好的，打开远程调试之后原有的Log组件输出在链路中，后台展示即可。通过socket我们可以做很多的操作。 动态化的实现步骤热更新与热修复这2点业界使用比较广泛，知识点也比较基础，所以这里不做讲解；动态界面调试，实时日志可以略微讲解一下。 socket服务器的搭建 App.socket服务的编码，web.socket服务的编码 数据格式的制定 数据内容的编解码方式 为了方便期间，socket服务从socket.io与webSocket中选择一种即可，我们选择socket.io，应为有很多现成的解决方案与代码。 服务端作为数据的中转站，做好一些基础的日志记录与错误捕获即可，App、Web端的编解码数据的方式要统一，App、Web实时的发送心跳包到服务器维持在服务器的虚拟存活状态。 App：每一个界面根据类名生成唯一的ID，内部的控件使用界面类名+控件类名+控件某一约定的属性内容，获取到之后使用base64编码之后发送到服务器，服务器做路由。 Web：拿到界面之后进行数据解码，首先渲染App传来的界面截图，然后做空间的处理，根据控件ID+控件详细信息（frame，selector&lt;可点击控件拥有&gt;）等，渲染，并可以操作，touch事件知道点击的控件之后，将事件传回App，做的好的可以把手势全部的做进去。 一个完整的界面动态调试模块基本可以做到，所有的手势识别，控件均可挪动，事件可以共同响应等。","categories":[],"tags":[{"name":"动态化","slug":"动态化","permalink":"https://wilddylan.github.io/tags/动态化/"}],"keywords":[]},{"title":"Swift语法熟悉（四）","slug":"Swift语法熟悉（四）","date":"2016-10-13T03:31:43.000Z","updated":"2017-02-04T09:01:56.000Z","comments":true,"path":"2016/10/13/Swift语法熟悉（四）/","link":"","permalink":"https://wilddylan.github.io/2016/10/13/Swift语法熟悉（四）/","excerpt":"上期提到了使用Moya作为网络基础模块，但是涉及到了一个sampleData的问题，我们也是即时的提交了一个issue来质问这样的默认Response data为什么类型竟然是Optional的。Moya的开发者举例：可以将上一次获取到的数据在需要的时候（网络请求失败）传入这里，所以进而给出建议：将var sampleData改为var cachePolicy进行缓存控制即可，缓存过期的时间由Server端使用Cache-control或Expires决定，目前有的回复是，作者觉得这个建议很棒，说不定有机会为Moya加入缓存机制。接下来继续我们的开发计划： 推送服务应当明确的是，每家公司用的推送第三方都是不同的（大部分是阿里云、极光、个推），所以继承第三方SDK这个事情不应该出现在框架中。框架仅仅负责申请推送能力即可。测试：在测试之前，Info.plist中所需要申请权限的Key需要自己手动配置。Xcode 8 后打开推送需要在程序中打开选项：","text":"上期提到了使用Moya作为网络基础模块，但是涉及到了一个sampleData的问题，我们也是即时的提交了一个issue来质问这样的默认Response data为什么类型竟然是Optional的。Moya的开发者举例：可以将上一次获取到的数据在需要的时候（网络请求失败）传入这里，所以进而给出建议：将var sampleData改为var cachePolicy进行缓存控制即可，缓存过期的时间由Server端使用Cache-control或Expires决定，目前有的回复是，作者觉得这个建议很棒，说不定有机会为Moya加入缓存机制。接下来继续我们的开发计划： 推送服务应当明确的是，每家公司用的推送第三方都是不同的（大部分是阿里云、极光、个推），所以继承第三方SDK这个事情不应该出现在框架中。框架仅仅负责申请推送能力即可。测试：在测试之前，Info.plist中所需要申请权限的Key需要自己手动配置。Xcode 8 后打开推送需要在程序中打开选项： 这样，如果是单单写权限的话，直接用之前我们引入的PermissionScope就可以搞定了，Push的class可以写为open的，因为每个项目对Push的需求不同，所以在Push中我们顺便截获一下信息然后提供给用户，也很简单。所以获得推送权限的需求我们放到Permission.swift中。由于屏幕限制，所以Permission也最多允许大家同时打开3个权限。改写之前的Permission.swift： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import Foundationimport PermissionScopepublic enum INSPermissionType &#123; case notification(Set&lt;UIUserNotificationCategory&gt;?, String) case locationAlways(String) case locationWhenInUse(String) case contact(String) case event(String) case microphone(String) case camera(String) case photos(String) case reminders(String) case bluetooth(String) case motion(String)&#125;open class Permission &#123; open static let `default` = Permission() static let pscope: PermissionScope = &#123; let permissionScope = PermissionScope() // Default customs permissionScope.headerLabel.text = \"嗨，你好！\" permissionScope.bodyLabel.text = \"在使用我们的应用之前\\n我们需要你做一些事情：\" permissionScope.closeButtonTextColor = UIColor.clear permissionScope.permissionButtonΒorderWidth = 0.5 permissionScope.permissionButtonCornerRadius = 2 /// 如果你希望更改权限开启按钮的英文，就需要自己配置本地化文件 /// 参考这里 https://github.com/nickoneill/PermissionScope/pull/12#issuecomment-96428580 return permissionScope &#125;() open class func requestPermission(_ permissionTypes: [INSPermissionType], _ authChange: authClosureType? = nil, cancelled: cancelClosureType? = nil) &#123; for item in permissionTypes &#123; switch item &#123; case .notification(let categories, let message): pscope.addPermission(NotificationsPermission(notificationCategories: categories), message: message) continue case .locationAlways(let message): pscope.addPermission(LocationWhileInUsePermission(), message: message) continue case .locationWhenInUse(let message): pscope.addPermission(LocationWhileInUsePermission(), message: message) continue case .contact(let message): pscope.addPermission(ContactsPermission(), message: message) continue case .event(let message): pscope.addPermission(EventsPermission(), message: message) continue case .microphone(let message): pscope.addPermission(MicrophonePermission(), message: message) continue case .camera(let message): pscope.addPermission(CameraPermission(), message: message) continue case .photos(let message): pscope.addPermission(PhotosPermission(), message: message) continue case .reminders(let message): pscope.addPermission(RemindersPermission(), message: message) continue case .bluetooth(let message): pscope.addPermission(BluetoothPermission(), message: message) continue case .motion(let message): pscope.addPermission(MotionPermission(), message: message) continue default: continue &#125; &#125; pscope.show(authChange, cancelled: cancelled) &#125;&#125; 然后测试效果（别忘记在Info.plist中添加相关的请求权限的Key-Desc）： 1234567let permissionTypes = [ INSPermissionType.notification(nil, \"打开推送服务\"), INSPermissionType.camera(\"打开相机服务\"), INSPermissionType.photos(\"希望使用照片\")] Permission.requestPermission(permissionTypes) 原本计划是要写Push.swift进行截获数据的，但是总感觉这样做貌似不太合理。所以索性我们止只统计一下用户收到推送好了，在Push.swift中仅提供一个方法入口，把推送的内容传进来供我们内部处理。不要干涉AppDelegate处理推送了，而且在iOS10之后要做版本兼容，使用UNUserNotificationCenterDelegate来处理推送，而且大多数第三方SDK都会有自己的处理方式。 所以在我们的Push.swift中，我们先预留一些代码： 等会儿先看个东西： 好、继续写代码： 123456789101112131415final public class Push &#123; public static let `default` = Push() public func DeviceToken(_ deviceToken: Data) &#123; &#125; public func ReceivedPushMessage (_ userInfo: [AnyHashable : Any]) &#123; &#125; private init() &#123; &#125;&#125; 简单的预留一些方法入口即可，不急着写，接着往下写日志上报（直接改造之前的Logger类）： 123456789101112131415161718192021222324252627282930313233final public class INSLogger &#123; /// 默认为输出全部日志 public static let `default` = INSLogger() /// 日志级别 public var level: LogLevel = .all /// 是否上报崩溃 public var crashCollect: Bool = true /// 日志输出 /// /// - parameter lev: 日志级别 /// - parameter content: 日志内容 public func printLog(_ lev: LogLevel, _ details: String, _ items: Any) &#123; guard level == .all || level == lev, ModeSwitcher.currentMode == .develope else &#123; return &#125; print(lev.rawValue, details, \"\\n\", items) &#125; private var exception: NSException? = nil public func setUncaughtException() &#123; NSSetUncaughtExceptionHandler &#123; let exception = $0 let name = exception.name let reason = exception.reason ?? \"Without system crash version.\" let callStack = exception.callStackSymbols let crashLog = \"name:\\(name)\\nreason:\\(reason)\\ncallStack:\\(callStack.joined(separator: \"\\n\"))\" // TODO: 上报 &#125; &#125;&#125; 获取到崩溃的信息后，我们在这里加一个TODO标签。 这里需要注意的是：框架外部如果也需要做日志捕获，那么需要先使用NSGetUncaughtExceptionHandler()获取当前的捕获器，在自己的捕获成功之后也让别人的捕获成功。啊好累啊，这还不是完整的奔溃捕获，于是我们接着写代码（写代码到时无妨，主要是这里有一坑爹的事情，需要自己去查看解决，说明：无法把方法传入这些捕获方法，也附上气前一个链接中的代码）： 慵懒的完善了signal后（上边提到的不能使用C方法的问题自己去解决把，这里仅仅是展示，所以不写那么详细了）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/// 设置异常捕获 public func setUncaughtException() &#123; NSSetUncaughtExceptionHandler &#123; let exception = $0 let name = exception.name let reason = exception.reason ?? \"Without system crash version.\" let callStack = exception.callStackSymbols let crashLog = \"name:\\(name)\\nreason:\\(reason)\\ncallStack:\\(callStack.joined(separator: \"\\n\"))\" exception.raise() // TODO: 上报 &#125; signal(SIGILL) &#123; let crashLog = \"SignalRaisedException(\\($0)): Illegal instruction (not reset when caught)\" // TODO: 上报 &#125; signal(SIGABRT) &#123; let crashLog = \"SignalRaisedException(\\($0)): Abort, abort()\" // TODO: 上报 &#125; signal(SIGFPE) &#123; let crashLog = \"SignalRaisedException(\\($0)): Floating point exception\" // TODO: 上报 &#125; signal(SIGBUS) &#123; let crashLog = \"SignalRaisedException(\\($0)): Bus Error\" // TODO: 上报 &#125; signal(SIGSEGV) &#123; let crashLog = \"SignalRaisedException(\\($0)): segmentation violation\" // TODO: 上报 &#125; signal(SIGSYS) &#123; let crashLog = \"SignalRaisedException(\\($0)): Bad argument to system call\" // TODO: 上报 &#125; signal(SIGPIPE) &#123; let crashLog = \"SignalRaisedException(\\($0)): Write on a pipe with no one to read it\" // TODO: 上报 &#125; &#125; public func unSetUncaughtException() &#123; NSSetUncaughtExceptionHandler(nil) signal(SIGILL, SIG_DFL); signal(SIGABRT, SIG_DFL); signal(SIGFPE, SIG_DFL); signal(SIGBUS, SIG_DFL); signal(SIGSEGV, SIG_DFL); signal(SIGSYS, SIG_DFL); signal(SIGPIPE, SIG_DFL); &#125; 这里只捕获了一部分signal，点进去自己看了解下，我之前也写过一篇关于日志捕获的文章，可以去找找。继续往下写：信息收集，新建swift文件Analytics.swift，这里我只给出一部分思路（完整的Analytics又是一个独立的框架，建议参考的是开源的ZhugeIO）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129import Foundationimport LKDBHelperlet AnalyticsManagerFlushedFlagKey = \"AnalyticsManagerFlushedFlagKey\"class AnalyticsItem: NSObject &#123; /// 事件名称 var eventName: String /// 事件数据 var parameters: [String: Any]? func toAnalytice() -&gt;[String: String] &#123; return [eventName ?? \"\": \"\\(parameters ?? [\"\": \"\"])\"] &#125; init(_ eventName: String, _ parameters: [String: Any]? = nil) &#123; self.eventName = eventName self.parameters = parameters &#125; override static func getTableName() -&gt; String &#123; return \"AnalyticsItem\" &#125;&#125;final public class Analytics &#123; public static let `default` = Analytics() public typealias FlushHandler = (_ info: [String], _ analyticsData: [[String: String]])-&gt;() /// 设备唯一标识，默认是UUID public var deviceIdentifier: String /// 设备用户标识，以设备标识为准 public var userIdentifier: String /// 上报间隔，会调用上报的方法，外部控制网络请求 public var flushInterval: Int = 10 /// 上报的回调方法 public var flushHandler: FlushHandler? /// 存储准备上报的数组 private var analyticsItems: [AnalyticsItem] = [] /// 是否已经上报，通过检查本地值来确定 private var flushed: Bool private var timer: Timer? = nil /// 追踪事件 public func track(_ eventName: String, _ parameters: [String: Any]? = nil) &#123; if analyticsItems.count == 0 &#123; startTimer() &#125; analyticsItems.append(AnalyticsItem(eventName, parameters)) &#125; /// 主动上报到服务器 public func flush() &#123; guard analyticsItems.count &gt; 0, let handler = flushHandler else &#123; return &#125; handler([deviceIdentifier, userIdentifier], analyticsItems.map &#123; return $0.toAnalytice() &#125;) stopTimer() flushed = true &#125; private func startTimer() &#123; stopTimer() timer = Timer.init(timeInterval: TimeInterval(flushInterval), target: self, selector: \"flush\", userInfo: nil, repeats: true) RunLoop.current.add(timer!, forMode: .commonModes) &#125; private func stopTimer() &#123; timer?.invalidate() timer = nil analyticsItems.removeAll() &#125; private func getLocalAnalyticsItem() &#123; AnalyticsItem.search(withWhere: nil).forEach &#123; [unowned self] in self.analyticsItems.append($0 as! AnalyticsItem) &#125; let dbHelper = AnalyticsItem.getUsingLKDBHelper()! dbHelper.dropTable(with: AnalyticsItem.self) &#125; public func setNeedsRestoreItems() &#123; analyticsItems.forEach &#123; $0.saveToDB() &#125; analyticsItems.removeAll() UserDefaults.standard.set(false, forKey: AnalyticsManagerFlushedFlagKey) UserDefaults.standard.synchronize() &#125; public func restoreItems() &#123; if flushed == false &#123; getLocalAnalyticsItem() &#125; &#125; private func UIApplicationDidEnterBackground() &#123; setNeedsRestoreItems() &#125; private func UIApplicationDidBecomeActive() &#123; self.flushed = UserDefaults.standard.bool(forKey: AnalyticsManagerFlushedFlagKey) restoreItems() &#125; private func addListener() &#123; NotificationCenter.default.addObserver(self, selector: \"UIApplicationDidEnterBackground\", name: .UIApplicationDidEnterBackground, object: nil) NotificationCenter.default.addObserver(self, selector: \"UIApplicationDidBecomeActive\", name: .UIApplicationDidBecomeActive, object: nil) &#125; private func removeListener() &#123; stopTimer() NotificationCenter.default.removeObserver(self) &#125; private init() &#123; self.deviceIdentifier = UUID().uuidString self.userIdentifier = \"iOS Device\" self.flushed = UserDefaults.standard.bool(forKey: AnalyticsManagerFlushedFlagKey) restoreItems() addListener() &#125; deinit &#123; removeListener() &#125;&#125;public let AnalyticsManager = Analytics.default 完成之前的奔溃时日志上报 1234// TODO: 上报AnalyticsManager.track(\"CRASH\", [\"info\": crashLog])// 程序奔溃需要调用标记未上传AnalyticsManager.setNeedsRestoreItems() 写到这里，框架其实只有30%，只有结合业务才能做出与业务相匹配的框架，接下来就是Cache，我只给出代码框架： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//存储引擎public enum IDPStorageType &#123; case disk case sql&#125;//缓存策略public enum IDPCacheStoragePolicy &#123; case memory case disk case memoryAndDisk&#125;open class INSCache &#123; open static let `default` = INSCache() open var _nameSpace: String = \"INSCache\" open var _cacheStoragePolicy: IDPCacheStoragePolicy = .memoryAndDisk open var _memoryCapacity: Float = 0 open var _memoryTotalCost: Float = 0 open var _diskExpiredTime: Int = 0 open func existCacheForKey(_ key: String) -&gt;Bool &#123; return false &#125; open func clearMemory() &#123; &#125; open func existCacheForKeyInMemory(_ key: String) -&gt;Bool &#123; return false &#125; open func existCacheForKeyOnDisk(_ key: String) -&gt;Bool &#123; return false &#125; open func setObject(_ data: AnyObject, for key: String) &#123; &#125; open func getObject(for key: String) -&gt;AnyObject? &#123; return nil &#125; open func objectForKeyOnlyInMemory(_ key: String) -&gt;AnyObject? &#123; return nil &#125; open func asyncObject(forKey key: String, _ handler: (AnyObject)-&gt;()) &#123; &#125; open func removeObjcet(for key: String) &#123; &#125; open func removeObjcetForKeyOnlyInMemory(_ key: String) &#123; &#125; open func removeAll () &#123; &#125; open func removeAllInMemory() &#123; &#125; open func removeAllInDisk() &#123; &#125; open class func removeNameSpace(_ spaceName: String) &#123; &#125;&#125; 包括模型的基类： 123456789101112131415161718192021222324252627open class Model: NSObject &#123; open var _ModelIdentifier: String? open var _ModelUpdatedAt: Date? open var _ModelCreatedAt: Date? open var _ModelExpiredAt: Date? open var _ModelNeedsCache: Bool? open var _CurrentPage: Int = 0 open var _PageSize: Int = 10 open var _TotalCount: Int = 0 open var _StartAt: Int = 0 open func load() &#123; &#125; open func refresh() &#123; &#125; open func cancel() &#123; &#125; open func goNextPage() &#123; &#125; open func goPrevPage() &#123; &#125; open func hasPrev() -&gt;Bool&#123; return false &#125; open func hasNext() -&gt;Bool&#123; return false &#125; public override init() &#123; &#125;&#125; 框架到这里就不说了，接下来有时间就会实际的在使用中一步步的优化框架，让框架适应业务。最近有点忙，开了算法课程，所以框架上边大部分东西都是懒得写，但是使用到的第三方库都建议大家去阅读源码（除ASDK以外）。希望会有所提升。代码地址。仅供作为Swift的语言熟悉，不作为框架教学。","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://wilddylan.github.io/tags/Swift/"}],"keywords":[]},{"title":"Swift语法熟悉（三）","slug":"Swift语法熟悉（三）","date":"2016-10-11T04:16:46.000Z","updated":"2017-02-04T09:01:58.000Z","comments":true,"path":"2016/10/11/Swift语法熟悉（三）/","link":"","permalink":"https://wilddylan.github.io/2016/10/11/Swift语法熟悉（三）/","excerpt":"为什么将数据模块与网络模块一起编写？紧密相关的2者，也是应用程序最常见的组合：请求数据-存储数据-展示数据。 数据模块（JSON、Model、DB）数据持久层其实有很多杂乱的选择，文件做为持久层的基础类型，又被分为sql、xml等等类型，我们可选的范围也很广阔，也可以自己动手来完善整个持久层模块，但这似乎对于很懒的程序员来说太浪费玩耍的时间了。所以我们索性在一些完善的开源库中挑选一类供我们做上层的封装。我们姑且确定选择FMDB作为我们的数据库支撑，但是联想到一般情况下，把JSON转换为Model直接存向数据库是常用需求，所以在数据模块这一层貌似扩展的很大了。我们首先引入SwiftyJSON作为JSON解析，不仅供框架使用也供外层使用，但是SwiftJSON解析后的数据仅是JSON对象，看来我们要亲自把JSON对象转换为Model了，写好之后，就是数据的存储。","text":"为什么将数据模块与网络模块一起编写？紧密相关的2者，也是应用程序最常见的组合：请求数据-存储数据-展示数据。 数据模块（JSON、Model、DB）数据持久层其实有很多杂乱的选择，文件做为持久层的基础类型，又被分为sql、xml等等类型，我们可选的范围也很广阔，也可以自己动手来完善整个持久层模块，但这似乎对于很懒的程序员来说太浪费玩耍的时间了。所以我们索性在一些完善的开源库中挑选一类供我们做上层的封装。我们姑且确定选择FMDB作为我们的数据库支撑，但是联想到一般情况下，把JSON转换为Model直接存向数据库是常用需求，所以在数据模块这一层貌似扩展的很大了。我们首先引入SwiftyJSON作为JSON解析，不仅供框架使用也供外层使用，但是SwiftJSON解析后的数据仅是JSON对象，看来我们要亲自把JSON对象转换为Model了，写好之后，就是数据的存储。 通常情况下，iOS App中常用的存储：UserDefault、WriteToFile、SQL、钥匙串等。为了框架的通用性，只选择完善SQL，即Model-&gt;DB，至于别的存储让App在框架外层随意。如果你的团队不是足够成熟的话， 并不建议在项目中使用CoreData。 想想这个模块比较大，所以单开一个文件夹：Model吧。 首先引入SwiftJSON作为JSON解析的模块。 1pod 'SwiftyJSON' 明确目标1： JSON对象转换为模型 模型转换为JSON对象 要实现我们这2个功能，必须遵守协议，在协议的方法中返回Mapping供我们赋值，类似：[属性名：JSON对象的Key]。 123456public protocol ModelMap &#123; /// 提供属性的对应Map /// /// - returns: 字典，为：属性名称：(JSON对象中名称，类型) static func keyMapping() -&gt;Dictionary&lt;String, (String, String)&gt;&#125; 首先我们要了解一些关于Swift runtime的东西，在纯Swift类中的属性在未添加dynamic修饰之前是不可以被运行时获取到属性的，之前我写过一篇有关Swift运行时的文章，可以细阅。 在这里有一个缺陷，就是我们这个库不允许你的模型是继承来的，因为static关键字代替了class final，在子类中不可以被覆盖，使用Extension又不能很好的解决方便程度上的问题而且需要写基类。所以在考虑了很多很多之后，还是决定写扩展！并且不对纯Swift类进行处理，只处理NSObject类。 1234567891011121314151617181920extension NSObject &#123; /// 提供属性的对应Map /// /// - returns: 字典，为：属性名称：JSON对象中名称 open class func keyMapping() -&gt;Dictionary&lt;String, String&gt;? &#123; return nil &#125; /// 提供的类对应Map open class func classMapping() -&gt;Dictionary&lt;String, AnyClass&gt;? &#123; return nil &#125; /// 忽略的属性的名称 /// /// - returns: 数组，忽略的属性名称数组 open class func ignoredKey() -&gt;[String]? &#123; return nil &#125;&#125; 这样所有需要被转换的类都需要继承Model类。但是使用的时候就比较尴尬了，必须要提供一个初始值，下面是我们的测试类： 1234567891011121314151617181920212223242526272829303132333435363738394041import UIKitimport INSSwiftclass Person: NSObject &#123; var name: String = \"\" var gender : Bool = false var array: Array = [\"\"] var dictionary: Dictionary&lt;String, Any&gt; = [\"\": \"\"] var student: Student = Student() var teachers: [Teacher] = [] var ignored: String = \"\" override class func keyMapping() -&gt;Dictionary&lt;String, String&gt;? &#123; return [ \"gender\": \"dictionary, gender\", \"teachers\": \"student, t\" ] &#125; override class func classMapping() -&gt;Dictionary&lt;String, AnyClass&gt;? &#123; return [ \"student\": Student.self, \"teachers\": Teacher.self ] &#125; override class func ignoredKey() -&gt;[String]? &#123; return [\"ignored\"] &#125;&#125;class Student: NSObject &#123; var sname: String = \"\" var sage: Int = 0&#125;class Teacher: NSObject &#123; var tname: String = \"\"&#125; 如果dynamic var name: String?的话，后果自负…会提示错误不能转换为OC类型。这里我附上完整的Model处理的代码以及测试代码，在Model文件夹下新建文件Model.swift： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214import Foundationimport SwiftyJSONpublic enum PropertyType: String &#123; case tString = \"T@\\\"NSString\\\"\" case tNSArray = \"T@\\\"NSArray\\\"\" case tNSDictionary = \"T@\\\"NSDictionary\\\"\" case tBool = \"TB\" case tClass = \"T@\\\"_TtC\" case tDouble = \"Td\" case tFloat = \"Tf\" case tInt = \"Tq\" case tInt8 = \"Tc\" case tInt16 = \"Ts\" case tInt32 = \"Ti\" case tUInt = \"TQ\" case tUInt8 = \"TC\" case tUInt16 = \"TS\" case tUInt32 = \"TI\" case unknow = \"UNKNOWTYPE\"&#125;extension NSObject &#123; /// 提供属性的对应Map /// /// - returns: 字典，为：属性名称：JSON对象中名称 open class func keyMapping() -&gt;Dictionary&lt;String, String&gt;? &#123; return nil &#125; /// 提供的类对应Map open class func classMapping() -&gt;Dictionary&lt;String, AnyClass&gt;? &#123; return nil &#125; /// 忽略的属性的名称 /// /// - returns: 数组，忽略的属性名称数组 open class func ignoredKey() -&gt;[String]? &#123; return nil &#125;&#125;/// 模型生成工厂final public class ModelFactory &#123; // MARK: - 对象生成 /// 转换JSON-&gt;Model /// /// - parameter json: JSON对象 /// - parameter cls: 类型 /// - returns: AnyObject public class func Convert(JSON json: JSON?, to cls: AnyClass) -&gt;AnyObject? &#123; let model = cls.alloc() let keyMapping = cls.keyMapping() let classMapping = cls.classMapping() setValue(with: fullPropertyFor(class: cls), for: model, with: classMapping, with: keyMapping, data: json) return model &#125; // MARK: - Private methods /// 赋值 /// - parameter props: 属性对应字典 /// - parameter object: 赋值的对象 /// - parameter clsMap: 类型映射字典 /// - parameter mapping: 属性映射字典 /// - parameter data: JSON对象 public class func setValue(with props: Dictionary&lt;String, String&gt;?, for object: AnyObject, with clsMap: Dictionary&lt;String, AnyClass&gt;?, with mapping: Dictionary&lt;String, String&gt;?, data data: JSON?) &#123; guard let fullInfos = props, fullInfos.count != 0, let json = data else &#123; return &#125; /// 将所有的Info取出来 for (key, typeString) in fullInfos &#123; /// 首先从Mapping中检测是否有对应的Mapper let JSONKey = mapping?[key] ?? key var JSONValue = json[JSONKey] if JSONKey.contains(\",\") &#123; var items: Array&lt;String&gt; = [] for item in JSONKey.components(separatedBy: \",\") &#123; items.append(item.replacingOccurrences(of: \" \", with: \"\")) &#125; JSONValue = json[items] &#125; let propType = PropertyType(rawValue: typeString) if let classMapping = clsMap, let pointedClass = classMapping[key] &#123; // 该属性实现了类型Map if propType == .tClass &#123; let sweetObject = Convert(JSON: JSONValue, to: pointedClass) object.setValue(sweetObject, forKey: key) continue &#125; else if propType == .tNSArray &#123; let list: Array&lt;JSON&gt; = JSONValue.arrayValue var objectArray: Array&lt;AnyObject&gt; = [] for item in list &#123; guard let arrayObject = Convert(JSON: item, to: pointedClass) else &#123; continue &#125; objectArray.append(arrayObject) &#125; object.setValue(objectArray, forKey: key) continue &#125; &#125; var value: Any? = JSONValue if propType == .tString &#123; value = JSONValue.stringValue &#125; if propType == .tInt || propType == .tInt8 || propType == .tInt16 || propType == .tInt32 || propType == .tUInt || propType == .tUInt8 || propType == .tUInt16 || propType == .tUInt32 &#123; value = JSONValue.intValue &#125; if propType == .tDouble &#123; value = JSONValue.doubleValue &#125; if propType == .tFloat &#123; value = JSONValue.floatValue &#125; if propType == .tBool &#123; value = JSONValue.boolValue &#125; if propType == .tNSArray &#123; value = JSONValue.arrayObject &#125; if propType == .tNSDictionary &#123; value = JSONValue.dictionaryObject &#125; object.setValue(value, forKey: key) &#125; &#125; /// 获得子类与父类叠加后的属性列表 public class func fullPropertyFor(class cls: AnyClass) -&gt;[String: String]? &#123; var currentCls: AnyClass = cls var infoDict = [String: String]() while let parent: AnyClass = currentCls.superclass() &#123; infoDict.merge(dict: propertyFor(class: currentCls)) currentCls = parent &#125; return infoDict &#125; /// 获取类的全部属性 public class func propertyFor(class cls: AnyClass) -&gt;[String: String]? &#123; var count: UInt32 = 0 let properties = class_copyPropertyList(cls, &amp;count) let ignoredKeys = cls.ignoredKey() ?? [] var infoDict = [String: String]() for index in 0..&lt;numericCast(count) &#123; let prop = properties?[Int(index)] let pname = String(cString: property_getName(prop)) let ptype = String(cString: property_getAttributes(prop)) var propertyRealType: PropertyType let index = ptype.index(ptype.startIndex, offsetBy: 2) if let type = PropertyType.init(rawValue: ptype.substring(to: index)) &#123; propertyRealType = type &#125; else &#123; if ptype.hasPrefix(PropertyType.tString.rawValue) &#123; propertyRealType = PropertyType.tString &#125; else if ptype.hasPrefix(PropertyType.tNSArray.rawValue) &#123; propertyRealType = PropertyType.tNSArray &#125; else if ptype.hasPrefix(PropertyType.tNSDictionary.rawValue) &#123; propertyRealType = PropertyType.tNSDictionary &#125; else if ptype.hasPrefix(PropertyType.tClass.rawValue) &#123; propertyRealType = PropertyType.tClass &#125; else &#123; propertyRealType = PropertyType.unknow &#125; &#125; if !ignoredKeys.contains(pname) &#123; infoDict[pname] = propertyRealType.rawValue &#125; &#125; free(properties) guard infoDict.count != 0 else &#123; return nil &#125; return infoDict &#125;&#125;extension Dictionary &#123; mutating func merge&lt;K, V&gt;(dict: [K: V]?) &#123; guard let d = dict, d != nil, d.count != 0 else &#123; return &#125; for (k, v) in d &#123; self.updateValue(v as! Value, forKey: k as! Key) &#125; &#125;&#125; 测试代码（测试的类在上边给出了）： 1234567891011121314151617181920212223242526272829303132let json: JSON = [\"name\": \"Jack\", \"ignored\": \"test ignored\", \"array\": [ \"1\", \"2\", \"3\", \"4\" ], \"dictionary\": [ \"2\": true, \"options\": 666, \"gender\": true ], \"student\": [ \"sname\": \"JACK\", \"sage\": 10, \"t\": [ [\"tname\": \"teacher1\"], [\"tname\": \"teacher2\"], [\"tname\": \"teacher3\"] ] ] ]let object: Person = ModelFactory.Convert(JSON: json, to: Person.self) as! Person// 使用filter答应、、let s = object.teachers.filter &#123; let teacher: Teacher = $0 print(teacher.tname) return true&#125;// 在32行之前加一个断点查看对象属性！ILog(.debug, object) 注：其实在实现Model提供Mapping的时候，期望还是使用Protocol的方式来做，但是不能解决static fun这个问题，static 代表着final class，所以会出现子类无法覆盖的问题。如果有解决方法还请告知，当然，这上边是我们自己手写的代码，在正真环境中，我还是选择了YYModel，前边仅是为了让大家了解一下转换代码。记得去掉SwiftJSON，等下我们的操作是Alamofire-&gt;YYModel-&gt;LKDBHelper，是不是很懒。 1pod 'YYModel' 明确目标2： 模型-数据库中的操作（数据库的基本语法在这里不做介绍） 说到模型-数据库中的操作，其实特别想把LKDBHelper拿来直接使用，这里比较懒，因为代码其实和上边差不多，多个数据库操作而已，所以不写了。LKDBHelper是一套OC的代码而且在Swift上测试没有问题。但是他的Demo是4个月前更新的，应该是Swift2.3版本，所以我们决定，fork一份代码并切转换到Swift3.0做测试，如果没问题，直接拿来用，以减少我们框架模块的编写时间。 好了，测试没有问题，并且提交了PR。我们现在拉过来使用，作者目前还没有合并到master，大家可以先来我的仓库查看使用的Demo。 1pod 'LKDBHelper' 这样我们JSON-模型-数据库的代码基本完成了30%。剩下的都是后期的针对业务的修改。 网络请求模块使用Alamofire，写到这里，读者肯定说我这个框架没有什么技术含量；要知道，这些库的成长经历了多少人的洗礼，而我只有3个人的小团队，创业公司的项目压力各位应该知道。所以合理的使用第三方库也是一个好的选择！如果你在一个大的团队，那么就可以为了晋升去写一点东西了。知道原理就好了，知道原理不写的原因是没有人家那么考虑的全面、构思的缜密。 新建文件Request.swift，Request对象作为在网络层流动的对象，Alamofire作为支撑。 1pod 'Alamofire' 但是你真的以为我会这么做么？这么做太麻烦了，我很懒的。我们使用Moya+Alamofire。直接上使用流程：可以选择继承INSRequest来实现自己的Request类，也可以直接下一个枚举统一管理，但是Moya这里有个问题是：实现Moya的协议必须要实现所有的方法，该协议中所有的属性全部是required（而且让我不理解的是，sampleData这种非必须数据竟然不是？，已经提了一个issue提问，因为文档没有很明确），对其中的一些属性做解释： 1pod 'Moya' 记得把开发环境调整到iOS 9.0 baseURL： 根地址 path：网络请求路径 method：网络请求方法 parameters： 参数 sampleData：默认的Response data task：当前任务的形态，一般为request，还有upload和download 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import Foundationimport Moya/// 在这里完成API的名称定义enum MMAPI &#123; case launch case signin(mobilePhoneNumber: String, password: String)&#125;/// 在这里完成API所需信息补全extension MMAPI: TargetType &#123; var baseURL: URL &#123; return URL(string: \"http://leaf.leanapp.cn/api/\")! &#125; var path: String &#123; switch self &#123; case .launch: return \"launch.json\" case .signin: return \"login\" &#125; &#125; var method: Moya.Method &#123; switch self &#123; case .signin: return .POST default: return .GET &#125; &#125; var parameters: [String: Any]? &#123; switch self &#123; case .signin(let number, let password): return [\"phone\": number, \"passwd\": password] default: return nil &#125; &#125; var sampleData: Data &#123; return Data(base64Encoded: \"\")! &#125; var task: Task &#123; return .request &#125;&#125; 在使用时候（顺便贴上官方Demo的地址）： 12345678910111213let provider = MoyaProvider&lt;MMAPI&gt;()provider.request(.launch) &#123; result in switch result &#123; case let .success(response): do &#123; if let json = try response.mapJSON() as? NSArray &#123; ILog(.debug, \"\\(json) \\n \\(response.statusCode)\") &#125; else &#123;&#125; &#125; catch &#123;&#125; case let .failure(error): ILog(.debug, error.localizedDescription) &#125; &#125; 也是看到成功了，这个时候，我们把开始写的-&gt;Model-&gt;DB顺便测试一下： 12345678910111213if let json = try response.mapJSON() as? NSDictionary &#123; // 转换成对象 let launchModel = LaunchModel.yy_model(withJSON: json) ILog(.debug, \"\\(launchModel?.imageUri) \\n \\(response.statusCode)\") // 存储到数据库 ILog(.debug, \"Save to DB result \\(launchModel?.saveToDB())\") // 查询 let searchedObject = LaunchModel.searchSingle(withWhere: nil, orderBy: nil) as! LaunchModel ILog(.debug, \"Searched result \\(searchedObject.imageUri)\") &#125; 12345⚒[DEBUG] [ViewController.swift: viewDidLoad(): 33] Save to DB result Optional(true)⚒[DEBUG] [ViewController.swift: viewDidLoad(): 36] Searched result Optional(&quot;http://static.zhaogeshi.com&quot;) 这里有一个坑大家注意： 在Swift上使用LKDB的时候，必须重写返回类名的方法： 1234567891011121314151617class LaunchModel: Model &#123; var bizUri: String? var domains: NSArray? var hotFixJS: String? var imageUri:String? var learningURL: String? var status: String? var version: String? override static func getPrimaryKey() -&gt; String &#123; return \"version\" &#125; override static func getTableName() -&gt; String &#123; return \"LaunchModel\" &#125;&#125; 否则，Swift这边读出的表名称会有问题，导致数据存储失败。 这样，借助第三方之手，我们美美的解决了领导给的2大块任务，数据模块与网络模块。依旧只能说，这2大功能模块只是提供了基础的功能，上层的封装还需要我们在接触业务的时候定制。所以这里只说，2大模块只完成了30%。 下一节开始写日志上报、异常捕获与处理、推送、位置、数据打点等。","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://wilddylan.github.io/tags/Swift/"}],"keywords":[]},{"title":"Swift语法熟悉（二）","slug":"Swift语法熟悉（二）","date":"2016-10-11T03:49:34.000Z","updated":"2017-02-04T09:02:01.000Z","comments":true,"path":"2016/10/11/Swift语法熟悉（二）/","link":"","permalink":"https://wilddylan.github.io/2016/10/11/Swift语法熟悉（二）/","excerpt":"功能编写环境管理 ModeSwitch新建ModeSwitch.swift 1234567891011121314151617181920212223242526272829import Foundation/// 开发模式public enum Mode: String &#123; /// 开发模式，打印日志，不上报日志 case develope = \"[DEVELOPE MODE]\" /// 调试模式，关闭日志打印，上报日志 case prepared = \"[PREPARED MODE]\" /// 生产模式，关闭日志打印，上报日志 case production = \"[PRODUCTION MODE]\"&#125;/// 模式控制public class INSModeSwitch &#123; /// 默认为调试模式 public static let `default` = INSModeSwitch(.develope) public var currentMode: Mode &#123; didSet &#123; &#125; &#125; /// 私有初始化方法 private init(_ mode: Mode) &#123; self.currentMode = mode &#125;&#125;/// 模式选择器public let ModeSwitcher = INSModeSwitch.default 目前这是一个极其简单的模式控制，毫无别的作用，以后扩展功能","text":"功能编写环境管理 ModeSwitch新建ModeSwitch.swift 1234567891011121314151617181920212223242526272829import Foundation/// 开发模式public enum Mode: String &#123; /// 开发模式，打印日志，不上报日志 case develope = \"[DEVELOPE MODE]\" /// 调试模式，关闭日志打印，上报日志 case prepared = \"[PREPARED MODE]\" /// 生产模式，关闭日志打印，上报日志 case production = \"[PRODUCTION MODE]\"&#125;/// 模式控制public class INSModeSwitch &#123; /// 默认为调试模式 public static let `default` = INSModeSwitch(.develope) public var currentMode: Mode &#123; didSet &#123; &#125; &#125; /// 私有初始化方法 private init(_ mode: Mode) &#123; self.currentMode = mode &#125;&#125;/// 模式选择器public let ModeSwitcher = INSModeSwitch.default 目前这是一个极其简单的模式控制，毫无别的作用，以后扩展功能 日志模块-基础日志 Console第一步我们先完成日志输出，新建Logger.swift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import Foundation/// 日志级别public enum LogLevel: String &#123; /// 打印所有类型日志 case all = \"🛢[ALL]\" /// 仅打印调试日志 case debug = \"⚒[DEBUG]\" /// 仅打印警告日志 case warning = \"❗️[WARN]\" /// 仅打印信息日志 case information = \"📢[INFO]\"&#125;final public class INSLogger &#123; /// 默认为输出全部日志 public static let `default` = INSLogger(.all) public var level: LogLevel &#123; didSet &#123; &#125; &#125; /// 日志输出 /// /// - parameter lev: 日志级别 /// - parameter content: 日志内容 public func printLog(_ lev: LogLevel, _ details: String, _ items: Any) &#123; guard level == .all || level == lev, ModeSwitcher.currentMode == .develope else &#123; return &#125; print(lev.rawValue, details, \"\\n\", items) &#125; private init(_ level: LogLevel) &#123; self.level = level &#125;&#125;/// 公开日志打印模块public let Logger = INSLogger.default/// 公开便捷调用方法public func ILog(_ lev: LogLevel, _ items: Any, _ function: StaticString = #function, _ line: Int = #line, _ file: StaticString = #file) &#123; var details = \"[\\(\"\\(file)\".components(separatedBy: \"/\").last!): \\(function): \\(line)]\" Logger.printLog(lev, details, items)&#125; 这个时候，我们对前2部分进行简单的测试： 123456789ModeSwitcher.currentMode = .developeprint(ModeSwitcher.currentMode) Logger.level = .warning ILog(.all, \"Hello world! Current Mode is \\(Logger.level)\")ILog(.debug, \"Hello world! Current Mode is \\(Logger.level)\")ILog(.warning, \"Hello world! Current Mode is \\(Logger.level)\")ILog(.information, \"Hello world! Current Mode is \\(Logger.level)\") .developer情况下会输出相应的日志，.all为输出所有日志，预发、生产模式下不会输出日志。 12🛢 [WARN] [ViewController.swift: viewDidLoad(): 24] [\"2\": \"3\", \"4\": \"5\"] 分别为文件，方法，行号，内容。 功能扩展，界面扩展一些Foundation，UIKit的扩展。新建2个文件夹，分别为FoundationExtension，UIKitExtension。在文件夹内添加这些扩展方法。这一块内容暂时省略，接着往下写功能模块。 UISDK这里我依旧支持AsyncDisplayKit，从这个库诞生我就开始一直使用，所以对于我来说，用这个比UIKit顺手： 1pod \"AsyncDisplayKit\" Foundation扩展先添加Keychain的帮助模块 1pod 'KeychainAccess' 权限服务权限服务：获得一些系统的权限，新建Permission.swift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231import Foundationimport CoreBluetoothimport AddressBook;import AVFoundation;import CoreBluetooth;import CoreLocation;import CoreMotion;import EventKit;import Photos/// 当前的状态public enum kPermissionAccess &#123; /// 用户拒绝 case denied /// 用户同意 case granted /// 系统设置拉黑等错误 case restricted /// 未知错误 case unknown /// 设备不支持 case unsupported /// 开发者没有导入相应的库 case missingFramework /// 用户没选 case notDetermined&#125;public func hasAccessToBluetoothLE() -&gt;kPermissionAccess &#123; switch CBCentralManager().state &#123; case .unsupported: return .unsupported; break; case .unauthorized: return .denied; break; default: return .granted; break; &#125;&#125;public func hasAccessToCalendar() -&gt;kPermissionAccess &#123; switch EKEventStore.authorizationStatus(for: .event) &#123; case .authorized: return .granted; break; case .denied: return .denied; break; case .restricted: return .restricted; break; case .notDetermined: return .notDetermined; break; default: return .unknown; break; &#125;&#125;public func hasAccessToContacts() -&gt;kPermissionAccess &#123; switch (ABAddressBookGetAuthorizationStatus()) &#123; case .authorized: return .granted; break; case .denied: return .denied; break; case .restricted: return .restricted; break; case .notDetermined: return .notDetermined; break; default: return .unknown; break; &#125;&#125;public func hasAccessToLocation() -&gt;kPermissionAccess &#123; switch CLLocationManager.authorizationStatus() &#123; case .authorizedAlways: return .granted; break; case .authorizedWhenInUse: return .granted; break; case .denied: return .denied; break; case .restricted: return .restricted; break; case .notDetermined: return .notDetermined; break; default: return .unknown; break; &#125;&#125;public func hasAccessToPhotos() -&gt;kPermissionAccess &#123; switch PHPhotoLibrary.authorizationStatus() &#123; case .authorized: return .granted; break; case .denied: return .denied; break; case .restricted: return .restricted; break; case .notDetermined: return .notDetermined; break; default: return .unknown; break; &#125;&#125;public func hasAccessToReminders() -&gt;kPermissionAccess &#123; switch EKEventStore.authorizationStatus(for: .reminder) &#123; case .authorized: return .granted; break; case .denied: return .denied; break; case .restricted: return .restricted; break; case .notDetermined: return .notDetermined; break; default: return .unknown; break; &#125;&#125;public typealias requestAccessHandler = (Bool?, Any?) -&gt;()public func requestAccessToCalendarWithSuccess(_ handler: @escaping requestAccessHandler) &#123; EKEventStore().requestAccess(to: .event) &#123; handler($0, $1) &#125;&#125;public func requestAccessToContactsWithSuccess(_ handler: @escaping requestAccessHandler) &#123; if let addressBook = ABAddressBookCreateWithOptions(nil, nil) &#123; ABAddressBookRequestAccessWithCompletion(addressBook as ABAddressBook!) &#123; handler($0, $1) &#125; &#125;&#125;public func requestAccessToMicrophoneWithSuccess(_ handler: @escaping requestAccessHandler) &#123; let session = AVAudioSession.sharedInstance() session.requestRecordPermission &#123; handler($0, nil) &#125;&#125;public func requestAccessToPhotosWithSuccess(_ handler: @escaping requestAccessHandler) &#123; PHPhotoLibrary.requestAuthorization &#123; if $0 == .authorized &#123; handler(true, nil) &#125; else &#123; handler(false, nil) &#125; &#125;&#125;public func requestAccessToRemindersWithSuccess(_ handler: @escaping requestAccessHandler) &#123; EKEventStore().requestAccess(to: .reminder) &#123; handler($0, $1) &#125;&#125;/// 获取位置访问权限////// - parameter whenInUse: 如果为False，则请求总是需要的权限public func requestAccessToLocationWithSuccess(_ handler: @escaping requestAccessHandler, _ whenInUse: Bool = true) &#123; let locationManager = CLLocationManager() if whenInUse, let content = Bundle.main.object(forInfoDictionaryKey: \"NSLocationWhenInUseUsageDescription\") &#123; locationManager.requestWhenInUseAuthorization() &#125; else &#123; locationManager.requestAlwaysAuthorization() &#125; handler(true, nil)&#125;public func requestAccessToMotionWithSuccess(_ handler: @escaping requestAccessHandler) &#123; let motionManager = CMMotionActivityManager() let motionQueue = OperationQueue() motionManager.startActivityUpdates(to: motionQueue) &#123;_ in handler(true, nil) motionManager.stopActivityUpdates() &#125;&#125; 可是你们忘记了，我很懒，所以这段代码不需要了，直接： 1pod 'PermissionScope' 来嗨吧！ 组件处理（核心模块）要解决的问题暂时有： 如何成为组件（实现协议与方法即可） 如何启动组件（调用组件必须实现的启动方法） 组件之间如何数据传输（实现Router模拟HTTP请求数据传递） 组件之间如何做界面跳转（利用上述Router模拟OpenURL方式调起） 组件服务如何停止（调用协议实现的方法并从组件管理中心移除注册） 规则1：只有已经注册了的组件才可以成为Router的操作对象，想成为组件则必须有单独类实现组件协议。 规则2：Router仅负责数据传递与获取视图实例（可传值，后者拥有前者的弱引用） 规则3：仅在每个模块的组件中心的代理方法中注册相应的URL供被调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import Foundation/// 数据流public typealias INSDataFlowHandler = (Any...) -&gt;Any/// 错误的Schemefileprivate let INSDataUnknowedScheme = \"INSDataUnknowedScheme_Key\"/// 插件协议public protocol INSPlugin &#123; var pluginLoaded: Bool &#123; get &#125; /// 插件唯一标识 /// - returns: 插件标识，用来获取插件 func pluginScheme() -&gt;String! // MARK: - Mappings /// 视图控制器Map /// - returns: 视图控制器的对应字典 func classMapping() -&gt;Dictionary&lt;String, AnyClass&gt;? /// 数据流Map /// - returns: 数据流字典 func dataflowMapping() -&gt;Dictionary&lt;String, INSDataFlowHandler&gt;? // MARK: - Plugin status /// 当插件注册成功的时候会调用这个方法 func serviceStarted() /// 当插件取消注册的时候会调用这个方法 func serviceStopped()&#125;extension INSPlugin &#123; /// 插件加载状态 public var pluginLoaded: Bool &#123; return (ModuleCenter.getPlugin(for: pluginScheme()) != nil) &#125;&#125;/// 插件基类，成为模块插件管理器则必须继承该类，并实现方法open class Plugin: INSPlugin &#123; final public func registePlugin() &#123; ModuleCenter.registePlugin(self) &#125; final public func deRegistePlugin() &#123; ModuleCenter.deRegistePlugin(self) &#125; open func pluginScheme() -&gt; String! &#123; return nil &#125; open func serviceStopped() &#123;&#125; open func serviceStarted() &#123;&#125; open func dataflowMapping() -&gt;Dictionary&lt;String, INSDataFlowHandler&gt;? &#123; return nil &#125; open func classMapping() -&gt;Dictionary&lt;String, AnyClass&gt;? &#123; return nil &#125; public init() &#123; // I'm a plug-in manager 🏵 &#125;&#125;/// 插件控制中心final public class ModuleManager: NSObject &#123; public static let `default` = ModuleManager() /// 已经加载的插件 private(set) var loadedPlugins: Dictionary&lt;String, Plugin&gt; = [:] /// 注册新的插件 @discardableResult public func registePlugin(_ item: Plugin) -&gt;Bool &#123; guard let scheme = item.pluginScheme(), loadedPlugins[scheme] == nil else &#123; return false &#125; loadedPlugins[scheme] = item /// 注册组件 item.serviceStarted() return true &#125; /// 取消注册插件 public func deRegistePlugin(_ item: Plugin) &#123; guard let scheme = item.pluginScheme() else &#123; return &#125; loadedPlugins.removeValue(forKey: scheme) /// 移除组件 item.serviceStopped() &#125; /// 根据唯一标识获取插件 public func getPlugin(for scheme: String) -&gt;Plugin? &#123; return loadedPlugins[scheme] &#125; /// 数据流 @discardableResult public func send(to url: String, and param: Any...) -&gt;Any? &#123; let (scheme, host) = validateURL(url) guard let pluginItem = getPlugin(for: scheme!), let dataMapping = pluginItem.dataflowMapping() else &#123; ILog(.warning, \"找不到scheme对应的插件或插件没有dataMapping!\") return nil &#125; guard let sendHandler = dataMapping[host!] else &#123; ILog(.warning, \"该路径没有对应的Handler\") return nil &#125; return sendHandler(param) &#125; /// 视图流 @discardableResult public func `class`(for url: String) -&gt;AnyClass? &#123; let (scheme, host) = validateURL(url) guard let pluginItem = getPlugin(for: scheme!), let dataMapping = pluginItem.classMapping() else &#123; ILog(.warning, \"找不到scheme对应的插件或插件没有classMapping!\") return nil &#125; return dataMapping[host!] &#125; @discardableResult private func validateURL(_ url:String) -&gt;(String?, String?) &#123; guard let URLObject = URL(string: url), let scheme = URLObject.scheme else &#123; ILog(.warning, \"输入的url不能转换为URL对象或URL对象没有Scheme!\") return (INSDataUnknowedScheme, \"\") &#125; return (scheme, URLObject.host) &#125; private override init() &#123; // I'm a module manager 🏵 &#125;&#125;public let ModuleCenter = ModuleManager.default 接下来，我们实现一个小的插件继承自Plugin并实现一些代理方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import UIKitclass NetworkPlugin: Plugin &#123; override func serviceStarted() &#123; ILog(.debug, \"Network service started\") &#125; override func serviceStopped() &#123; ILog(.debug, \"Network service stopped\") &#125; override func pluginScheme() -&gt; String! &#123; return \"Network\" &#125; override func dataflowMapping() -&gt;Dictionary&lt;String, INSDataFlowHandler&gt;? &#123; let mapping: [String: INSDataFlowHandler] = [ \"getData\": &#123; ILog(.warning, \"receive call \\($0)\") return \"Custom data\" &#125;, \"supportMethod\": &#123; ILog(.warning, \"receive call \\($0)\") return [ \"GET\", \"POST\", \"PUT\", \"DELETE\" ] &#125; ] return mapping &#125; override func classMapping() -&gt; Dictionary&lt;String, AnyClass&gt;? &#123; let mapping: [String: AnyClass] = [ \"vc1\": UIViewController.self, \"vc2\": NSObject.self ] return mapping &#125; static let `default` = NetworkPlugin()&#125; 然后在ViewController.swift中测试： 123456789101112ModeSwitcher.currentMode = .developeLogger.level = .all let sharedNetwork = NetworkPlugin.defaultsharedNetwork.registePlugin() ILog(.information, ModuleCenter.send(to: \"Network://getData\", and: \"Hello World\"))ILog(.information, ModuleCenter.send(to: \"Network://supportMethod\", and: \"Hello World\", \"Hello real world!\", [\"a\": \"b\"]))ILog(.information, ModuleCenter.class(for: \"Network://vc1\"))ILog(.information, ModuleCenter.class(for: \"Network://vc2\")) sharedNetwork.deRegistePlugin() 看到输出为： 说明功能已经基本的完成了。这里并没有将打开界面写入到当前模块，还是感觉直接获取类好一点，所以直接把OpenURL的方式改成了获取类型，然后由使用者自己去创建对象分情况使用，这样自定义的程度也高一点。 如果写为OpenURL的方式，那我们又要分很多种了，push还是present，是否需要导航，考虑到仅获取不使用的情况，要写控制器基类，还有必要统一一个初始化方法供使用。但是这些似乎已经不是一个框架应该做的事情了（仅鉴于我对Swift框架的理解，框架不干涉业务，框架不干涉UI）。 文章篇幅过长并且均为代码，所以本文只写到这里。 下篇文章会开始编写数据模块、网络模块。","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://wilddylan.github.io/tags/Swift/"}],"keywords":[]},{"title":"Swift语法熟悉（一）","slug":"Swift语法熟悉（一）","date":"2016-10-09T10:56:43.000Z","updated":"2017-02-04T09:01:47.000Z","comments":true,"path":"2016/10/09/Swift语法熟悉（一）/","link":"","permalink":"https://wilddylan.github.io/2016/10/09/Swift语法熟悉（一）/","excerpt":"知识储备就像从零搭建OC项目Service支撑一样，要在一定量知识储备的情况下才可以让框架质量得到保证。 Service：项目支撑服务。每个公司的项目都会依赖一定量的组件，每一个组件作为项目的独立模块提供本身的功能供使用。一般来讲，大公司的项目均为组件化项目，一方面为了方便安排开发，另一方面方面集成管理与扩展。小公司的项目则是依赖某一个私有库作为项目的支撑。建议每一个项目都按照组件化项目的思想来从零构造，便于以后核心服务代码抽出进行组件化拆分。 Swift知识储备与框架需求知识储备即熟悉Swift编码思想，基础知识，进阶知识与细节知识，这里不做赘述。编码能力不能做衡量，即便知识储备不够，也可以慢慢的学习。给出的建议是：多阅读源码，不是大型开源项目的源码，而是小而精的功能性项目源码。","text":"知识储备就像从零搭建OC项目Service支撑一样，要在一定量知识储备的情况下才可以让框架质量得到保证。 Service：项目支撑服务。每个公司的项目都会依赖一定量的组件，每一个组件作为项目的独立模块提供本身的功能供使用。一般来讲，大公司的项目均为组件化项目，一方面为了方便安排开发，另一方面方面集成管理与扩展。小公司的项目则是依赖某一个私有库作为项目的支撑。建议每一个项目都按照组件化项目的思想来从零构造，便于以后核心服务代码抽出进行组件化拆分。 Swift知识储备与框架需求知识储备即熟悉Swift编码思想，基础知识，进阶知识与细节知识，这里不做赘述。编码能力不能做衡量，即便知识储备不够，也可以慢慢的学习。给出的建议是：多阅读源码，不是大型开源项目的源码，而是小而精的功能性项目源码。 框架需求：按照开发步骤 [ ] 环境管理 ModeSwitch 控制当前环境，开发，预发，正式 [ ] 日志模块-基础日志 Console 完成基础日志模块，日志打印即可 [ ] 功能扩展 Foundation Foundation常用的扩展 [ ] 界面扩展 UIKit UIKit常用的扩展 [ ] 权限服务 Permission 获得应用程序权限 [ ] 组件处理/链接模块 Plug-in 组件化方案，组件加载，组件衔接（Router） [ ] 数据模块 DataBase 数据持久层，暂定使用数据库 [ ] 网络模块 Network 网络层，网络请求，缓存控制，图片缓存等 [ ] 日志模块-日志上报 Console 完成日志上报功能（一般为奔溃上报） [ ] 推送服务 Push 远程推送与本地推送服务 [ ] 位置服务 Location 位置获取服务 [ ] 数据收集服务 Monitor 数据打点与用户信息上报等 规范、知识 （仅了解基础的开发者阅读&lt;知识回顾&gt;）别急着入手写代码，先制定一系列的规范，了解一些知识。 规范Swift版本：3.0 Xcode版本：8.0+ 支撑版本：iOS 8.0+ 缩进： 2 单例写法与命名规范： 闭包预定义： 函数参数与规范： 使用 _来忽略参数描述，使用@discardableResult来标记该函数可以忽略返回值，尽量不要使用关键字。尽量避免函数复杂程度（不要写内部函数等）。命名明确，可选参数要写默认值。 注释规范： 1// MARK: Initializing 1234/// Returns a matched view controller from a specified URL.////// - parameter url: The URL to find view controllers./// - returns: A match view controller or `nil` if not matched. MARK、TODO等使用//开头，默认注释使用///开头。 好的规范可以提高代码的可读性与统一性 上边只是一些简单的规范。还有很多好的建议，我们慢慢聊。 知识 空值合并 a ?? b 中的 ?? 就是是空值合并运算符，会对 a 进行判断，如果不为 nil 则解包，否则就返回 b 。使用的时候有以下两点要求： a 必须是 optional 的 b 必须和 a 类型一致 当然如果你觉得这样可读性不高，我们可以自定义运算符来实现 1234567891011121314infix operator |-&gt;| &#123;&#125;func |-&gt;|&lt;T&gt; (left: T?, right: T) -&gt;T &#123; if let l = left &#123; return l &#125; return right&#125;var a: String?var b = \"Hello world!\"var c = a |-&gt;| b 关于字符串 String传递的时候会进行拷贝，NSString通常为引用，使用countElements计算String数量与同样NSString.length计算的结果可能不同，因为 length 利用的是 UTF-16 类型的值，而不是 Unicode 字符。比如 emoji 表情加进去之后，UTF-16 算的结果是2，而 Unicode 的计算结果是1。 数组 除了普通的初始化方法，我们可以通过 init(count: Int, repeatedValue: T) 来初始化一个数组并填充上重复的值： 12// [0.0, 0.0, 0.0]var threeDoubles = [Double](repeating:0.0, count:3) 按某种规则获得新数组，使用map方法 12345var oldArray = [10, 20, 30, 40]var newArray = oldArray.map &#123; (money: Int) in \"￥\\(money)\"&#125;print(newArray) 当然也可以简写 1var newArray = oldArray.map(&#123; \"￥\\($0)\" &#125;) 数组过滤： 12345678var oldArray = [10, 20, 45, 32]var filteredArray : Array&lt;Int&gt; = []for money in oldArray &#123; if (money &gt; 30) &#123; filteredArray += [money] &#125;&#125;print(filteredArray) 不过这个方法看起来很笨重，我们使用新方法 123var filtered = oldArray.filter &#123; return $0 &gt; 30&#125; 计算数组的和 12let array: Array&lt;Int&gt; = [10, 20, 30, 40]var result = array.reduce(0, +) 解包技巧： 12345678910111213141516171819func add(_ num: Int?) -&gt;Int? &#123; if let n = num &#123; return n + 1 &#125; else &#123; return nil &#125;&#125;add(1)add(nil)// -&gt; Mapfunc madd(_ num: Int?) -&gt;Int? &#123; return num.map &#123;n in n + 1&#125;&#125;madd(1)madd(nil) 字符串也可以进行容错 12345678func madd(_ s: String?) -&gt;String &#123; return s.map&#123; sss in \"Hello \\(sss)!\" &#125; ?? \"default value\"&#125;madd(\"c\")madd(nil) Switch中巧用where 123456789101112let point = (1, -1)switch point &#123;case let (x, y) where x == y: print(\"1\") breakcase let (x, y) where x == -y: print(\"2\") breakdefault: break&#125; fallthrough - 在 switch 中，将代码引至下一个 case 而不是默认的跳出 switch。不过要注意的是，fallthrough不能用在定义了变量的case内，只能用在直接的判断中 控制流语法大全 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// for loop (array)let myArray = [1, 1, 2, 3, 5]for value in myArray &#123; if value == 1 &#123; println(\"One!\") &#125; else &#123; println(\"Not one!\") &#125;&#125;// for loop (dictionary)var dict = [ \"name\": \"Steve Jobs\", \"title\": \"CEO\", \"company\": \"Apple\"]for (key, value) in dict &#123; println(\"\\(key): \\(value)\")&#125;// for loop (range)for i in -1...1 &#123; // [-1, 0, 1] println(i)&#125;// use .. to exclude the last number// for loop (ignoring the current value of the range on each iteration of the loop)for _ in 1...3 &#123; // Do something three times.&#125;// while loopvar i = 1while i &lt; 1000 &#123; i *= 2&#125;// do-while loopdo &#123; println(\"hello\")&#125; while 1 == 2// Switchlet vegetable = \"red pepper\"switch vegetable &#123;case \"celery\": let vegetableComment = \"Add some raisins and make ants on a log.\"case \"cucumber\", \"watercress\": let vegetableComment = \"That would make a good tea sandwich.\"case let x where x.hasSuffix(\"pepper\"): let vegetableComment = \"Is it a spicy \\(x)?\"default: // required (in order to cover all possible input) let vegetableComment = \"Everything tastes good in soup.\"&#125;// Switch to validate plist contentlet city:Dictionary&lt;String, AnyObject&gt; = [ \"name\" : \"Qingdao\", \"population\" : 2_721_000, \"abbr\" : \"QD\"]switch (city[\"name\"], city[\"population\"], city[\"abbr\"]) &#123; case (.Some(let cityName as NSString), .Some(let pop as NSNumber), .Some(let abbr as NSString)) where abbr.length == 2: println(\"City Name: \\(cityName) | Abbr.:\\(abbr) Population: \\(pop)\") default: println(\"Not a valid city\")&#125; 函数 可选的参数请提供默认值 12345func add(_ a: Int = 1, _ b: Int = 2) -&gt;Int &#123; return a + b&#125;add(3) // 3 + 2 可变参数 12345func add(nums: Int ...) -&gt;Int &#123; return nums.reduce(0, +)&#125;add(nums: 1, 2, 3, 4, 5) // 15 如果不止一个参数，需要把可变参数放在最后，否则会报错。 通过函数修改原始值需要 inout ： 1234567func add( v:inout Int) &#123; v = v + 1&#125;var a = 1add(v: &amp;a) 泛型函数： 123456789101112131415161718192021func value&lt;T&gt;( value1:inout T, oldValue: inout T) &#123; let temp = value1 value1 = oldValue oldValue = temp&#125;var n1 = \"mr r\"var n2 = \"ms s\"value(value1: &amp;n1, oldValue: &amp;n2)print(n1)print(n2)var i1 = 1var i2 = 2value(value1: &amp;i1, oldValue: &amp;i2)print(i1)print(i2) 变量： 1234567func functionAdd(_ a: Int) -&gt;Int &#123; return a + 2&#125;let funcalias = functionAddfuncalias(2) 函数既然是类型的一种，那么显然也是可以作为参数传递的： 123456789func addFunc(_ a: Int) -&gt;Int &#123; return a + 3&#125;func withFunc(addingFunc: (Int) -&gt;Int, a: Int) &#123; print(\"R: \\(addingFunc(a))\")&#125;withFunc(addingFunc: addFunc, a: 4) // 7 函数也是可以作为结果返回的。比如返回的值是一个参数为 Int 返回值为 Int 的函数，就是这样定义：func foo() -&gt; (Int) -&gt; Int 1234567891011121314func add(a: Int) -&gt;Int &#123; return a + 1&#125;func rev(a: Int) -&gt;Int &#123; return a - 1&#125;func choose(a2r: Bool) -&gt; (Int) -&gt;Int &#123; return a2r ? add: rev&#125;let functionForUse = choose(a2r: false)functionForUse(3) // rev 2 用多了会发现在一大串 ()-&gt; 中又穿插各种 ()-&gt; 是一个非常蛋疼的事情。我们可以用 typealias 定义函数别名，其功能和 OC 中的 typedef 以及 shell 中的 alias 的作用基本是一样的： 12345678910111213typealias handler = (Bool, String) -&gt;Stringfunc requetsWithHandler (_ completeHandler: handler) -&gt; String &#123; return completeHandler(false, \"Hello\")&#125;requetsWithHandler &#123; (a:Bool, s:String) -&gt; String in if a &#123; return s &#125; else &#123; return \"World!\" &#125;&#125; 函数嵌套： 123456789101112131415func choose(a2r: Bool) -&gt; (Int) -&gt;Int &#123; func add(a: Int) -&gt;Int &#123; return a + 1 &#125; func rev(a: Int) -&gt;Int &#123; return a - 1 &#125; return a2r ? add: rev&#125;let functionForUse = choose(a2r: true)functionForUse(3) 柯里化（简单提及）文 1234567891011func add(b:Int)(a:Int) -&gt; Int&#123; return a + b ;&#125;let addOne = add(1)let addTwo = add(2)var a = 0a = addOne(a: a) // 1a = addTwo(a: a) // 3 闭包 闭包的完整形态是这个样子的： 1&#123;(parameters) -&gt; (returnType) in statements&#125; 闭包有3种形态 全局的函数都是闭包，它们有自己的名字，但是没有捕获任何值。 内嵌的函数都是闭包，它们有自己的名字，而且从包含他们的函数里捕获值。 闭包表达式都是闭包，它们没有自己的名字，通过轻量级的语法定义并且可以从上下文中捕获值。 我们可以直接用 $0 $1 $2 这种来依次定义闭包的参数。比如 sorted 函数： 1var reversed = sorted([\"c\",\"a\",\"d\",\"b\"], &#123; $0 &gt; $1 &#125;) // d c b a 如果闭包是函数的最后一个参数，Swift 提供了尾随闭包 (Trailing Closures) 解决这个审美问题： 123456789// 以下是不使用尾随闭包进行函数调用someFunc(0, &#123; // 闭包主体部分&#125;)// 以下是使用尾随闭包进行函数调用someFunc(0) &#123; // 闭包主体部分&#125; 使用尾随，之前的函数改写为： 1var reversed = sorted([\"c\",\"a\",\"d\",\"b\"]) &#123; $0 &gt; $1 &#125; // d c b a 如果除了闭包没有其他参数了，甚至可以把小括号也去掉。 12345var oldArray = [10, 20, 30, 40]var filteredArray = oldArray.filter&#123; return $0 &gt; 30&#125; closure 的变形大致有以下几种形态： 123456[1, 2, 3].map( &#123; (i: Int) -&gt;Int in return i * 2 &#125; )[1, 2, 3].map( &#123; i in return i * 2 &#125; )[1, 2, 3].map( &#123; i in i * 2 &#125; )[1, 2, 3].map( &#123; $0 * 2 &#125; )[1, 2, 3].map() &#123; $0 * 2 &#125;[1, 2, 3].map &#123; $0 * 2 &#125; 一个活生生的例子： 12345678910var canvas = UIView(frame: CGRect(x: 0, y: 0, width: 50, height: 50))canvas.backgroundColor = UIColor.redUIView.animate(withDuration: 4, animations: &#123; canvas.backgroundColor = UIColor.blue&#125;) &#123; print(\"Result \\($0)\")&#125;PlaygroundPage.current.liveView = canvas 常见形态 1234567891011121314151617181920212223242526272829303132// 作为变量var closureName: (parameterTypes) -&gt; (returnType)// 作为可选类型的变量var closureName: ((parameterTypes) -&gt; (returnType))?// 做为一个别名typealias closureType = (parameterTypes) -&gt; (returnType)// 作为函数的参数func(&#123;(parameterTypes) -&gt; (returnType) in statements&#125;)// 作为函数的参数array.sort(&#123; (item1: Int, item2: Int) -&gt; Bool in return item1 &lt; item2 &#125;)// 作为函数的参数 - 隐含参数类型array.sort(&#123; (item1, item2) -&gt; Bool in return item1 &lt; item2 &#125;)// 作为函数的参数 - 隐含返回类型array.sort(&#123; (item1, item2) in return item1 &lt; item2 &#125;)// 作为函数的参数 - 尾随闭包array.sort &#123; (item1, item2) in return item1 &lt; item2 &#125;// 作为函数的参数 - 通过数字表示参数array.sort &#123; return $0 &lt; $1 &#125;// 作为函数的参数 - 尾随闭包且隐含返回类型array.sort &#123; $0 &lt; $1 &#125;// 作为函数的参数 - 引用已存在的函数array.sort(&lt;) 枚举 Swift 中的相关值有点像是 F# 中的 Discriminated Unions，它允许在枚举中存储额外的数据。 123456789101112131415enum BarCode &#123; case UPCA(Int, Int) case QRCode(String)&#125;var productBar = BarCode.QRCode(\"abc\")productBar = .UPCA(1, 2)switch productBar &#123;case .UPCA(let a, let b): print(\"\\(a) \\(b)\") breakdefault: break&#125; Swift代码块 懒加载 1234567891011121314class Person &#123; var name: String lazy var greeting: String = &#123; [unowned self] in return \"Hello, \\(self.name)!\" &#125;() init(name: String) &#123; self.name = name &#125;&#125;var p = Person(name: \"World!\")p.greeting 123456789101112131415class ViewController: UIViewController &#123; lazy var animator: UIDynamicAnimator = &#123; return UIDynamicAnimator(referenceView: self.view) &#125;() required init?(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) &#125; override func viewDidLoad() &#123; super.viewDidLoad() animator.addBehavior(UIGravityBehavior()) &#125;&#125; 其他类型 Any 可以表示任何类型 AnyObject 可以代表任何class类型的实例 类型设计 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import Foundationenum Github &#123; case Zen case UserProfile(String)&#125;protocol Path &#123; var path : String &#123; get &#125;&#125;extension Github : Path &#123; var path: String &#123; switch self &#123; case .Zen: return \"/zen\" case .UserProfile(let name): return \"/users/\\(name)\" &#125; &#125;&#125;let sample = Github.UserProfile(\"ashfurrow\")println(sample.path) // Prints \"/users/ashfurrow\"// So far, so goodprotocol Moya : Path &#123; var baseURL: NSURL &#123; get &#125; var sampleData: String &#123; get &#125; // Probably JSON would be better than AnyObject&#125;extension Github : Moya &#123; var baseURL: NSURL &#123; return NSURL(string: \"https://api.github.com\")! &#125; var sampleData: String &#123; switch self &#123; case .Zen: return \"Half measures are as bad as nothing at all.\" case .UserProfile(let name): return \"&#123;login: \\\"\\(name)\\\", id: 100&#125;\" &#125; &#125;&#125;func url(route: Moya) -&gt; NSURL &#123; return route.baseURL.URLByAppendingPathComponent(route.path)&#125;println(url(sample)) // prints https://api.github.com/users/ashfurrow 插曲：实践一下写个动画 大部分知识块儿内容来自这个粗心的开发者，不过我很喜欢 熟悉并回顾了这些杂乱的东西之后，都跃跃欲试了吧？下篇文章开始正式的写代码。","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://wilddylan.github.io/tags/Swift/"}],"keywords":[]},{"title":"IAP","slug":"IAP","date":"2016-09-23T02:08:53.000Z","updated":"2017-02-04T09:02:06.000Z","comments":true,"path":"2016/09/23/IAP/","link":"","permalink":"https://wilddylan.github.io/2016/09/23/IAP/","excerpt":"前言：应用内支付（IAP）一直是苹果尽力强迫大家使用的在线支付方式, 用以获利。 进入主题，如何将IAP继承至自己的应用中。我们使用到了开源库APKit，github地址： APKit的Github仓库主页，包含了本地校验。 准备In-App Purchase， 简称IAP，允许在iOS app与macOS app中出售商品，如果你想将IAP加入自己的应用中，需要在集成之前做一些配置，下边将会一步一步的教大家配置相关的信息。 IAP在iOS 3.0 和 macOS 10.7之后有效。 Agreements, Tax, and Banking Information必须完成以下步骤：","text":"前言：应用内支付（IAP）一直是苹果尽力强迫大家使用的在线支付方式, 用以获利。 进入主题，如何将IAP继承至自己的应用中。我们使用到了开源库APKit，github地址： APKit的Github仓库主页，包含了本地校验。 准备In-App Purchase， 简称IAP，允许在iOS app与macOS app中出售商品，如果你想将IAP加入自己的应用中，需要在集成之前做一些配置，下边将会一步一步的教大家配置相关的信息。 IAP在iOS 3.0 和 macOS 10.7之后有效。 Agreements, Tax, and Banking Information必须完成以下步骤： 在创建IAP之前必须要先同意最近的开发者协议（Developer Program License Agreement）。 完成一些必须的信息：协议、税务、银行信息。更多关于协议、税务、银行的资料。 第一步，打开 https://developer.apple.com/account，如果协议有更新的话, 需要先同意最新的协议： 第二部，打开https://itunesconnect.apple.com，点击协议、税务与银行，编辑并完成信息： 通常我们对Contact info，Bank info，Tax info进行编辑，我这里已经有了合同号，新用户打开界面后，合同号为空。完善这一部分信息比较杂乱，而本文的重点还是在集成，所以协议税务和银行这里大家参考配置协议、税务、银行的信息来完成。 Certificates, Identifiers &amp; Profiles配置IAP应用的App ID与描述文件，必须完成以下步骤： 注册一个新的App ID（这一部分对于iOS开发者来说不需要赘述，小白参考官网关于这一部分的介绍）。 注册一个App ID为com.hack.app的应用。目前创建的App ID默认是勾选了IAP。 iTunes Connect为了后续测试IAP，需要创建商品以及用于测试的帐号，iTunes Connect提供了这些操作，需要完成以下步骤： 创建测试账户 苹果提供的测试环境，被称为沙箱（sandbox），可用来对IAP应用进行测试，模拟真实交易流程。不明真像的吃瓜群众可以看一下如何创建Sandbox tester。 创建IAP商品 手先创建一个App，然后才可以为该App创建内购商品。依旧，小白用户看一下如何创建内购商品。 再次动手实践： 步骤1： 打开iTunes Connect，点击用户和职能，Tab栏点击沙箱技术测试员，点击+号添加； 比较坑的事是已经注册成为苹果用户的邮箱帐号在这里会被显示为占用。 步骤2：创建新的App，并且创建新的内购商品； 建议读一下内购商品的区别与创建这篇官方文档。 套装ID选择刚创建的App ID，SKU是一个你希望的唯一App的标识，不会出现在AppStore中。 创建成功之后，Tab选择功能，默认选中的项目就是App内购项目，点击添加之后，会先弹窗告诉你内购商品的4中类型的特性，选择一种，一般游戏币充值类似的选择消耗类；游戏场景开通类似的选择非消耗类；陌陌会员类似的选择自动续订，每月自动扣费；VPN年限内有效类似的选择非续订。 选择创建消耗类项目，进入创建界面后，每一个项目后边都有一个查看提示信息的问号。审核信息以及审核信息暂时不需要配置，在提交App审核之前，需要先提交内购商品审核，那个时候再上传截图也可以。产品的ID一般存储与服务器中，App从服务器获取到商品列表之后进行选择购买。 创建2个商品供未来测试购买。 至此，准备工作告一段落，接下来进入集成工作。 集成完成以下步骤 创建新的Xcode工程，使用OC作为开发语言。 修改bundleIdentifier为我们创建的App ID。 配置需要的证书以及描述文件，但是在Xcode8中为了测试便捷，自动管理。 打开IAP功能支持。 编码前须知。 完成步骤1，2，3： 这里作者使用的Xcode8，Xcode7.3界面与稍有区别。 完成步骤4： 步骤5，须知： 注：macOS开发需在didFinishLaunch要先获取一下凭证 123if ( ![NSData dataWithContentsOfURL:[NSBundle mainBundle].appStoreReceiptURL] ) &#123; exit(173);&#125; 如果不存在的话直接让程序退掉就好了。 注：测试之前，先退出当前登录的AppStore帐号，选择真机测试，需要支付的时候登录配置好的测试帐号。 编码工程目录下，pod init，Podfile中加入 1pod \"APKit\", \"~&gt;1.1\" 执行pod update --no-repo-update，如果是第一次使用，pod install --no-repo-update。 STEP1打开AppDelegate.m配置APKit接收商店购买回调： 12#import &lt;StoreKit/StoreKit.h&gt;#import &lt;APKit/APKit.h&gt; 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;#warning Add transaction observer [[SKPaymentQueue defaultQueue] addTransactionObserver:[APStoreObserver sharedInstance]]; return YES;&#125; 1234- (void)applicationWillTerminate:(UIApplication *)application &#123;#warning Remove transaction observer [[SKPaymentQueue defaultQueue] removeTransactionObserver: [APStoreObserver sharedInstance]];&#125; 设置与移除监听，要在购买操作之前。 STEP2设置商品获取与商品购买结果监听（这里是测试，所以放到了一起）： 123456789101112131415- (instancetype)init &#123; self = [super init]; if ( self ) &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleProductRequestNotification:) name:APProductRequestNotification object:[APProductManager sharedInstance]]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handlePurchasesNotification:) name:APPurchaseNotification object:[APStoreObserver sharedInstance]]; &#125; return self;&#125; 第一个监听会在收到iTunes Connect商品获取成功之后，第二个监听是支付或者恢复购买的结果。 SETP3请求商品，这里建议从服务器获取商品唯一标识，然后请求。这里测试写的是上边创建的ID，并写了一个不存在的商品标识以供测试（01， 02存在，03不存在）。 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; NSArray *productIdentifiers = @[ @&quot;1994101101&quot;, @&quot;1994101102&quot;, @&quot;1994101103&quot; ]; APProductManager *productManager = [APProductManager sharedInstance]; [productManager fetchProductInformationForIds:productIdentifiers];&#125; fetchProductInformationForIds即根据商品唯一标识获取商品信息。在通知里我们可以收到一些信息： 123456789-(void)handleProductRequestNotification: (NSNotification *)notification &#123; APProductManager *productRequestNotification = (APProductManager*)notification.object; APProductRequestStatus result = (APProductRequestStatus)productRequestNotification.status; if (result == APProductRequestSuccess) &#123; NSLog(@&quot;VALID: %@&quot;, productRequestNotification.availableProducts); NSLog(@&quot;INVALID: %@&quot;, productRequestNotification.invalidProductIds); &#125;&#125; VALID: 可以使用的数组 INVALID：不正确的商品标识 1994101103不是正确的标识。 STEP4发起购买请求： 1234567NSArray *productArray = productRequestNotification.availableProducts;if ( productArray.count &gt; 0 ) &#123; SKProduct *product_1 = productArray.firstObject; APStoreObserver *storeObs = [APStoreObserver sharedInstance]; [storeObs buy:product_1];&#125; 使用buy方法轻松的开始购买商品，要注意的是，一定要先设置APStoreObserver为IAP的处理（在AppDelegate.m中的设置，当然也可以在你需要的位置），并设置结果监听（在上边的init方法中）。 在通知里我们可以收到一些信息： 123456789101112131415161718192021222324252627282930313233343536373839#pragma mark - Handle purchase notification-(void)handlePurchasesNotification: (NSNotification *)notification &#123; APStoreObserver *purchasesNotification = (APStoreObserver *)notification.object; APPurchaseStatus status = (APPurchaseStatus)purchasesNotification.status; switch ( status ) &#123;#pragma - Purchase case APPurchaseSucceeded: &#123; NSLog(@&quot;Purchase-Success: %@&quot;, purchasesNotification.productsPurchased); // Verify receipts step. [self verifyReceipts]; break; &#125; case APPurchaseFailed: &#123; NSLog(@&quot;Purchase-Failed %@&quot;, purchasesNotification.errorMessage); break; &#125; case APPurchaseCancelled: &#123; NSLog(@&quot;Purchase-Cancelled!&quot;); break; &#125;#pragma - Restore case APRestoredSucceeded: &#123; NSLog(@&quot;Restored-Success: %@&quot;, purchasesNotification.productsRestored); break; &#125; case APRestoredFailed: &#123; NSLog(@&quot;Restored-Failed %@&quot;, purchasesNotification.errorMessage); break; &#125; case APRestoredCancelled: &#123; NSLog(@&quot;Restored-Cancelled!&quot;); break; &#125; default: break; &#125;&#125; 这些枚举值都很清晰的表达了意思，不做赘述。需要注意的是第12行[self verifyReceipts];，这个是很重要的一步，用于验证凭证（验证是否合法的完成的购买）。 STEP5凭证验证： 在macOS中，凭证有可能丢失 1NSURL *localReceiptURL = [[NSBundle mainBundle] appStoreReceiptURL]; URL是否存在的判断，在文章准备工作的步骤5中有提到过。 目前，在iPhone非越狱设备下，我没有碰到过凭证丢失的情况（我们直接抛弃了越狱用户）。所以文中不做赘述。 凭证校验出错可以使用SKReceiptRefreshRequest刷新，阅读SKReceiptRefreshRequest官方文档。 获得凭证： 123NSURL *localReceiptURL = [[NSBundle mainBundle] appStoreReceiptURL];NSData *data = [NSData dataWithContentsOfURL:localReceiptURL];NSString *receiptStr = [data base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed]; 将receiptStr发送到服务器，由服务器与苹果通信进行验证。 这里提供2种验证路径： 通过与苹果通信进行验证，还没有了解过的开发小伙伴阅读一下验证相关的文档。 服务器做本地验证，实现苹果验证的规则，没有了解过的小伙伴了解一下用python做本地凭证校验。这种校验方式是可以直接用到生产环境的，某知名公司已经在使用了，这是取来的经，放心尝试吧。我把它Fork到了自己的仓库里，希望各路的服务端大牛可以依据思路贡献多个版本的本地验证库，我也会抽时间用Node.js实现一遍以供使用。 验证的参考文章，也涵盖了基础的一些配置以及基本的编码等等。 结语至此，IAP开发结束了，感谢大家的阅读。","categories":[],"tags":[{"name":"支付与IAP","slug":"支付与IAP","permalink":"https://wilddylan.github.io/tags/支付与IAP/"}],"keywords":[]},{"title":"CFNetwork","slug":"CFNetwork","date":"2016-08-31T08:01:14.000Z","updated":"2017-02-04T09:02:11.000Z","comments":true,"path":"2016/08/31/CFNetwork/","link":"","permalink":"https://wilddylan.github.io/2016/08/31/CFNetwork/","excerpt":"CFNetwork存在于CoreFoundation中的一个地级别但高性能的网络框架。BSD套接字的扩展，CFNetwork物理上和理论上都基于BSD套接字。有大量的Cocoa框架依赖于CFNetwork。 CFNetwork更侧重与网络协议，Foundation则更倾向于API数据请求等，虽然框架也提供了一些操作，但是远不如CFNetwork丰富。在学习CFNetwork之前，需要先了解2个基础API框架： CFSocket、CFStream。 CFSocket API套接字是网络通信的底层，一个套接字类似于电话的插孔，他允许链接到另外一个电话插孔并传输一些信息过去。最常见的套接字是BSD套接字。CFSocket是BSD套接字的一个抽象概念，在很小开销的情况下，几乎提供了全部BSD套接字的功能，并将套接字集成到一个Loop中。并且，CFSocket可以处理任何类型的套接字。","text":"CFNetwork存在于CoreFoundation中的一个地级别但高性能的网络框架。BSD套接字的扩展，CFNetwork物理上和理论上都基于BSD套接字。有大量的Cocoa框架依赖于CFNetwork。 CFNetwork更侧重与网络协议，Foundation则更倾向于API数据请求等，虽然框架也提供了一些操作，但是远不如CFNetwork丰富。在学习CFNetwork之前，需要先了解2个基础API框架： CFSocket、CFStream。 CFSocket API套接字是网络通信的底层，一个套接字类似于电话的插孔，他允许链接到另外一个电话插孔并传输一些信息过去。最常见的套接字是BSD套接字。CFSocket是BSD套接字的一个抽象概念，在很小开销的情况下，几乎提供了全部BSD套接字的功能，并将套接字集成到一个Loop中。并且，CFSocket可以处理任何类型的套接字。 CFStream API读写流，提供一种简单的方法进行媒体数据的交换，与设备无关。你可以为内存中、文件中或者网络中的数据创建流，并且你可以在不把数据加载到内存中的情况下使用流。流是一个字节序列串行传输的通信路径，流是单向的，通常情况下，为了双向通信，需要输入（CFReadStream）、输出流（CFWriteStream）。除了基于文件的流，你不能寻找一个流，一旦数据流被提供或者被消耗，就不能从流中重新取出。 CFStream构建在CFSocket之上，在CFHTTP和CFFTP之下。如图可以看出，尽管CFStream不是CFNetwork正式的部分，但它是几乎所有CFNetwork的基础。CFNetwork框架的层级设计： CFNetwork APICFNetwork又分成了几个单独的API，分别负责一个特定的的网络协议，这些API可以结合或分开使用，这取决于App的实际需要。 CFFTPCFFTP使与FTP服务器通信更加便利。创建写入流与读取流，使用读写流，你可以进行的操作包括： 从FTP服务器下载文件 上传文件到FTP服务器 获得FTP服务器下目录 创建目录到FTP服务器 CFHTTP发送和接受HTTP消息，CFFTP是FTP协议的抽象，CFHTTP是HTTP协议的抽象。超文本传输协议（HTTP）是一种客户端/服务端的请求/响应协议，客户端创建请求消息，请求消息被序列化，转换为原始字节流，发送字节流到服务器，服务器收到进行反序列化处理并响应。 要创建一个HTTP请求，需指定一些基础的内容： 请求的方法，比如GET、POST、HEAD等 URL 资源定位，比如http://www.apple.com HTTP版本，比如1.0、2.0 消息主题，字节流 消息头 消息创建后，需将其序列化后进行传递，序列化后一般的请求样式为： 1GET / HTTP/1.0\\r\\nUser-Agent: UserAgent\\r\\nContent-Length: 0\\r\\n\\r\\n CFHTTPAuthentication完成身份验证。 CFHost获取主机信息，包括名称、地址、可达性信息等。获取信息的过程被称为解析。 所有的CFNetwork、CFHost都兼容IPv4与IPv6，使用CFHost，可以透明的使用代码对IPv4、IPv6进行处理。 CFNetServices如果你想让你的应用使用Bonjour注册一个服务或发现服务可以使用CFNetServices。Bonjour是苹果零配置网络（ZEROCONF）的实现，它允许你发布、发现和解析网络服务。 CFNetDiagnostics连接到网络的应用依赖于一个稳定的链接。如果网络不稳定，这将导致应用程序的问题。采用CFNetDiagnostics API，用户可以自己诊断如下网络问题： 物理连接失败（例如，未插入电缆） 网络故障（例如，DNS或DHCP服务器不再响应） 配置失败（例如，代理配置不正确） 由下至上的进行学习 CFSocket官方文档 12345#import &lt;CFNetwork/CFNetwork.h&gt;#import &lt;sys/socket.h&gt;#import &lt;netinet/in.h&gt;#import &lt;arpa/inet.h&gt;#import &lt;unistd.h&gt; 进入第一个socket程序: 添加2个全局变量供下面 12CFSocketRef socket; // socket引用CFDataRef dataRef; // 存储服务器地址信息 创建socket并发送、接收消息 12345678910111213141516171819// 创建socket连接CFSocketContext context = &#123; 0, // 结构体的版本，必须为0 (__bridge void *)(self), // 一个任意指针的数据，可以用在创建时CFSocket对象相关联。这个指针被传递给所有的上下文中定义的回调。 NULL, // 一个定义在上面指针中的retain的回调， 可以为NULL NULL, NULL&#125;;// 创建socket引用socket = CFSocketCreate( kCFAllocatorDefault, // 为新对象分配内存，可以为nil PF_INET, // 协议族，如果为0或者负数，则默认为PF_INET SOCK_STREAM, // 套接字类型，如果协议族为PF_INET,则它会默认为SOCK_STREAM, IPPROTO_TCP, // 套接字协议，如果协议族是PF_INET且协议是0或者负数，它会默认为IPPROTO_TCP kCFSocketConnectCallBack, // 触发回调函数的socket消息类型，具体见Callback Types TCPServerConnectCallBack, // 上面情况下触发的回调函数 &amp;context // 一个持有CFSocket结构信息的对象，可以为nil ); 实现callBack方法 1234567891011static voidTCPServerConnectCallBack(CFSocketRef s, CFSocketCallBackType type, CFDataRef address, const void *data, void *info) &#123; if ( data != NULL ) &#123; // 当socket为kCFSocketConnectCallBack时，失败时回调失败会返回一个错误代码指针，其他情况返回NULL NSLog(@&quot;连接失败&quot;); return; &#125; UIViewController * vc = (__bridge UIViewController *) info; [vc performSelector:@selector(sendMessage) withObject:nil]; [vc performSelector:@selector(readStream) withObject:nil];&#125; 创建服务器地址信息 12345678// 创建服务端信息 struct sockaddr_in addr4; // IPv4, sockaddr_in6 memset(&amp;addr4, 0, sizeof(addr4)); addr4.sin_len = sizeof(addr4); addr4.sin_family = AF_INET; addr4.sin_port = htons(18800); addr4.sin_addr.s_addr = inet_addr([localHost UTF8String]); dataRef = CFDataCreate(kCFAllocatorDefault, (UInt8 *)&amp;addr4, sizeof(addr4)); 连接 123456789101112131415if ( socket ) &#123; CFSocketError e = CFSocketConnectToAddress(socket, dataRef, -1); if ( e ) &#123; NSLog(@&quot;Error!&quot;); return; &#125; CFRunLoopRef runLoopRef = CFRunLoopGetCurrent(); CFRunLoopSourceRef runLoopSourcesRef = CFSocketCreateRunLoopSource(kCFAllocatorDefault, socket, 0); CFRunLoopAddSource(runLoopRef, runLoopSourcesRef, kCFRunLoopCommonModes); CFRelease(runLoopSourcesRef); &#125; else &#123; NSLog(@&quot;连接失败&quot;); &#125; 接收与发送消息 123456789101112131415- (void) readStream &#123; char buffer[1024]; while (recv(CFSocketGetNative(socket), //与本机关联的Socket 如果已经失效返回－1:INVALID_SOCKET buffer, sizeof(buffer), 0)) &#123; NSLog(@&quot;%@&quot;, [NSString stringWithUTF8String:buffer]); &#125;&#125;- (void)sendMessage &#123; NSString *stringTosend = @&quot;你好&quot;; CFSocketError e = CFSocketSendData(socket, dataRef, CFDataCreate(kCFAllocatorDefault, (UInt8 *)[stringTosend UTF8String], sizeof([stringTosend UTF8String])), 1); if ( e ) &#123; &#125;&#125; 1NSString * localHost = @&quot;120.27.139.39&quot;; // 该地址为测试IP地址, 仅供测试连接使用 以上步骤没问题的话，可以成功的连接到服务器并发送一条消息。 参考文档 CFStream尝试对文件的读取，文件直接存在于项目工程目录下，通过NSBundle来加载。 创建读入流 12345// 创建读入流 NSString *pdfPath = [[NSBundle mainBundle] pathForResource:@&quot;File&quot; ofType:@&quot;txt&quot;]; NSURL *pdfUrl = [NSURL fileURLWithPath:pdfPath]; CFReadStreamRef myReadStream = CFReadStreamCreateWithFile(kCFAllocatorDefault, (CFURLRef)pdfUrl); 读取文件内容 12345678910111213141516171819202122232425262728293031if (!CFReadStreamOpen(myReadStream)) &#123; CFStreamError myErr = CFReadStreamGetError(myReadStream); // 发生了错误 if (myErr.domain == kCFStreamErrorDomainPOSIX) &#123; // Interpret myErr.error as a UNIX errno. &#125; else if (myErr.domain == kCFStreamErrorDomainMacOSStatus) &#123; // Interpret myErr.error as a MacOS error code. OSStatus macError = (OSStatus)myErr.error; NSLog(@&quot;%d&quot;, macError); &#125;&#125; else &#123; NSLog(@&quot;打开成功&quot;); CFIndex numBytesRead; do &#123; UInt8 buf[1024 * 1024]; // define myReadBufferSize as desired numBytesRead = CFReadStreamRead(myReadStream, buf, sizeof(buf)); if( numBytesRead &gt; 0 ) &#123; NSLog(@&quot;%s&quot;, buf); &#125; else if( numBytesRead &lt; 0 ) &#123; CFStreamError error = CFReadStreamGetError(myReadStream); NSLog(@&quot;%ld %d&quot;, error.domain, error.error); &#125; else &#123; NSLog(@&quot;去读结束&quot;); &#125; &#125; while( numBytesRead &gt; 0 ); NSLog(@&quot;读取完毕&quot;); CFReadStreamClose(myReadStream); CFRelease(myReadStream); myReadStream = NULL;&#125; 正常执行，会在控制台打印工程目录下File.txt文件的内容。 创建写入流 123456789NSString * document = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES).lastObject; NSString * p = [document stringByAppendingPathComponent:@&quot;a.txt&quot;]; if ( ![[NSFileManager defaultManager] fileExistsAtPath:p] ) &#123; [[NSFileManager defaultManager] createFileAtPath:p contents:nil attributes:nil]; &#125; CFWriteStreamRef myWriteStream = CFWriteStreamCreateWithFile(kCFAllocatorDefault, (CFURLRef)[NSURL fileURLWithPath:p]); 开始写入操作 1234567891011121314151617181920212223242526272829if (!CFWriteStreamOpen(myWriteStream)) &#123; CFStreamError myErr = CFWriteStreamGetError(myWriteStream); // An error has occurred. if (myErr.domain == kCFStreamErrorDomainPOSIX) &#123; // Interpret myErr.error as a UNIX errno. &#125; else if (myErr.domain == kCFStreamErrorDomainMacOSStatus) &#123; // Interpret myErr.error as a MacOS error code. OSStatus macError = (OSStatus)myErr.error; // Check other error domains. NSLog(@&quot;%d&quot;, macError); &#125; &#125; NSLog(@&quot;%ld&quot;,CFWriteStreamGetStatus(myWriteStream)); const char * buf = &quot;World !&quot;; CFIndex bufLen = (CFIndex)strlen(buf); if ( CFWriteStreamCanAcceptBytes(myWriteStream) ) &#123; NSLog(@&quot;可以接受字节&quot;); CFIndex bytesWritten = CFWriteStreamWrite(myWriteStream, (UInt8 *)buf, (CFIndex)bufLen); NSLog(@&quot;%ld&quot;, bytesWritten); &#125; else &#123; NSLog(@&quot;不可以接受字节&quot;); &#125; CFWriteStreamClose(myWriteStream); CFRelease(myWriteStream); myWriteStream = NULL; 如果正常运行的话, 会在项目本沙箱地址Library中存在a.txt并且内容为World ！ 官方文档 CFHTTP创建一个Request 123456789101112131415161718192021222324CFStringRef bodyString = CFSTR(&quot;Hello&quot;);CFStringRef headerFieldName = CFSTR(&quot;X-My-Favorite-Field&quot;);CFStringRef headerFieldValue = CFSTR(&quot;Dreams&quot;);CFStringRef url = CFSTR(&quot;http://www.apple.com&quot;);CFURLRef myURL = CFURLCreateWithString(kCFAllocatorDefault, url, NULL);CFStringRef requestMethod = CFSTR(&quot;GET&quot;);CFHTTPMessageRef myRequest =CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, myURL, kCFHTTPVersion1_1);CFDataRef bodyDataExt = CFStringCreateExternalRepresentation(kCFAllocatorDefault, bodyString, kCFStringEncodingUTF8, 0);CFHTTPMessageSetBody(myRequest, bodyDataExt);CFHTTPMessageSetHeaderFieldValue(myRequest, headerFieldName, headerFieldValue);CFDataRef mySerializedRequest = CFHTTPMessageCopySerializedMessage(myRequest);CFRelease(myRequest);CFRelease(myURL);CFRelease(url);CFRelease(mySerializedRequest);myRequest = NULL;mySerializedRequest = NULL; mySerializedRequest即为序列化后的Request内容。 12345(lldb) po [[NSString alloc] initWithData:(NSData *)mySerializedRequest encoding:NSUTF8StringEncoding]GET / HTTP/1.1X-My-Favorite-Field: DreamsHello 通过lldb打印可以看到内容。 创建请求并发送 123456CFReadStreamRef myReadStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, myRequest);CFReadStreamOpen(myReadStream);CFHTTPMessageRef myResponse = (CFHTTPMessageRef)CFReadStreamCopyProperty(myReadStream, kCFStreamPropertyHTTPResponseHeader);CFStringRef myStatusLine = CFHTTPMessageCopyResponseStatusLine(myResponse);UInt32 myErrCode = CFHTTPMessageGetResponseStatusCode(myResponse); 其中CFReadStreamCreateForHTTPRequest类似的API已经弃用，苹果希望使用NSURLSession。 官方文档 Communicating with Authenticating HTTP Servers官方文档 CFFTP官方文档 网络诊断1CFNetDiagnosticDiagnoseProblemInteractively() 注：文中内容90%来自官方文档。","categories":[],"tags":[{"name":"CoreFoundation","slug":"CoreFoundation","permalink":"https://wilddylan.github.io/tags/CoreFoundation/"}],"keywords":[]},{"title":"Launch Arguments & Environment Variables.","slug":"Launch-Arguments-Environment-Variables","date":"2016-08-30T08:16:10.000Z","updated":"2017-02-04T09:02:03.000Z","comments":true,"path":"2016/08/30/Launch-Arguments-Environment-Variables/","link":"","permalink":"https://wilddylan.github.io/2016/08/30/Launch-Arguments-Environment-Variables/","excerpt":"Walk into any American fast food establishment, and you’ll be greeted with a colorful, back-lit display of specials, set menus, and other a la carte items. But as those in-the-know are quick to point out, larger chains often have a secret menu, passed down by oral tradition between line cook workers and patrons over the generations. At McDonald’s, one can order a “Poor Man’s Big Mac”, which transforms a double cheeseburger alchemy-like into the chain’s signature sandwich on the cheap. At Chipotle, there is an unwritten rule that they’ll make anything within the scope of available ingredients. Since Mexican food is a testament to culinary combinatorics, an off-book order for a Quesadilla or Nachos is well within their wheelhouse. In life, it’s all about knowing what to ask for.","text":"Walk into any American fast food establishment, and you’ll be greeted with a colorful, back-lit display of specials, set menus, and other a la carte items. But as those in-the-know are quick to point out, larger chains often have a secret menu, passed down by oral tradition between line cook workers and patrons over the generations. At McDonald’s, one can order a “Poor Man’s Big Mac”, which transforms a double cheeseburger alchemy-like into the chain’s signature sandwich on the cheap. At Chipotle, there is an unwritten rule that they’ll make anything within the scope of available ingredients. Since Mexican food is a testament to culinary combinatorics, an off-book order for a Quesadilla or Nachos is well within their wheelhouse. In life, it’s all about knowing what to ask for. Which brings us to Xcode Launch Arguments &amp; Environment Variables. There are a number of options that can be passed into a target’s scheme to enable useful debugging behavior, but like a fast food secret menu, they’re obscure and widely unknown. So this week on NSHipster, we’ll take a look at the hidden world of Xcode runtime configuration, so that you, dear reader, may also saunter up to the great lunch counter of Objective-C and order to your heart’s content. To enable launch arguments and set environment variables for your app, select your target from the Xcode toolbar and select “Edit Scheme…” On the left side of the panel, select “Run [AppName].app”, and select the “Arguments” segment on the right side. There will be two drop-downs, for “Arguments Passed on Launch” and “Environment Variables”. For the purposes of debugging an app target, launch arguments and environment variables can be thought to be equivalent—both change the runtime behavior by defining certain values. In practice, the main difference between the two is that launch arguments begin with a dash (-) and don’t have a separate field for argument values. Arguments Passed on LaunchAny argument passed on launch will override the current value in NSUserDefaults for the duration of execution. While this can be used for domain-specific testing and debugging, the two most widely applicable use cases are for localization and Core Data. LocalizationGetting localization right is a challenging and time-consuming task in and of itself. Fortunately, there are a few launch arguments that make the process much nicer. For more information about localization, check out our article aboutNSLocalizedString. NSDoubleLocalizedStringsTo simulate German’s UI-breaking götterdämmere Weltanschauung of long-compound-words-unbroken-by-breakable-whitespace, there’s NSDoubleLocalizedStrings. According to IBM’s Globalization Guidelines, we can expect translations from English to many European languages to be double or even triple the physical space of the source: Number of Characters in Text Additional Physical Space Required ≤ 10 100% to 200% 11 – 20 80% to 100% 21 – 30 60% to 80% 31 – 50 40% to 60% 51 – 70 31% to 40% 70 30% While you’re waiting for the first batch of translations to come back, or are merely curious to see how badly your UI breaks under linguistic pressure, specify the following launch argument: 1-NSDoubleLocalizedStrings YES NSShowNonLocalizedStringsProject managers screaming at you to get localization finished? Now you can configure your app to scream at you as well! If you pass the NSShowNonLocalizedStrings launch argument, any unlocalized string will SCREAM AT YOU IN CAPITAL LETTERS. HOW DELIGHTFUL! 1-NSShowNonLocalizedStrings YES AppleLanguagesPerhaps the most useful launch argument of all, however, is AppleLanguages. Normally, one would have to manually go through Settings &gt; General &gt; International &gt; Language and wait for the Simulator or Device to restart. But the same can be accomplished much more simply with the following launch argument: 1-AppleLanguages (es) The value for AppleLanguages can either be the name of the language (“Spanish”), or its language code (es), but since localization files are keyed by their ISO 639 code, using the code is preferable to the actual name of the language. Core DataOf all of the system frameworks, Core Data may be the most in need of debugging. Managed objects passing across contexts and threads, and notifications firing with dazzlingly fervor, there’s too much going on to keep track of yourself. Call in reinforcements with these essential launch arguments: SQL DebugMost Core Data stacks use SQLite as a persistent store, so if your app is anything like the majority, you’ll appreciate being able to watch SQL statements and statistics fly by as Core Data works its magic. Set the following launch argument: 1-com.apple.CoreData.SQLDebug 3 …and let the spice flow. 12345CoreData: sql: pragma cache_size=1000CoreData: sql: SELECT Z_VERSION, Z_UUID, Z_PLIST FROM Z_METADATACoreData: sql: SELECT 0, t0.Z_PK, t0.Z_OPT, t0.ZAUTHOR, t0.ZTITLE, t0.ZCOPYRIGHT FROM ZBOOK t0 ORDER BY t0.ZAUTHOR, t0.ZTITLECoreData: annotation: sql connection fetch time: 0.0001sCoreData: annotation: total fetch execution time: 0.0010s for 20 rows. com.apple.CoreData.SQLDebug takes a value between 1 and 3; the higher the value, the more verbose the output. Adjust according to taste. Migration DebugIn any other persistence layer, migrations are a blessing. Yet, for some reason, Core Data manages to make them into something out of a nightmare. When things go wrong and you have no one to blame except your own ignorant self, unworthy of such an intuitive and well-designed ORM graph persistence framework, then here’s an argument you’ll want to pass at launch: 1-com.apple.CoreData.MigrationDebug Environment VariablesWhereas launch arguments are specific to the executable, environment variables have a wider scope, more along the lines of a global variable (but without all of the knee-jerk derision from programmers). Configure your environment with the following settings to shape the memory management policies to aide in debugging. Unless otherwise specified, environment variables are passed YES or NO to enable or disable a particular feature. Zombies!Over-played in popular media, under-played in Objective-C, everyone can agree that it pays to know about zombies. Setting NSZombie-related environment variables allows you to control the BRAAAAINS! of your app. To be more specific, when objects are deallocated, they become “zombified”, able to communicate any messages that are passed after they have been freed. This can be useful for tracing any errantEXC_BAD_ACCESS exceptions you get during execution. Name Effect NSZombieEnabled If set to YES, deallocated objects are ‘zombified’; this allows you to quickly debug problems where you send a message to an object that has already been freed. NSDeallocateZombies If set to YES, the memory for ‘zombified’ objects is actually freed. Memory AllocatorThe memory allocator includes several debugging hooks that can be enabled by environment variables. As explained in Apple’s Memory Usage Performance Guidelines: Guard Malloc is a special version of the malloc library that replaces the standard library during debugging. Guard Malloc uses several techniques to try and crash your application at the specific point where a memory error occurs. For example, it places separate memory allocations on different virtual memory pages and then deletes the entire page when the memory is freed. Subsequent attempts to access the deallocated memory cause an immediate memory exception rather than a blind access into memory that might now hold other data. When the crash occurs, you can then go and inspect the point of failure in the debugger to identify the problem. Here are some of the most useful ones: Name Effect MallocScribble Fill allocated memory with 0xAA and scribble deallocated memory with 0x55. MallocGuardEdges Add guard pages before and after large allocations. MallocStackLogging Record backtraces for each memory block to assist memory debugging tools; if the block is allocated and then immediately freed, both entries are removed from the log, which helps reduce the size of the log. MallocStackLoggingNoCompact Same as MallocStackLogging but keeps all log entries. I/O BufferingAlthough unlikely, you may come across a situation where you want logging to stdout to be unbuffered (ensuring that the output has been written before continuing). You can set that with theNSUnbufferedIO environment variable: Name Effect NSUnbufferedIO If set to YES, Foundation will use unbuffered I/O for stdout (stderr is unbuffered by default). Just as secret menus are bound by the implications of Gödel’s Incompleteness Theorem, it is impossible to document all of the secret incantations to get special treatment in Xcode. However, perhaps you can find a few more (and learn a ton about runtime internals) by perusing Apple’sTechnical Note TN2239: iOS Debugging Magic and Technical Note TN2124: OS X Debugging Magic. Hopefully, though, the secret knowledge you’ve been exposed to in this article will sustain you in your app endeavors. Use them wisely, and pass them onto your coworkers like an urban legend or juicy rumor.","categories":[],"tags":[{"name":"iOS新特性","slug":"iOS新特性","permalink":"https://wilddylan.github.io/tags/iOS新特性/"}],"keywords":[]},{"title":"AddressBook.framework","slug":"AddressBook-framework","date":"2016-08-22T09:44:14.000Z","updated":"2017-02-04T09:02:14.000Z","comments":true,"path":"2016/08/22/AddressBook-framework/","link":"","permalink":"https://wilddylan.github.io/2016/08/22/AddressBook-framework/","excerpt":"AddressBook.framework/AddressBookUI.framework9.0之后, AddressBook.framework被Contacts.framework代替。但是目前大部分的应用软件起支撑的版本是iOS6.0或7.0, 所以AddressBook还大有用处。之前在简书的文章AddressBook, AddressBookUI中有提及, 但是由于是转载, 所以代码不是很清晰, 而且有一些读者希望得到清晰的代码以及详细的功能解释, 所以在这里把AddressBook.framework以及AddressBookUI.framework重新做一下详细的使用方法介绍。 这篇文章先介绍AddressBook.framework。 AddressBookUI以及Contacts.framework也会补上。","text":"AddressBook.framework/AddressBookUI.framework9.0之后, AddressBook.framework被Contacts.framework代替。但是目前大部分的应用软件起支撑的版本是iOS6.0或7.0, 所以AddressBook还大有用处。之前在简书的文章AddressBook, AddressBookUI中有提及, 但是由于是转载, 所以代码不是很清晰, 而且有一些读者希望得到清晰的代码以及详细的功能解释, 所以在这里把AddressBook.framework以及AddressBookUI.framework重新做一下详细的使用方法介绍。 这篇文章先介绍AddressBook.framework。 AddressBookUI以及Contacts.framework也会补上。 开始使用AdressBook首先, 导入我们需要的Framework 1#import &lt;AddressBook/AddressBook.h&gt; 经常使用到： ABAddressBookRef: 通讯录引用 ABRecordRef: 记录引用 ABPropertyID: 记录的属性ID 获取AddressBook使用权限像使用相机、推送一样, 访问AddressBook同样需要获取权限。 在获取权限之前，我们需要创建一个AddressBook的引用，用来做后续操作。 12345678910111213static ABAddressBookRef r;static inline ABAddressBookRef getAddressBookRef() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; CFErrorRef errorRef; r = ABAddressBookCreateWithOptions(NULL, &amp;errorRef); if ( errorRef ) &#123; ILog(@&quot;%@&quot;, (__bridge NSString *)CFErrorCopyFailureReason(errorRef)); &#125; &#125;); return r;&#125; ABAddressBookRef，作为后续使用的通讯录引用，这里写作单例。或者可以写作单例的属性，但只需初始化一次。 ABAddressBookCreateWithOptions通过参数创建, options暂时为预留字段，但是AddressBook在9.0被弃用，估计不会被使用了。 在获取到引用之后，我们应先查询AddressBook的访问状态： 123456789101112Boolean needRequestAccess() &#123; ABAuthorizationStatus s = ABAddressBookGetAuthorizationStatus(); if ( s == kABAuthorizationStatusDenied || s == kABAuthorizationStatusRestricted ) &#123; alert(@&quot;提示&quot;, @&quot;&quot;); return false; &#125; if ( s != kABAuthorizationStatusAuthorized ) &#123; return true; &#125; return false;&#125; 推荐使用switch-case来判断状态。如果结果为kABAuthorizationStatusAuthorized表示可以正常访问。要注意的是，如果用户拒绝了首次的请求，那么需要用户在设置-隐私-通讯录中手动打开App使用通讯录的权限。 如果结果为kABAuthorizationStatusNotDetermined意味着我们需要请求访问权限: Restricted意味着系统决定了访问权限，用户不能修改。 123void requestAddressBookAccess (ABAddressBookRequestAccessCompletionHandler handler) &#123; ABAddressBookRequestAccessWithCompletion(getAddressBookRef(), handler);&#125; 综合起来的调用: 12345678910111213void initAddressBook (void (^shouldAccessAddressBook)(Boolean boo)) &#123; if ( needRequestAccess() ) &#123; requestAddressBookAccess(^(bool granted, CFErrorRef error) &#123; if ( granted ) &#123; shouldAccess = true; &#125; shouldAccessAddressBook(granted); &#125;); &#125; else &#123; shouldAccess = true; shouldAccessAddressBook(true); &#125;&#125; 非常简单的，我们获得了通讯录的访问权限。 用户的查询用户的查询非常简单； ABAddressBookGetPersonCount：获取总人数 ABAddressBookGetPersonWithRecordID：通过RecordID获取单个人，recordID可以通过ABRecordGetRecordID获得 ABAddressBookCopyArrayOfAllPeople：获取全部联系人数组 ABAddressBookCopyArrayOfAllPeopleInSource：获取记录引用中所有的练习嗯 ABAddressBookCopyArrayOfAllPeopleInSourceWithSortOrdering：带着排序参数 ABAddressBookCopyPeopleWithName：拷贝符合该名称的联系人 获取联系人的数量: 12CFIndex i = ABAddressBookGetPersonCount(getAddressBookRef());printf(&quot;AddressBook: has %ld Person&quot;, i); 获取联系人: 1234CFArrayRef ref = ABAddressBookCopyArrayOfAllPeople(getAddressBookRef()); ABRecordRef pr = CFArrayGetValueAtIndex(ref, 0);ILog(@&quot;%@&quot;, ABRecordCopyValue(pr, kABPersonFirstNameProperty)); 获取联系人组使用ABAddressBookCopyArrayOfAllGroups即可。然后通过ABAddressBookCopyArrayOfAllPeopleInSource即可获得组内联系人。 用户信息的修改与删除12345678910111213141516CFArrayRef ref = ABAddressBookCopyArrayOfAllPeople(getAddressBookRef()); ABRecordRef pr = CFArrayGetValueAtIndex(ref, 0);ILog(@&quot;%@&quot;, ABRecordCopyValue(pr, kABPersonFirstNameProperty)); if ( ABRecordSetValue(pr, kABPersonFirstNameProperty, (__bridge CFStringRef)@&quot;Hello&quot;, nil) ) &#123; if ( ABAddressBookSave(getAddressBookRef(), nil) ) &#123; ILog(@&quot;Succeed!&quot;); &#125;&#125; if ( ABAddressBookRemoveRecord(getAddressBookRef(), pr, nil) ) &#123; if ( ABAddressBookSave(getAddressBookRef(), nil) ) &#123; ILog(@&quot;Remove Succeed!&quot;); &#125;&#125; ABRecordCopyValue用来通过ABPropertyID获取相应属性的内容, 具体的ID在ABPerson.h中有详细列表。 ABRecordSetValue用来通过ABPropertyID设置相应的属性内容，同时返回bool值以供判段。参数中的error已经不在使用。 在修改后，切记保存修改，使用ABAddressBookSave做保存，在这之前，可以使用ABAddressBookHasUnsavedChanges判断是否存在未保存的修改。 使用ABAddressBookRemoveRecord来移除记录。 监听其他应用对AddressBook的修改在操作AddressBook的同时，有可能在后台的时候被其他程序所修改，addressBook提供了监听方法: 1234567void callBack(ABAddressBookRef addressBook, CFDictionaryRef info, void *context) &#123; ILog(@&quot;AddressBook has changed in another application.&quot;);&#125;;void handleChange() &#123; ABAddressBookRegisterExternalChangeCallback(getAddressBookRef(), callBack, nil);&#125; 在收到监听后我们需要做相应的处理，比如： 是否其他改动与我们的改动有重叠等。 注意点 在设置值的时候，可以使用ABMultiValueRef设置多个值，比如说多个电话。 在不使用的时候，要使用ABAddressBookUnregisterExternalChangeCallback取消对AddressBook的监听。 Q&amp;A： Q：如何在删除完联系人的多个电话后，直接删除联系人？ A：通过propertyID获取到电话的信息后，做简单的判断就可以实现。如果仅存这一条电话记录，那么在删除的同时也删除掉联系人即可。 附本文全部的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#import \"Ins_AddressBook.h\"@implementation InsAddressBookstatic Boolean shouldAccess;static ABAddressBookRef r;static inline ABAddressBookRef getAddressBookRef() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; CFErrorRef errorRef; r = ABAddressBookCreateWithOptions(NULL, &amp;errorRef); if ( errorRef ) &#123; ILog(@\"%@\", (__bridge NSString *)CFErrorCopyFailureReason(errorRef)); &#125; &#125;); return r;&#125;void requestAddressBookAccess (ABAddressBookRequestAccessCompletionHandler handler) &#123; ABAddressBookRequestAccessWithCompletion(getAddressBookRef(), handler);&#125;Boolean needRequestAccess() &#123; ABAuthorizationStatus s = ABAddressBookGetAuthorizationStatus(); if ( s == kABAuthorizationStatusDenied || s == kABAuthorizationStatusRestricted ) &#123; alert(@\"提示\", @\"你之前已经拒绝了程序的访问权限, 请在设置-隐私-通讯录中手动打开, 并重新启动应用。\"); return false; &#125; if ( s != kABAuthorizationStatusAuthorized ) &#123; return true; &#125; return false;&#125;void initAddressBook (void (^shouldAccessAddressBook)(Boolean boo)) &#123; if ( needRequestAccess() ) &#123; requestAddressBookAccess(^(bool granted, CFErrorRef error) &#123; if ( granted ) &#123; shouldAccess = true; &#125; shouldAccessAddressBook(granted); &#125;); &#125; else &#123; shouldAccess = true; shouldAccessAddressBook(true); &#125;&#125;void callBack(ABAddressBookRef addressBook, CFDictionaryRef info, void *context) &#123; ILog(@\"AddressBook has changed in another application.\");&#125;;void handleChange() &#123; ABAddressBookRegisterExternalChangeCallback(getAddressBookRef(), callBack, nil);&#125;void getPerson () &#123; CFIndex i = ABAddressBookGetPersonCount(getAddressBookRef()); printf(\"AddressBook: has %ld Person\", i); CFArrayRef ref = ABAddressBookCopyArrayOfAllPeople(getAddressBookRef()); ABRecordRef pr = CFArrayGetValueAtIndex(ref, 0); ILog(@\"%@\", ABRecordCopyValue(pr, kABPersonFirstNameProperty)); if ( ABRecordSetValue(pr, kABPersonFirstNameProperty, (__bridge CFStringRef)@\"Hello\", nil) ) &#123; if ( ABAddressBookSave(getAddressBookRef(), nil) ) &#123; ILog(@\"Succeed!\"); &#125; &#125; if ( ABAddressBookRemoveRecord(getAddressBookRef(), pr, nil) ) &#123; if ( ABAddressBookSave(getAddressBookRef(), nil) ) &#123; ILog(@\"Remove Succeed!\"); &#125; &#125;&#125;- (instancetype)init &#123; self = [super init]; if ( self ) &#123; initAddressBook(^(Boolean boo)&#123; if ( boo ) &#123; ILog(@\"Get access to addressBook\") handleChange(); getPerson(); &#125; else &#123; ILog(@\"Without access to addressBook\") &#125; &#125;); &#125; return self;&#125;DEF_SINGLETON_AUTOLOAD(InsAddressBook)@end AddressBookUI.framework相比而言，使用UI则简单的多，直接进入创建一个新的用户： 123ABNewPersonViewController * pv = [[ABNewPersonViewController alloc] init];pv.newPersonViewDelegate = self;[getRootNc() presentViewController:INS_NAV(pv) animated:YES completion:nil]; 1234- (void) newPersonViewController: (ABNewPersonViewController *) newPersonView didCompleteWithNewPerson: (ABRecordRef) person &#123; [newPersonView.navigationController dismissViewControllerAnimated:YES completion:nil];&#125; 创建界面与其代理方法，当然在ABNewPersonViewController中，有写参数我们可以设置，意义很简单，可以通过我们上边AddressBook.framework中获得的一些引用穿进去，或者在创建用户之前直接设置一个用户的基础信息。这里不做赘述。 选择一个用户123ABPeoplePickerNavigationController * pv = [[ABPeoplePickerNavigationController alloc] init];pv.peoplePickerDelegate = self;[getRootNc() presentViewController:pv animated:YES completion:nil]; 12345678- (void)peoplePickerNavigationController:(ABPeoplePickerNavigationController*)peoplePicker didSelectPerson:(ABRecordRef)person &#123; &#125;// Called after the user has pressed cancel.- (void)peoplePickerNavigationControllerDidCancel:(ABPeoplePickerNavigationController *)peoplePicker &#123; [peoplePicker dismissViewControllerAnimated:YES completion:nil];&#125; 注：这里我没有低版本的测试环境，但是可以看到，选中人的方法在8.0后才被使用，所以低版本的童鞋应该主动尝试原本被弃用的2个方法。 展示用户ABPersonViewController If displayedPerson has been added to an ABAddressBook, then the addressBook property will be updated to use the displayedPerson’s ABAddressBook. 可以设置的属性包括：允许编辑、允许操作（短信、邮件等），允许展示连接的联系人，设置属性高亮等。也比较方便。 信息的完善ABUnknownPersonViewController 1234ABUnknownPersonViewController *un = [[ABUnknownPersonViewController alloc] init];un.displayedPerson = person; // 展示的联系人un.allowsAddingToAddressBook = YES; // 允许添加到通讯录中[getRootNc() presentViewController:INS_NAV(un) animated:YES completion:nil]; 总结AddressBook.framework、AdressBookUI.framework还是可以满足一些基本需求，但是由于是c库，并且功能不是很完善，所以在iOS9.0之后苹果使用Contacts.framework来代替AddressBook.framework。ContactsFramework是一整套OC的库，理解起来也很简单。 这是ContactsFramework中包含的一些头文件，在使用AddressBook的时候，基本所有的方法都在后边写了使用ContactsFramework中什么方法来代替。 CNContact以及CNGroup分别代表了联系人与联系人组，比之前的Record引用清晰了许多。 CNContactFetchRequest以及CNSaveRequest方便的提供了查询以及保存等操作。 CNSaveRequest则提供了方便直观的方法去保存用户。 然后整个框架都清晰了很多，基本的使用方法如下： 123456789101112131415161718192021222324252627282930313233CNContactStore * c;CNAuthorizationStatus s;CNContactFetchRequest * f;NSError * e; s = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts];c = [[CNContactStore alloc] init]; if ( s != CNAuthorizationStatusAuthorized ) &#123; ILog(@&quot;Un Authorized !&quot;); [c requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * error) &#123; &#125;];&#125; // 根据`CNContact`中的属性单独获得，比如 @[CNContactGivenNameKey, CNContactMiddleNameKey, ...]f = [[CNContactFetchRequest alloc] initWithKeysToFetch:@[CNContactMiddleNameKey, CNContactEmailAddressesKey, CNContactPhoneNumbersKey]]; BOOL b = [c enumerateContactsWithFetchRequest:f error:&amp;e usingBlock:^(CNContact * contact, BOOL * stop) &#123; /* &lt;CNContact: 0x7f8f4fb86dc0: identifier=41592D45-CE20-44C8-95C5-C1FE464474A5:ABPerson, givenName=(not fetched), familyName=(not fetched), organizationName=(not fetched), phoneNumbers=( &quot;&lt;CNLabeledValue: 0x7f8f4fb88dc0: identifier=243FA6B4-33AE-43A6-8567-AFE11518BBCC, label=_$!&lt;Home&gt;!$_, value=&lt;CNPhoneNumber: 0x7f8f4fb88ca0: countryCode=us, digits=+8613088488288&gt;&gt;&quot; ), emailAddresses=( &quot;&lt;CNLabeledValue: 0x7f8f4fb87c30: identifier=3B1CADF7-967B-41A0-A575-EB0B7BA1BB5B, label=_$!&lt;Home&gt;!$_, value=dylan@china.com&gt;&quot; ), postalAddresses=(not fetched)&gt; */&#125;]; if ( b ) &#123; ILog(@&quot;Search success.&quot;);&#125; 当然不能所有的代码全部我贴出来，关于保存等功能，大家自行探索。 2016-8-23 上午10：00 copyRight@dylan@china.com 欢迎转载。","categories":[],"tags":[{"name":"Frameworks","slug":"Frameworks","permalink":"https://wilddylan.github.io/tags/Frameworks/"}],"keywords":[]},{"title":"What’s New in iOS 10","slug":"What’s-New-in-iOS-10","date":"2016-08-22T01:30:09.000Z","updated":"2017-02-04T09:01:37.000Z","comments":true,"path":"2016/08/22/What’s-New-in-iOS-10/","link":"","permalink":"https://wilddylan.github.io/2016/08/22/What’s-New-in-iOS-10/","excerpt":"What’s New in iOS 10.0 Table of Contents Introduction iOS 10.0 iOS 9.3 iOS 9.2 iOS 9.1 iOS 9.0 iOS 8.4 iOS 8.3 iOS 8.2 iOS 8.1 iOS 8.0 iOS 7.1 iOS 7.0 iOS 6.1 iOS 6.0 iOS 5.1 iOS 5.0 iOS 10.0This article summarizes the key developer-related features introduced in iOS 10, which runs on currently shipping iOS devices. The article also lists the documents that describe new features in more detail. For late-breaking news and information about known issues, see Release Notes at https://developer.apple.com/ios/download/. For the complete list of new APIs added in iOS 10, see iOS 10.0 API Diffs. For more information on new devices, see iOS Device Compatibility Reference. To learn about what’s new in Swift, see Swift Language and The Swift Programming Language (Swift 3).","text":"What’s New in iOS 10.0 Table of Contents Introduction iOS 10.0 iOS 9.3 iOS 9.2 iOS 9.1 iOS 9.0 iOS 8.4 iOS 8.3 iOS 8.2 iOS 8.1 iOS 8.0 iOS 7.1 iOS 7.0 iOS 6.1 iOS 6.0 iOS 5.1 iOS 5.0 iOS 10.0This article summarizes the key developer-related features introduced in iOS 10, which runs on currently shipping iOS devices. The article also lists the documents that describe new features in more detail. For late-breaking news and information about known issues, see Release Notes at https://developer.apple.com/ios/download/. For the complete list of new APIs added in iOS 10, see iOS 10.0 API Diffs. For more information on new devices, see iOS Device Compatibility Reference. To learn about what’s new in Swift, see Swift Language and The Swift Programming Language (Swift 3). SiriKitApps that provide services in specific domains can use SiriKit to make those services available from Siri on iOS. Making your services available requires creating one or more app extensions using the Intents and Intents UI frameworks. SiriKit supports services in the following domains: Audio or video calling Messaging Sending or receiving payments Searching photos Booking a ride Managing workouts When the user makes a request involving your service, SiriKit sends your extension an intent object, which describes the user’s request and provides any data related to that request. You use the intent object to provide an appropriate response object, which includes details of how you can handle the user’s request. Siri typically handles all user interactions, but you can use an extension to provide custom UI that incorporates branding or additional information from your app. SiriKit also provides a mechanism you can use to tell the system about the interactions and activities that occur within your app.When you tell the system about these interactions, the system can determine if your app can handle the user’s current request and, if it can, pass the request to your app. In addition to the intent, SiriKit defines an interaction object, which combines an intent with information about the intent-handling process, including details such as the start time and duration of a specific occurrence of the process. If your app is registered as capable of handling an activity that has the same name as an intent, the system can launch your app with an interaction object containing that intent even if you don’t provide an Intents app extension. Ride booking is supported by both Maps and Siri, and users can also make restaurants reservations with Maps. Your Intents extension handles interactions that originate from the Maps app in the same way that it handles requests coming from Siri. If you customize the user interface, your Intents UI extension can also configure itself differently, depending on whether the request came from Siri or Maps. To learn how to support SiriKit and give users new ways to access your services, read SiriKit Programming Guide. When you’re ready to implement the app extensions that handle various intents, see Intents Framework Reference and Intents UI Framework Reference. Proactive SuggestionsiOS 10 introduces new ways to increase engagement with your app by helping the system suggest your app to users at appropriate times. If you adopted app search in your iOS 9 app, you gave users access to activities and content deep within your app through Spotlight and Safari search results, Handoff, and Siri suggestions. In iOS 10 and later, you can provide information about what users do in your app, which helps the system promote your app in additional places, such as the keyboard with QuickType suggestions, Maps and CarPlay, the app switcher, Siri interactions, and (for media playing apps) the lock screen. These opportunities for enhanced integration with the system are supported by a collection of technologies, such as NSUserActivity, web markup defined by Schema.org, and APIs defined in the Core Spotlight, MapKit, UIKit, and Media Player frameworks. In iOS 10, the NSUserActivity object includes the mapItem property, which lets you provide location information that can be used in other contexts. For example, if your app displays hotel reviews, you can use the mapItem property to hold the location of the hotel the user is viewing so that when the user switches to a travel planning app, that hotel’s location is automatically available. And if you support app search, you can use the new text-based address component properties in CSSearchableItemAttributeSet, such as thoroughfare and postalCode, to fully specify locations to which the user may want to go. Note that when you use the mapItem property, the system automatically populates the contentAttributeSet property, too. To share a location with the system, be sure to specify latitude and longitude values, in addition to values for the address component properties inCSSearchableItemAttributeSet. It’s also recommended that you supply a value for the namedLocation property, so that users can view the name of the location, and thephoneNumbers property, so that users can use Siri to initiate a call to the location. In iOS 9, adding markup to the structured data on your website enriched the content that users see in Spotlight and Safari search results. In iOS 10, you can use location-related vocabulary defined at Schema.org, such as PostalAddress, to further enhance the user’s experience. For example, if users view a location described on your website, the system can suggest the same location when users switch to Maps. Note that Safari supports both JSON-LD and Microdata encodings of Schema.org vocabularies. UIKit introduces the textContentType property in the UITextInputTraits protocol so that you can specify the semantic meaning of the content you expect users to enter in a text area. When you provide this information, the system can in some cases automatically select an appropriate keyboard and improve keyboard corrections and proactive integration with information supplied from other apps and websites. For example, if you use UITextContentTypeFullStreetAddress to tell the system that you expect users to enter a complete address in a text field, the system can suggest the address of a location the user was recently viewing. If your app plays media and you use the MPPlayableContentManager APIs, iOS 10 helps you let users view album art and play media through your app on the lock screen. If your ride-sharing app uses the MKDirectionsRequest API, iOS 10 can display it in the app switcher when the user is likely to want a ride. To register as a ride-share provider, specify the MKDirectionsModeRideShare value for the MKDirectionsApplicationSupportedModes key in your Info.plist file. If your app supports only ride sharing, the system suggests your app with text that begins “Get a ride to…”; if your app supports both ride sharing and another routing type (such as Automobile or Bike), the system uses the text “Get directions to…”. Note that the MKMapItem object you receive may not include latitude and longitude information and would require geocoding. Integrating with the Messages AppIn iOS 10, you can create app extensions that interact with the Messages app and let users send text, stickers, media files, and interactive messages. You can also support interactive messages that update as each recipient responds to the message. You can create two types of app extensions: A Sticker pack provides a set of stickers that users can add to their Messages content. An iMessage app lets you present a custom user interface within the Messages app, create a sticker browser, include text, stickers, and media files within a conversation, and create, send, and update interactive messages. An iMessage app can also help users search images that you host on your app’s related website while they’re in the Messages app. You can create a Sticker pack without writing any code: Simply drag images into the Sticker Pack folder inside the Stickers asset catalog in Xcode. To develop an iMessage app, you use the APIs in the Messages framework (Messages.framework). To learn about the Messages framework, see Messages Framework Reference. For general information about creating app extensions, see App Extension Programming Guide. If your app provides images for sharing in Messages and you want users to be able to use the Spotlight popular image search (that is, “#images”) to search these images without leaving the Messages app, first create an iMessage app. Then follow these steps: Add the com.apple.developer.associated-domains key to your app’s entitlements. Include a list of the web domains that host the images you want to make searchable. For each domain, specify the spotlight-image-search service. Add an apple-app-site-association file to your website. Add a dictionary for the spotlight-image-search service and include your app ID, which is the team ID or app ID prefix, followed by the bundle ID. You can also specify up to 500 paths and patterns that should be included for indexing by the Spotlight popular image search (for some examples of website paths, see the universal links examples in Creating and Uploading the Association File). Allow crawling by Applebot (to learn more, see About Applebot). User NotificationsiOS 10 introduces the User Notifications framework (UserNotifications.framework), which supports the delivery and handling of local and remote notifications. You use the classes of this framework to schedule the delivery of local notifications based on specific conditions, such as time or location. Apps and app extensions can use this framework to receive and potentially modify local and remote notifications when they are delivered to the user’s device. Also introduced in iOS 10, the User Notifications UI framework (UserNotificationsUI.framework) lets you customize the appearance of local and remote notifications when they appear on the user’s device. You use this framework to define an app extension that receives the notification data and provides the corresponding visual representation. Your extension can also respond to custom actions associated with those notifications. Speech RecognitioniOS 10 introduces a new API that supports continuous speech recognition and helps you build apps that can recognize speech and transcribe it into text. Using the APIs in the Speech framework (Speech.framework), you can perform speech transcription of both real-time and recorded audio. For example, you can get a speech recognizer and start simple speech recognition using code like this: let recognizer = SFSpeechRecognizer() let request = SFSpeechURLRecognitionRequest(url: audioFileURL) recognizer?.recognitionTask(with: request, resultHandler: { (result, error) in print (result?.bestTranscription.formattedString) }) As with accessing other types of protected data, such as Calendar and Photos data, performing speech recognition requires the user’s permission (for more information about accessing protected data classes, see Security and Privacy Enhancements). In the case of speech recognition, permission is required because data is transmitted and temporarily stored on Apple’s servers to increase the accuracy of speech recognition. To request the user’s permission, you must add the NSSpeechRecognitionUsageDescription key to your app’s Info.plist file. When you adopt speech recognition in your app, be sure to indicate to users that their speech is being recognized, and that they should not make sensitive utterances at that time. Wide ColorMost graphics frameworks throughout the system, including Core Graphics, Core Image, Metal, and AVFoundation, have substantially improved support for extended-range pixel formats and wide-gamut color spaces. By extending this behavior throughout the entire graphics stack, it is easier than ever to support devices with a wide color display. In addition, UIKit standardizes on working in a new extended sRGB color space, making it easy to mix sRGB colors with colors in other, wider color gamuts without a significant performance penalty. Here are some best practices to adopt as you start working with Wide Color. In iOS 10, the UIColor class uses the extended sRGB color space and its initializers no longer clamp raw component values to between 0.0 and 1.0. If your app relies on UIKit to clamp component values (whether you’re creating a color or asking a color for its component values), you need to change your app’s behavior when you link against iOS 10. When performing custom drawing in a UIView on an iPad Pro (9.7 inch), the underlying drawing environment is configured with an extended sRGB color space. If your app renders custom image objects, use the new UIGraphicsImageRenderer class to control whether the destination bitmap is created using an extended-range or standard-range format. If you are performing your own image processing on wide-gamut devices using a lower level API, such as Core Graphics or Metal, you should use an extended range color space and a pixel format that supports 16-bit floating-point component values. When clamping of color values is necessary, you should do so explicitly. Core Graphics, Core Image, and Metal Performance Shaders provide new options for easily converting colors and images between color spaces. Adapting to the True Tone DisplayThe True Tone display uses ambient light sensors to automatically adjust the color and intensity of the display to match the lighting conditions of the current environment. To ensure that your app works well with the standard color shift provided by True Tone, add the new UIWhitePointAdaptivityStyle key to your Info.plist file to describe your app’s primary visual content. For example: If your app is a photo editing app, color fidelity is more important than automatic adjustment to the environmental white point. In this case, you can use theUIWhitePointAdaptivityStylePhoto style to reduce the strength of True Tone shift applied by the system. If your app is a reading app, conformance with the environmental white point is helpful to users. In this case, you can use the UIWhitePointAdaptivityStyleReadingstyle to increase the strength of True Tone shift applied by the system. App Search EnhancementsiOS 10 and the Core Spotlight framework introduce several enhancements to app search: In-app searching Search continuation Crowdsourcing deep link popularity with differential privacy Visualization of validation results The new CSSearchQuery class supports in-app searches of content that you index using existing Core Spotlight APIs. Using this API can eliminate the need to maintain your own separate search index and lets you take advantage of Spotlight’s powerful search technology and matching rules to allow users to search for content without leaving your app, just as they do within Mail, Messages, and Notes. In iOS 9, using search APIs (such as Core Spotlight, NSUserActivity, and web markup) to index content within your app let users search for that content using the Spotlight and Safari search interfaces. In iOS 10, you can use new Core Spotlight symbols to let users continue a search they began in Spotlight when they open your app. To enable this feature, add the CoreSpotlightContinuation key to your Info.plist file, give it the value YES, and update your code to handle an activity continuation of typeCSQueryContinuationActionType. The user info dictionary in the NSUserActivity object that you receive in yourapplication:continueUserActivity:restorationHandler: method includes the CSSearchQueryString key, whose value is a string that represents the user’s query. iOS 10 introduces a differentially private way to help improve the ranking of your app’s content in search results. iOS submits a subset of differentially private hashes to Apple servers as users use your app and as NSUserActivity objects that include a deep link URL and have their eligibleForPublicIndexing property set to YES are submitted to iOS. The differential privacy of the hashes allows Apple to count the frequency with which popular deep links are visited without ever associating a user with a link. When you test your website markup and deep links using the App Search API Validation tool, it now displays a visual representation of your results, including supported markup, such as that defined at Schema.org. The validation tool can help you see information that the Applebot web crawler has indexed, such as the title, description, URL, and other supported elements. You can access the validation tool here: https://search.developer.apple.com/appsearch-validation-tool. To learn more about supporting deep links and adding markup, see Mark Up Web Content. To learn how to make your website’s images searchable within the Messages app, see Integrating with the Messages App. Widget EnhancementsiOS 10 introduces a new design for the lock screen, which now displays widgets. To ensure that your widget looks good on any background, you can specifywidgetPrimaryVibrancyEffect or widgetSecondaryVibrancyEffect, as appropriate (use these properties instead of the deprecatednotificationCenterVibrancyEffect property). In addition, widgets now include the concept of display mode (represented by NCWidgetDisplayMode), which lets you describe how much content is available and allows users to choose a compact or expanded view. Apple Pay EnhancementsIn iOS 10, users can make easy and secure payments using Apple Pay from websites and through interaction with Siri and Maps. For developers, iOS 10 introduces new APIs you can use in code that runs in both iOS and watchOS, the ability to support dynamic payment networks, and a new sandbox testing environment. iOS 10 introduces new APIs that help you incorporate Apple Pay directly into your website. When you support Apple Pay in your website, users browsing with Safari in iOS or OS X can make payments using their cards in Apple Pay on their iPhone or Apple Watch. To learn more, see ApplePay JS Framework Reference. The PassKit framework (PassKit.framework) introduces APIs that let you support Apple Pay in places where UIKit is not available. Specifically,PKPaymentAuthorizationController and PKPaymentAuthorizationControllerDelegate enable features provided by PKPaymentAuthorizationViewController and its delegate, but don’t require UIKit. Although the new API is required for supporting Apple Pay in watchOS and in certain intents, it’s recommended that you adopt it in all of your code so that you can provide broad Apple Pay support with a single code base. (To learn more about intents and Siri integration, see SiriKit.) The PassKit framework also adds features that let card issuers present their cards from within their apps. Specifically, the PKPaymentButtonTypeInStore button type lets you display an Apple Pay button for a card and the presentPaymentPass: method lets you programmatically display the card (the presentPaymentPass: method is defined inPKPassLibrary). When a new payment network becomes available, your app can automatically support the new network without requiring you to modify and recompile your app. TheavailableNetworks method lets you discover the networks that are available on the user’s device at runtime. In addition, the supportedNetworks property is expanded, so that it can take some payment provider names as an argument. Your app then automatically supports any networks that the payment provider supports. To learn more, seehttps://developer.apple.com/apple-pay/. iOS 10 introduces a new testing environment that lets you provision test cards directly on the device. The test environment returns encrypted test payment data. To use this environment, follow these steps: Create a testing iCloud Account at iTunes Connect. Log into that account on your device. Set the desired region for testing. Use test cards listed at https://developer.apple.com/apple-pay/. Note: When you switch iCloud accounts, the environment switches automatically.You must still test your payments using actual cards in an production environment. Security and Privacy EnhancementsiOS 10 introduces several changes and additions that help you improve the security of your code and maintain the privacy of user data. To learn more about these items, seehttps://developer.apple.com/security/. The new NSAllowsArbitraryLoadsInWebContent key for your Info.plist file gives you a convenient way to allow arbitrary web page loads to work while retaining ATS protections for the rest of your app. The SecKey API includes improvements for asymmetric key generation. Use the SecKey API instead of the deprecated Common Data Security Architecture (CDSA) APIs. The RC4 symmetric cipher suite is now disabled by default for all SSL/TLS connections, and SSLv3 is no longer supported in the Secure Transports API. It’s recommended that you stop using the SHA-1 and 3DES cryptographic algorithms as soon as possible. The UIPasteboard class supports the Clipboard feature, which lets users copy and paste between devices, and includes API you can use to restrict a pasteboard to a specific device and set an expiration timestamp after which the pasteboard is cleared. Additionally, named pasteboards are no longer persistent—instead, you should use shared containers—and the “Find” pasteboard (that is, the pasteboard identified by the UIPasteboardNameFind constant) is unavailable. You must statically declare your app’s intended use of protected data classes by including the appropriate purpose string keys in your Info.plist file. For example, you must include the NSCalendarsUsageDescription key to access the user’s Calendar data. If you don’t include the relevant purpose string keys, your app exits when it tries to access the data. CallKitThe CallKit framework (CallKit.framework) lets VoIP apps integrate with the iPhone UI and give users a great experience. Use this framework to let users view and answer incoming VoIP calls on the lock screen and manage contacts from VoIP calls in the Phone app’s Favorites and Recents views. CallKit also introduces app extensions that enable call blocking and caller identification. You can create an app extension that can associate a phone number with a name or tell the system when a number should be blocked. News Publisher EnhancementsNews Publisher makes it easy to deliver beautifully designed news, magazine, and web content to Apple News using the Apple News Format. Anyone can sign up, from major magazines or news organizations to independent publishers and bloggers. To get started or to learn more about recent updates, visit https://newsresources.apple.com. Video Subscriber AccountiOS 10 introduces the Video Subscriber Account framework (VideoSubscriberAccount.framework) to help apps that support authenticated streaming or authenticated video on demand (also known as TV Everywhere) authenticate with their cable or satellite TV provider. Using the APIs in this framework can help you support a single sign-in experience in which users sign in once to unlock access in all of the streaming video apps that their subscription supports. App ExtensionsiOS 10 introduces several new extension points for which you can create an app extension, such as: Call Directory Intents Intents UI Messages Notification Content Notification Service Sticker Pack In addition, iOS 10 includes the following enhancements for third-party keyboard app extensions: You can automatically detect the input language of a document by using the documentInputMode property of the UITextDocumentProxy class, and change your keyboard extension to align with that language (if supported). When you detect the input language in this way, you can do per-language keyboard switching such as what is built in to Messages. The new handleInputModeListFromView:withEvent: method lets a keyboard extension display the system’s keyboard picker menu (that is, the globe key menu). A keyboard extension should position the globe key in the same location as the system globe key for each orientation. Also, if you need to provide a custom key—to enable keyboard settings, for example—you should put this key in the same location as the dictation key in the system keyboard. To learn more about creating app extensions in general, see App Extension Programming Guide. Additional Framework ChangesIn addition to the major changes described above, iOS 10 includes many other improvements. AVFoundationThe AVFoundation framework (AVFoundation.framework) includes the following enhancements: The new AVCapturePhotoOutput class provides a unified pipeline for all photography workflows, enabling more sophisticated control and monitoring of the entire capture process and including support for new features such as Live Photos and RAW format capture. You should transition to AVCapturePhotoOutput instead ofAVCaptureStillImageOutput, which is deprecated in iOS 10. The Camera Capture pipeline now enables capture in wide-gamut color formats on supported hardware. By default, an AVCaptureSession automatically configures for wide-color capture when appropriate for your capture workflow—for details, see iOS Device Compatibility Reference. You no longer need to implement different behaviors for AVPlayerItem, depending on whether the content is a movie file or HLS content. In apps that link on or after iOS 10, you simply set the rate property and AVFoundation determines when enough content has been buffered to play without stalling. The AVPlayerLooper class makes it easier to loop a particular piece of media content during playback. Use the AVAssetDownloadURLSession and AVAssetDownloadURLSession classes to download an asset, including an HLS stream, to the device and then play it later. When used in conjunction with FairPlay Streaming, you can download an encrypted HLS stream and play the stream securely at a later time. AVKitThe AVKit framework (AVKit.framework) includes the updatesNowPlayingInfoCenter property, which indicates when the Now Playing Info Center should be updated. Core DataThe Core Data framework (CoreData.framework) includes the following enhancements: NSPersistentStoreCoordinator now maintains a connection pool for SQLite stores. Root NSManagedObjectContext objects (those without parent MOCs) transparently support concurrent fetching and faulting without serializing against each other. NSManagedObjectContext objects with SQLite stores in WAL journal_mode support a new feature called query generations. These allow a MOC to be pinned to a version of the database at a point in time and perform all future fetching and faulting against that version of the database. Pinned MOCs are moved to the most recent transaction with any save, and query generations do not survive the process’s life time. The new NSPersistentContainer class provides your app with a high-level integration point that maintains references to your NSPersistentStoreCoordinator,NSManagedObjectModel, and other configuration resources. Core Data now has tighter integration with Xcode and automatically generates and updates your NSManagedObject subclasses. NSManagedObject includes several additional convenience methods, making it easier to fetch and create subclasses. NSManagedObject subclasses that have a 1:1 relationship with an entity now support entity. Core Data introduces several API adjustments that provide better integration with Swift, including parameterized NSFetchRequest objects. For more information, see Core Data Framework Reference. Core ImageThe Core Image framework (CoreImage.framework) includes several enhancements. RAW image file support is now available on iOS devices that use the A8 or A9 CPU. Core Image can decode RAW images produced by several third-party cameras as well as images produced by the iSight camera of supported iOS devices (to learn more, see AVFoundation). To process RAW images, use filterWithImageData:options: orfilterWithImageURL:options: to create a CIFilter object, adjust RAW processing options with the keys listed in RAW Image Options, and read the processed image from the filter’s outputImage property. You can now insert custom processing into a Core Image filter graph by using theimageWithExtent:processorDescription:argumentDigest:inputFormat:outputFormat:options:roiCallback:processor: method. This method adds a callback block that Core Image invokes in between filters when processing an image for display or output; in the block, you can access the pixel buffers or Metal textures containing the current state of the processed image and apply your own image processing algorithms. When using a custom processor block or writing filter kernels, you can process images in a color space other than the Core Image context’s working color space. Use theimageByColorMatchingWorkingSpaceToColorSpace: and imageByColorMatchingColorSpaceToWorkingSpace: methods to convert into and out of your color space before and after processing. Performance is significantly improved for rendering UIImage objects that are backed by Core Image images (such as those created by using the initWithCIImage: initializer) in a UIImageView object. In addition, a Core Image–backed UIImage object that’s tagged with a wide-gamut color profile renders in a UIImageView object that uses wide-gamut color (on capable iOS devices). Core Image kernel code can now request a specific output pixel format. Core Image introduces five new filters: CINinePartTiled CINinePartStretched CIHueSaturationValueGradient CIEdgePreserveUpsampleFilter CIClamp Core MotionThe Core Motion framework (CoreMotion.framework) includes pedometer events, which enable apps to receive fast real-time notifications when users pause and resume while running. On supported devices, apps can use CMPedometer APIs to register to receive live pedometer events while running in the foreground or the background. FoundationThe Foundation framework (Foundation.framework) contains many enhancements, such as: The new NSDateInterval class defines a programmatic interface for calculating the duration of a time interval and determining whether a date falls within it, as well as comparing date intervals and checking to see whether they intersect. The NSLocale class defines many new properties that you can use to get information about a locale and how it can be displayed. The new NSMeasurement class helps you convert measurements into different units, and calculate the sum or difference between two measurements. The newNSMeasurementFormatter class helps you create localized representations of measurements when displaying quantities of units to the user. The new NSUnit class and concrete NSDimension subclasses help you represent specific units of measure. GameKitThe GameKit framework (GameKit.framework) includes the following changes and enhancements: The Game Center app has been removed. If your game implements GameKit features, it must also implement the interface behavior necessary for the user to see these features. For example, if your game supports leaderboards, it could present a GKGameCenterViewController object or read the data directly from Game Center to implement a custom user interface. A new account type, implemented by the GKCloudPlayer class, supports iCloud-only game accounts. Game Center provides a new generalized solution for managing persistent storage of data on Game Center. A game session (GKGameSession) has a list of players who are the session’s participants. Your game’s implementation defines when and how a participant stores or retrieves data from the server or exchanges data between players. Game sessions can often replace existing turn-based matches, real-time matches, and persistent save games, and also enable other models of interaction between participants. GameplayKitThe GameplayKit framework (GameplayKit.framework) includes the following changes and enhancements: Procedural noise generation can be used to generate rich game worlds, create sophisticated natural-looking textures, and add realism to camera movement. Spatial partitioning lets you partition your game world data so that the data in the game world can be searched efficiently. A new Monte Carlo strategist (GKMonteCarloStrategist) helps you model games where exhaustive computation of possible moves is difficult. The new decision tree API can enhance your game-building AI when you adopt decision-tree learning to generalize behavior based on data mining of logged player actions. To learn more, see GKDecisionTree and GKDecisionNode. The GKAgent3D and GKGraphNode3D classes introduce 3D support to existing agent and path-finding behavior. The new GKMeshGraph class provides a higher performance alternative to GKObstacleGraph, allowing you to produce more natural-looking output at the cost of less mathematically perfect paths. The new GKScene and GKSKNodeComponent classes, combined with changes in SpriteKit and the Xcode editor, make integrating GameplayKit with SpriteKit easier than ever. HealthKitThe HealthKit framework (HealthKit.framework) includes the following changes and enhancements: The new HKCDADocument class, which represents a CDA document (that is, a document that follows the Clinical Document Architecture standard). The new HKWorkoutConfiguration class, which lets you specify the activityType and locationType for a workout. The new HKWheelchairUseObject characteristic object type and the related HKHealthStore method wheelchairUseWithError:. New metadata keys that indicate weather types, such as HKWeatherConditionClear and HKWeatherConditionCloudy, and workout types, such asHKWorkoutActivityTypeFlexibility and HKWorkoutActivityTypeWheelchairRunPace. HomeKitIn iOS 10, iPad can be configured to provide remote access to accessories, run automation triggers, and enable shared user permissions. In addition, the HomeKit framework (HomeKit.framework) adds support for camera and doorbell accessories and introduces many new APIs that help you: View and interact with IP camera accessory profiles, display live streams and snapshots, and control a camera’s settings, speaker, and microphone Access new services and characteristics For the primary service, link services and valid values to provide more context and configuration about the accessories You can also add and set up accessories using the Apple accessory setup workflow. To learn more, see HomeKit Framework Reference. MetalIn iOS 10, Metal includes several new features and enhancements, such as: Support for tessellation, enabling 3D apps and games to render more detailed scenes by efficiently describing complex geometry to the GPU. Function Specialization, which makes it easy to create a collection of highly optimized functions to handle all the material and light combinations in a scene. Resource Heaps and Memoryless Render Targets, which grant even finer-grained control of resource allocation to further optimize the performance of Metal-based apps. To learn more, see What’s New in iOS 10, tvOS 10, and OS X 10.12 in Metal Programming Guide. ModelIOThe ModelIO framework (ModelIO.framework) includes the following enhancements: The USD file format is now supported. The new MDLMaterialPropertyGraph class makes it easier to support runtime procedural changes to models. The MDLVoxelArray class adds support for signed distance fields. You can add assisted light probe placement by implementing the MDLLightProbeIrradianceDataSource protocol. PhotosThe Photos framework (Photos.framework) makes Live Photo editing available to apps that use Photos framework APIs to access the user’s Photos library and to photo editing app extensions for use in the Photos and Camera apps. Specifically, the new PHLivePhotoEditingContext class lets you apply edits to the video and still photo content of a Live Photo, with an easy-to-use API based on Core Image enhancements. In addition, you can take advantage of the new Core Image processor feature to use other image processing technologies to perform edits. To learn more, see CIImageProcessorInput and CIImageProcessorOutput. ReplayKitThe ReplayKit framework (ReplayKit.framework) includes the following enhancements: ReplayKit supports broadcasting services so that a user can broadcast recorded media through a third-party site. You can implement support for this functionality by using the RPScreenRecorder, RPBroadcastActivityViewController, and RPBroadcastController classes. To participate in ReplayKit broadcast, third-party broadcast services need to implement a pair of app extensions. The Broadcast UI extension provides a UI that lets users sign into the service and set up a broadcast. The Broadcast Upload extension receives movie clips and transmits them to the service. SceneKitThe SceneKit framework (SceneKit.framework) includes several enhancements. A new Physically Based Rendering (PBR) system allows you to leverage the latest in 3D graphics research to create more realistic results with simpler asset authoring. Specifically: Use the new SCNLightingModelPhysicallyBased shading model to opt into PBR shading for materials. PBR materials require only three fundamental properties—diffuse,metalness, and roughness—to produce a wide range of realistic shading effects. (The normal, ambientOcclusion, and selfIllumination material properties also remain useful for PBR materials, but you can now ignore the large number of other properties used for traditional materials.) PBR shading works best with environment-based lighting, which causes even diffuse surfaces to pick up the colors of the scene around them. Use thelightingEnvironment property to assign global image-based lighting to an entire scene, and place light probes in the Xcode scene editor to pick up the local lighting contributions from objects within your scene. Authors of PBR scene content often prefer working in physically based terms, so you can now define lighting using intensity (in lumens) and color temperature (in degrees Kelvin), and import specifications for real-world light fixtures using the IESProfileURL property. Add even more realism with the new HDR features and effects in the SCNCamera class. With HDR rendering, SceneKit captures a much wider range of brightness and contrast in a scene, then allows you to customize the tone mapping that adapts that scene for the narrower range of a device’s display. Enable exposure adaptation to create automatic effects when, for example, the player in your game moves from a darkened area into sunlight. Or use vignetting, color fringing, and color grading to add a filmic look to your game. Although linear, more color-accurate rendering is the basis for PBR shading and HDR camera features, it produces better results even for traditional rendering. By default, SceneKit now performs all color calculations in a linear (not gamma-adjusted) color space, and uses the P3 color gamut of devices that include wide-color displays. This feature is enabled automatically for all apps linking against the iOS 10 SDK, and has a few ramifications for content design and asset management: SceneKit color matches all colors. In previous versions, SceneKit would read only the color values from material colors specified as NSColor or UIColor objects, ignoring color profile information and assuming the sRGB color space. SceneKit interprets color component values specified within shader modifier or custom Metal or OpenGL shader code in linear RGB space. SceneKit reads and adjusts for color profile information in texture images. Design textures for a linear brightness ramp, and use Asset Catalogs in Xcode to make sure your images use the correct color profile. If necessary, you can disable linear space rendering with the SCNDisableLinearSpaceRendering key in your app’s Info.plist file, and wide color rendering with theSCNDisableWideGamut key. Geometry can now be loaded from scene files or programmatically defined using arbitrary polygon primitives (SCNGeometryPrimitiveTypePolygon). SceneKit automatically triangulates polygon meshes for rendering, but makes use of the underlying polygon mesh for more accurate surface subdivision (to learn more, see the subdivisionLevelproperty). SpriteKitThe SpriteKit framework (SpriteKit.framework) includes the following enhancements: A new tilemap solution supports square, hexagonal, and isometric tilemaps that make it easy to create 2D, 2.5D, and side-scroller games. The Xcode editor provides comprehensive support for organizing your tiles and creating your tilemap. For more information, see the SKTileMapNode, SKTileGroup, SKTileGroupRule, andSKTileSet classes . The new SKWarpGeometry class is used to stretch or distort how a SKSpriteNode or SKEffectNode object is rendered. The warp is specified by a set of control points. NewSKAction types can be used to animate between different warp effects. A custom shader can use attributes that can be configured separately by each node that uses the shader. To add an attribute, create an SKAttribute object and attach it to your shader. Then, for each node that uses that shader, attach an SKAttributeValue object.] The SKView class defines new methods that give you finer control over when and how your scene is rendered. UIKitThe UIKit framework (UIKit.framework) includes many enhancements, such as: New object-based, fully interactive and interruptible animation support that lets you retain control of your animations and link them with gesture-based interactions. To learn more, see UIViewAnimating Protocol Reference, UIViewPropertyAnimator Class Reference, UITimingCurveProvider Protocol Reference, UICubicTimingParameters Class Reference, and UISpringTimingParameters Class Reference. The new UIPreviewInteraction class and UIPreviewInteractionDelegate protocol, which let you provide a custom user interface related to the peek and pop experience. The new UIAccessibilityCustomRotor class and related classes that help you provide custom, context-specific functionality that assistive technologies such as VoiceOver can expose to users. For example, you might create a custom rotor that lets VoiceOver users find misspelled words in a document by repeatedly returning the range of text that contains the next misspelled word. The UIAccessibilityIsAssistiveTouchRunning and UIAccessibilityAssistiveTouchStatusDidChangeNotification symbols, which let you determine when AssistiveTouch is enabled, and the UIAccessibilityHearingDevicePairedEar and UIAccessibilityHearingDevicePairedEarDidChangeNotification symbols, which give you the pairing status of MFi hearing aids. New UIPasteboard API that automatically declares compatible content types for common class instances and new options that limit the lifetime of objects on the pasteboard. New options in UIPasteboard The new preferredFontForTextStyle:compatibleWithTraitCollection: UIFont method, which lets you add support for Dynamic Type in labels, text fields, and other text areas. The UIContentSizeCategoryAdjusting protocol, which provides the adjustsFontForContentSizeCategory property that you can use to determine if the adopting element should update its font when the device’s UIContentSizeCategory changes. Additional control over the appearance of the badge on a tab bar item, such as background color and text attributes. Support for the refresh control in all scroll views and scroll-view subclasses, such as UICollectionView. The new UIApplication method openURL:options:completionHandler:, which is executed asynchronously and calls the specified completion handler on the main queue (this method replaces openURL:). The new UICloudSharingController class and UICloudSharingControllerDelegate protocol, which help you initiate a CloudKit sharing operation and display a view controller that lets users view and modify participants and start and stop sharing. Enhancements to UICollectionView and the new UICollectionViewDataSourcePrefetching protocol, which help you take advantage of automatic prefetching of cells to improve the scrolling experience. WebKitThe WebKit framework (WebKit.framework) introduces enhanced peek and pop support in WKWebView objects. In iOS 10, you can use the webView:shouldPreviewElement:method to determine if the specified web view should display the preview. Deprecated APIsiOS 10 deprecates several APIs, including: The CloudKit CKDiscoverAllContactsOperation, CKDiscoveredUserInfo, CKDiscoverUserInfosOperation, CKFetchRecordChangesOperation classes. Instead, use CKDiscoverAllUserIdentitiesOperation, CKUserIdentity, CKDiscoverUserIdentitiesOperation, and CKFetchRecordZoneChangesOperation classes, all of which support record sharing. Several CKSubscription APIs, such as methods and properties related to zone-based subscriptions (use CKRecordZoneSubscription APIs instead) and to query-based subscriptions (use CKQuerySubscription APIs instead). Several NSPersistentStoreCoordinator symbols related to ubiquitous content. The ADBannerView and ADInterstitialAd classes and related symbols in UIViewController. Several SKUniform symbols related to floating point values. Instead, use methods such as initWithName:vectorFloat2: and uniformWithName:matrixFloat2x2:, as appropriate. Several UIKit classes related to notifications, such as UILocalNotification, UIMutableUserNotificationAction, UIMutableUserNotificationCategory,UIUserNotificationAction, UIUserNotificationCategory, and UIUserNotificationSettings. Use APIs in the User Notifications framework instead (see User Notifications Framework Reference). The handleActionWithIdentifier:forLocalNotification:, handleActionWithIdentifier:forRemoteNotification:,didReceiveLocalNotification:withCompletion:, and didReceiveRemoteNotification:withCompletion: WatchKit methods. UsehandleActionWithIdentifier:forNotification: and didReceiveNotification:withCompletion: instead. Also the notification-handling methods in WKExtensionDelegate, such as didReceiveRemoteNotification: andhandleActionWithIdentifier:forRemoteNotification:. Instead of using these methods, first create a delegate object that adopts theUNUserNotificationCenterDelegate protocol and implement the appropriate methods. Then assign the delegate object to the delegate property of the singletonUNUserNotificationCenter object. For a complete list of specific API deprecations, see iOS 10.0 API Diffs.","categories":[],"tags":[{"name":"iOS新特性","slug":"iOS新特性","permalink":"https://wilddylan.github.io/tags/iOS新特性/"}],"keywords":[]},{"title":"方便的处理在StoryBoard、Xib中的圆角设置","slug":"方便的处理在StoryBoard、Xib中的圆角设置","date":"2016-08-15T09:57:28.000Z","updated":"2017-02-04T09:03:08.000Z","comments":true,"path":"2016/08/15/方便的处理在StoryBoard、Xib中的圆角设置/","link":"","permalink":"https://wilddylan.github.io/2016/08/15/方便的处理在StoryBoard、Xib中的圆角设置/","excerpt":"直奔主题, 怎么能方便的在StoryBoard与Xib中设置圆角呢？ runtime属性？awakeFromNib？ 直接使用Catrgory来实现！ 123456//UIView+O2CornerRadius.h@interface UIView (O2CornerRadius) @property (nonatomic, assign) IBInspectable CGFloat cornerRadius; @end 12345678910111213//UIView+O2CornerRadius.m@implementation UIView (O2CornerRadius) - (void)setCornerRadius:(CGFloat)cornerRadius&#123; self.layer.cornerRadius = cornerRadius;&#125; - (CGFloat)cornerRadius&#123; return self.layer.cornerRadius;&#125;@end","text":"直奔主题, 怎么能方便的在StoryBoard与Xib中设置圆角呢？ runtime属性？awakeFromNib？ 直接使用Catrgory来实现！ 123456//UIView+O2CornerRadius.h@interface UIView (O2CornerRadius) @property (nonatomic, assign) IBInspectable CGFloat cornerRadius; @end 12345678910111213//UIView+O2CornerRadius.m@implementation UIView (O2CornerRadius) - (void)setCornerRadius:(CGFloat)cornerRadius&#123; self.layer.cornerRadius = cornerRadius;&#125; - (CGFloat)cornerRadius&#123; return self.layer.cornerRadius;&#125;@end 导入全局的pch中, 然后你发现, 世界变了。 Xcode6之后运行时属性升级到了 @IBInspectable ，利用这个我们可以给 UIView 添加一个属性，然后就可以在IB中进行设置 Copy @aotu.io 2016.8.15 By Dylan.","categories":[],"tags":[{"name":"UIKit","slug":"UIKit","permalink":"https://wilddylan.github.io/tags/UIKit/"}],"keywords":[]},{"title":"Crash 收集","slug":"Crash","date":"2016-08-05T01:30:49.000Z","updated":"2017-02-04T09:02:09.000Z","comments":true,"path":"2016/08/05/Crash/","link":"","permalink":"https://wilddylan.github.io/2016/08/05/Crash/","excerpt":"通常情况下, App中会做崩溃的日志收集, 以便进行问题的追踪。奋斗提供了多个平台日志捕获的代码片断。 崩溃捕获在iOS中碰到异常之后, 捕获异常, 在Log的位置做日志记录, 崩溃次数统计, 下次启动可以做日志上传或者应用启动保护。下边的runLoop相关的代码的所用是把当前App的RunLoop跑起来, 让程序可以继续运作, 但是某些功能可能无法使用, 可以避免大部分闪退。这段代码是很久以前学自孙源。 下边的代码可以满足最简单的日志收集。成熟的开源项目有 KSCrash、plcrashreporter、CrashKit等。如果想自己的做的更全面就要涉及到更多的知识了, 这篇文章可以帮到你漫谈iOS Crash收集, 如果细读的话, 请注意多个 Crash 日志收集服务共存的坑。","text":"通常情况下, App中会做崩溃的日志收集, 以便进行问题的追踪。奋斗提供了多个平台日志捕获的代码片断。 崩溃捕获在iOS中碰到异常之后, 捕获异常, 在Log的位置做日志记录, 崩溃次数统计, 下次启动可以做日志上传或者应用启动保护。下边的runLoop相关的代码的所用是把当前App的RunLoop跑起来, 让程序可以继续运作, 但是某些功能可能无法使用, 可以避免大部分闪退。这段代码是很久以前学自孙源。 下边的代码可以满足最简单的日志收集。成熟的开源项目有 KSCrash、plcrashreporter、CrashKit等。如果想自己的做的更全面就要涉及到更多的知识了, 这篇文章可以帮到你漫谈iOS Crash收集, 如果细读的话, 请注意多个 Crash 日志收集服务共存的坑。 12345678910111213141516171819-(BOOL)install&#123; NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler); return YES;&#125;void UncaughtExceptionHandler(NSException *exception) &#123; NSArray *callStack = [exception callStackSymbols]; NSString *reason = [exception reason]; NSString *name = [exception name]; NSString *content = [NSString stringWithFormat:@\"\\n异常错误报告\\nname:%@\\nreason:\\n%@\\ncallStackSymbols:\\n%@\",name,reason,[callStack componentsJoinedByString:@\"\\n\"]]; DLogOut(@\"%@\", content); CFRunLoopRef runLoop = CFRunLoopGetCurrent(); NSArray * modes = CFBridgingRelease(CFRunLoopCopyAllModes(runLoop)); while (1) &#123; for (NSString * mode in modes) &#123; CFRunLoopRunInMode((CFStringRef)mode, 0.001, false); &#125; &#125;&#125; 信息上传收集到错误信息后, 在第二次启动的时候自然要上传用户的崩溃信息。一般来说, 部分程序提供了关闭日志与错误搜集这个功能的开关。但是大部分程序都是默认开启这项功能, 包括苹果一直在默默的收集Crash日志。 主要的流程：-ApplicationDidFinishLaunch之后首先检查用户是否开启了错误收集与反馈, 进而决定是否上传错误日志。 判断本地是否存在未上报的错误日志文件, 如果符合条件, 上报当前的崩溃日志, 清空本地日志。一个简单的网络请求而已, 这里不做代码的展示。 当然, App也可以合理的提供一些BUG反馈的界面, 如果没有提供可以使用友盟、蒲公英类似的摇一摇反馈等。 程序崩溃保护 启动崩溃 程序有可能在启动的时候就崩溃了, 这怎么办呢？微信读书给出了很好的方案, 原文在这里启动连续闪退保护。原理其实很简单, 捕获到程序在一定时间内没有退出的话, 为正常启动。否则清零计数, 当错误计数达到了设置的最大次数时候, 调用Block进行用户自己的一些处理（文中一处有思路问题：程序启动用户就滑掉了, 其实不会影响的, 只要在AppDelegate-程序退入后台的方法中做一些手脚就好了, 滑掉应用也是要先退入后台）。 总体来说框架思路还是很直接的, 程序启动嘛, 5s差不多用户已经进去了, 所以代码达到了作者的初始思路。光是启动保护其实并没有什么大的用处, 可以在自己做的时候加入一些更好的处理方式。启动崩溃使用上边提到的框架可以解决部分问题。 使用中崩溃 在使用中崩溃, 在调试的时候, 有很多次实际是崩溃到了main函数中, 在我们打开全局断电以及僵尸模式等调试设置后, 大部分的崩溃还是会定位到出错的位置, 但是我们在不调试的时候怎么知道某一个用户是崩溃到什么位置呢？因为什么崩溃？还是要牵扯到最开始提到的Crash捕获, 在这里我们就要做错误的分析。通常的崩溃的callstack中我们可以得到部分想要的信息, 然后就是联合判断。 实际我们做的, 所有的Model都继承基类, 会有自己的标识, 被持有的对象标识等, 其他视图的基类也有对应的标识。建议大家这么做, 任何时候都有好处。 核心的思路是, 获取到Window当前的VC, 然后运行时取出这个VC相关的信息, 进行定位与分析。 这个方法可以准确的定位到80%的错误发生, 可以直接定位到具体的VC, 然后结合callStack中的一些信息就可以方便的定位到错误。这样, 我们定位错误的能力提升到80%, 在加上我们对应用的数据打点以及用户的行为追踪, 定位错误的能力提升了更多！。 这里提供一片关于BUG信息分析的文章iOS崩溃日志解密。当然为了懒, 你也可以使用念茜提到的Crashlytics, Hockeyapp这样一体的解决方案。 文章到此结束, 下边是本周干货 杀死野指针（MRC老项目细看） 开发期间 开发中我们发现, 哎呦, 我们自己测试的没有问题, 为什么别人一用就有问题, 或者是偶尔出现问题？这就是已经被释放的对象在搞鬼。有些对象被release了, 但是他占用的那一块内存保存完好, 有可能不Crash, 访问了不可访问的数据, 肯定会Crash。对象释放后内存被改动过，写上了可以访问的数据，但是再次访问的时候执行的代码把别的数据写坏了，遇到这种Crash只能哭了（随机Crash，难度大，概率低）, 对象释放后再次release（几乎是必现Crash，但也有例外，很常见）。 加入全局断点 做下边的配置 在调试中, 看看就知道, 总之我知道最常见的野指针是会出来见你的。 但是这是你插着调试, 如果打包内测就没有办法了, 所以这里我们还提供另一种方法, HOOK, 涉及到的方法一般是dealloc,object_dispose,free。这里我们直接选择去hookC语言的free方法, 这里用到了facebook·fishhook, 在Main函数中直接进行Hook。 123456789101112131415161718192021222324#import \"fishhook.h\"#import &lt;malloc/malloc.h&gt;static void (*origin_free)(void *);void hook_free(void * p) &#123; size_t memSiziee = malloc_size(p); memset(p, 0x55, memSiziee); printf(\"call origin free\"); origin_free(p); return;&#125;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; // Hook free method. rebind_symbols((struct rebinding[1])&#123;&#123;\"free\", hook_free, (void *)&amp;origin_free&#125;&#125;, 1); return UIApplicationMain(argc, argv, nil, NSStringFromClass([INSApp class])); &#125;&#125; 这个时候运行程序发现调用了我们的hook-free方法, 这里为什么把已经被free的内容覆盖为0x55呢？ 实际上填写数据的关键在于填写数据后其地址指向不可读的内存。而填写0x55，和出现异常情况的对象地址0x555555连接起来被当成指针使用的话，就会被识别为0x55555555，而CPU访问这个地址就会抛出异常。另外一点，就是方便区分野指针，例如在Xcode启用Enable Scribble时，指定alloc之后填写的地址为0xaa，防止内存初始化就使用，也是为了方便和free之后的内存做区分。 下边的文章自行细读, 我就不在这里扯了 ~ 调试时候让Crash随机成必现1 调试时候让Crash随机成比现2 让野指针自报家门 HTTPSHTTPS 安全在哪里呢? 逆向工程（你想自动拆红包？&lt;老文章了&gt;）揭秘1 揭秘2 动画渲染机制动画渲染机制","categories":[],"tags":[{"name":"崩溃日志","slug":"崩溃日志","permalink":"https://wilddylan.github.io/tags/崩溃日志/"}],"keywords":[]}]}